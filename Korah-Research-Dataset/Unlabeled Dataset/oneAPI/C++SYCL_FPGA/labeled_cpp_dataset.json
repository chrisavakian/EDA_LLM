[
    {
        "label": "pca_demo.cpp",
        "data": "#include <cmath>\n#include <sycl/ext/intel/ac_types/ac_int.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n#include <vector>\n\n#define DEBUG 0\n\n#include \"exception_handler.hpp\"\n#include \"golden_pca.hpp\"\n#include \"pca.hpp\"\n\nint main(int argc, char *argv[]) {\n#if defined(FPGA_SIMULATOR)\n  // Only read a few lines of the input data when running the simulator\n  constexpr size_t kPCAsToCompute = 1;\n  constexpr size_t kFeaturesCount = 4;\n  constexpr size_t kSamplesCount = 8;\n  constexpr bool kBenchmarkMode = false;\n  constexpr bool kBenchmarkModeForcelyDisabled = true;\n  std::cout << \"The benchmark mode is disabled when running the simulator\"\n            << std::endl;\n#elif BENCHMARK\n  constexpr size_t kPCAsToCompute = 1;\n  constexpr size_t kFeaturesCount = 8;\n  constexpr size_t kSamplesCount = 4176;\n  constexpr bool kBenchmarkMode = true;\n  constexpr bool kBenchmarkModeForcelyDisabled = false;\n#else\n  constexpr size_t kPCAsToCompute = 8;\n  constexpr bool kBenchmarkMode = false;\n  constexpr bool kBenchmarkModeForcelyDisabled = false;\n  constexpr size_t kFeaturesCount = FEATURES_COUNT;\n  constexpr size_t kSamplesCount = SAMPLES_COUNT;\n#endif\n\n  constexpr size_t kAMatrixSize = kSamplesCount * kFeaturesCount;\n  constexpr size_t kEigenValuesCount = kFeaturesCount;\n  constexpr size_t kEigenVectorsMatrixSize = kFeaturesCount * kFeaturesCount;\n\n  constexpr int k_zero_threshold_1e = -8;\n\n#if defined(FPGA_EMULATOR) or defined(FPGA_SIMULATOR)\n  int repetitions = 1;\n#else\n  int repetitions = 4096;\n#endif\n  std::string in_file_name = \"\";\n\n  if constexpr (kBenchmarkMode || kBenchmarkModeForcelyDisabled) {\n    // We expect to read the dataset path from the program arguments\n    if ((argc != 2) && (argc != 3)) {\n      std::cout << \"Usage: \" << std::endl\n                << \"./pca.xxx <path to abalone.csv> n\" << std::endl\n                << \"where n is an optional parameter which specifies how many \"\n                   \"times to \"\n                   \"repeat the computation (for performance evaluation) \"\n                << std::endl;\n      std::terminate();\n    }\n\n    // Get the file path\n    in_file_name = std::string(argv[1]);\n\n    if (argc == 3) {\n      // get the number of repetitions\n      repetitions = std::stoi(argv[2]);\n    }\n  } else {\n    // We expect to read the dataset path from the program arguments\n    if (argc == 2) {\n      // get the number of repetitions\n      repetitions = std::stoi(argv[1]);\n    }\n  }\n\n  // Get the number of times we want to repeat the decomposition\n  // from the command line.\n\n  if (repetitions < 1) {\n    std::cout << \"Number of repetitions is lower that 1.\" << std::endl;\n    std::cout << \"The computation must occur at least 1 time.\" << std::endl;\n    std::cout << \"Increase the number of repetitions (e.g. 16).\" << std::endl;\n    return 1;\n  }\n\n  try {\n    // Device selector selection\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // Enable the queue profiling to time the execution\n    sycl::property_list queue_properties{\n        sycl::property::queue::enable_profiling()};\n    sycl::queue q =\n        sycl::queue(selector, fpga_tools::exception_handler, queue_properties);\n\n    sycl::device device = q.get_device();\n\n    // Print out the device information.\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>() << std::endl;\n\n    // Create vectors to hold all the input and output matrices\n    std::vector<float> a_matrix;\n    std::vector<float> eigen_values_vector;\n    std::vector<float> eigen_vectors_matrix;\n    std::vector<ac_int<1, false>> rank_deficient_flag;\n\n    a_matrix.resize(kAMatrixSize * kPCAsToCompute);\n    eigen_values_vector.resize(kEigenValuesCount * kPCAsToCompute);\n    eigen_vectors_matrix.resize(kEigenVectorsMatrixSize * kPCAsToCompute);\n    rank_deficient_flag.resize(kPCAsToCompute);\n\n    if (kBenchmarkMode) {\n      std::cout << \"Reading the input data from file.\" << std::endl;\n      std::cout << \"Features count: \" << kFeaturesCount << std::endl;\n      std::cout << \"Samples count: \" << kSamplesCount << std::endl;\n    } else {\n      std::cout << \"Generating \" << kPCAsToCompute << \" random \";\n      std::cout << \"matri\" << (kPCAsToCompute > 1 ? \"ces\" : \"x\") << \" of size \"\n                << kSamplesCount << \"x\" << kFeaturesCount << \" \" << std::endl;\n    }\n\n    constexpr bool print_debug_information = false;\n\n    GoldenPCA<double> pca(kSamplesCount, kFeaturesCount, kPCAsToCompute,\n                          print_debug_information, kBenchmarkMode,\n                          in_file_name);\n    pca.populateA();\n    pca.standardizeA();\n    pca.computeCovarianceMatrix();\n    pca.computeEigenValuesAndVectors();\n\n    // Copy all the input matrices to the of the golden implementation to the\n    // a_matrix that uses the float datatype, which is going to be used by the\n    // hardware implementation\n    for (int matrix_index = 0; matrix_index < kPCAsToCompute; matrix_index++) {\n      for (int row = 0; row < kSamplesCount; row++) {\n        for (int column = 0; column < kFeaturesCount; column++) {\n          a_matrix[matrix_index * kFeaturesCount * kSamplesCount +\n                   column * kSamplesCount + row] =\n              pca.a_matrix[matrix_index * kFeaturesCount * kSamplesCount +\n                           row * kFeaturesCount +\n                           column];  // implicit double to float cast here\n        }\n      }\n    }\n\n    std::cout << \"Running Principal Component analysis of \" << kPCAsToCompute\n              << \" matri\" << (kPCAsToCompute > 1 ? \"ces \" : \"x \") << repetitions\n              << \" times\" << std::endl;\n\n    PCAKernel<kSamplesCount, kFeaturesCount, FIXED_ITERATIONS,\n              k_zero_threshold_1e>(a_matrix, eigen_values_vector,\n                                   eigen_vectors_matrix, rank_deficient_flag, q,\n                                   kPCAsToCompute, repetitions);\n\n    if (DEBUG) {\n      for (int matrix_index = 0; matrix_index < kPCAsToCompute;\n           matrix_index++) {\n        std::cout << \"\\n Results : \" << matrix_index << std::endl;\n        std::cout << \"\\n Eigen Values: \\n\";\n        for (int i = 0; i < kFeaturesCount; i++) {\n          std::cout << eigen_values_vector[matrix_index * kEigenValuesCount + i]\n                    << \" \";\n        }\n        std::cout << \"\\n\";\n\n        std::cout << \"\\n Eigen Vectors: \\n\";\n        for (int i = 0; i < kFeaturesCount; i++) {\n          for (int j = 0; j < kFeaturesCount; j++) {\n            std::cout\n                << eigen_vectors_matrix[matrix_index * kEigenVectorsMatrixSize +\n                                        i * kFeaturesCount + j]\n                << \" \";\n          }\n          std::cout << \"\\n\";\n        }\n      }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    /////////  Sorting and matching with golden value ///////////////////\n    /////////////////////////////////////////////////////////////////////\n    std::cout << \"Verifying results...\" << std::endl;\n\n    std::vector<int> sort_index_golden(kFeaturesCount);\n    int passed_matrices = 0;\n    int kernel_innacurate_result_flag_count = 0;\n    for (int matrix_index = 0; matrix_index < kPCAsToCompute; matrix_index++) {\n      if (rank_deficient_flag[matrix_index] != 0) {\n        // Skip the verification of the current matrix as it was flagged as\n        // rank deficient, which is not supported by the kernel\n        kernel_innacurate_result_flag_count++;\n        continue;\n      }\n\n      int eigen_vectors_offset = matrix_index * kEigenVectorsMatrixSize;\n      int eigen_values_offset = matrix_index * kEigenValuesCount;\n\n      // Initialize the indexes for sorting the eigen values.\n      for (int i = 0; i < kFeaturesCount; i++) {\n        sort_index_golden[i] = i;\n      }\n\n      // Sort the golden Eigen values by reordering the indexes that we are\n      // going to access\n      // The Eigen values and vectors from the kernel are already sorted\n      std::sort(sort_index_golden.begin(), sort_index_golden.end(),\n                [=](int a, int b) {\n                  return fabs(pca.eigen_values[eigen_values_offset + a]) >\n                         fabs(pca.eigen_values[eigen_values_offset + b]);\n                });\n\n      // Absolute threshold at which we consider there is an error\n      constexpr float k_diff_threshold = 1e-2;\n      int eigen_values_errors = 0;\n\n      // Check the Eigen values\n      for (int i = 0; i < kFeaturesCount; i++) {\n        int sorted_index_golden = sort_index_golden[i];\n\n        float golden_eigen_value =\n            pca.eigen_values[eigen_values_offset + sorted_index_golden];\n        float kernel_eigen_value = eigen_values_vector[eigen_values_offset + i];\n\n        if (fabs(fabs(golden_eigen_value) - fabs(kernel_eigen_value)) >\n                k_diff_threshold ||\n            std::isnan(golden_eigen_value) || std::isnan(kernel_eigen_value)) {\n          eigen_values_errors++;\n          std::cout\n              << \"Mismatch between golden and kernel Eigen value for matrix \"\n              << matrix_index << std::endl\n              << \"golden: \" << golden_eigen_value << std::endl\n              << \"kernel: \" << kernel_eigen_value << std::endl;\n        }\n      }\n\n      if (eigen_values_errors != 0) {\n        std::cout << \"Matrix: \" << matrix_index << std::endl\n                  << \"Eigen values mismatch count: \" << eigen_values_errors\n                  << std::endl;\n      }\n\n      // Check the Eigen vectors\n      int eigen_vectors_errors = 0;\n      for (int row = 0; row < kFeaturesCount; row++) {\n        for (int column = 0; column < kFeaturesCount; column++) {\n          float golden_vector_element =\n              pca.eigen_vectors[eigen_vectors_offset + row * kFeaturesCount +\n                                sort_index_golden[column]];\n          float kernel_vector_element =\n              eigen_vectors_matrix[eigen_vectors_offset +\n                                   column * kFeaturesCount + row];\n\n          if (fabs(fabs(golden_vector_element) - fabs(kernel_vector_element)) >\n                  k_diff_threshold ||\n              std::isnan(golden_vector_element) ||\n              std::isnan(kernel_vector_element)) {\n            eigen_vectors_errors++;\n\n            std::cout << \"Mismatch between golden and kernel Eigen vector \"\n                      << \"at index \" << row << \", \" << column << \" in matrix \"\n                      << matrix_index << std::endl\n                      << \"golden: \" << golden_vector_element << std::endl\n                      << \"kernel: \" << kernel_vector_element << std::endl\n                      << std::endl;\n          }\n        }\n      }\n\n      if (eigen_vectors_errors != 0) {\n        std::cout << \"Matrix: \" << matrix_index << std::endl\n                  << \"Eigen vector elements mismatch count: \"\n                  << eigen_vectors_errors << std::endl;\n      } else {\n        passed_matrices++;\n      }\n\n    }  // end for:matrix_index\n\n    if (kernel_innacurate_result_flag_count > 0) {\n      std::cout << \"During the execution, the kernel identified \"\n                << kernel_innacurate_result_flag_count\n                << \" rank deficient matrices.\" << std::endl;\n      std::cout << \"These matrices were omitted from the data verification.\"\n                << std::endl;\n    }\n\n    if ((passed_matrices + kernel_innacurate_result_flag_count) <\n        kPCAsToCompute) {\n      std::cerr << \"Errors were identified.\" << std::endl;\n      std::cerr << \"Pass rate: \"\n                << (100.0 *\n                    (passed_matrices + kernel_innacurate_result_flag_count)) /\n                       (kPCAsToCompute)\n                << \"%\" << std::endl;\n      std::terminate();\n    }\n\n    std::cout << \"All the tests passed.\" << std::endl;\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::terminate();\n  }\n\n  return 0;\n}  // end of main\n"
    },
    {
        "label": "main.cpp",
        "data": "#include <algorithm>\n#include <array>\n#include <chrono>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\n#include \"merge_sort.hpp\"\n\n// Included from DirectProgramming/C++SYCL_FPGA/include/\n#include \"constexpr_math.hpp\"\n\nusing namespace sycl;\nusing namespace std::chrono;\n\n// Determines whether we will use USM host or device allocations to move data\n// between host and the device.\n// This can be set on the command line by defining the preprocessor macro\n// 'USM_HOST_ALLOCATIONS' using the flag: '-DUSM_HOST_ALLOCATIONS'\n#if defined(USM_HOST_ALLOCATIONS)\nconstexpr bool kUseUSMHostAllocation = true;\n#else\nconstexpr bool kUseUSMHostAllocation = false;\n#endif\n\n// Limits the number of merge units used in hardware to support older\n// versions of quartus.\n#if defined(LIMIT_HW_MERGE_UNITS)\n#if FPGA_HARDWARE\n#ifndef MERGE_UNITS\n#define MERGE_UNITS 4\n#endif\n#endif\n#endif\n\n// The number of merge units, which must be a power of 2.\n// This can be set by defining the preprocessor macro 'MERGE_UNITS'\n// otherwise the default value below is used.\n#ifndef MERGE_UNITS\n#if defined(FPGA_SIMULATOR)\n#define MERGE_UNITS 2\n#else\n#define MERGE_UNITS 8\n#endif\n#endif\nconstexpr size_t kMergeUnits = MERGE_UNITS;\nstatic_assert(kMergeUnits > 0);\nstatic_assert(fpga_tools::IsPow2(kMergeUnits));\n\n// The width of the sort, which must be a power of 2\n// This can be set by defining the preprocessor macro 'SORT_WIDTH'\n// otherwise the default value below is used.\n#ifndef SORT_WIDTH\n#define SORT_WIDTH 4\n#endif\nconstexpr size_t kSortWidth = SORT_WIDTH;\nstatic_assert(kSortWidth >= 1);\nstatic_assert(fpga_tools::IsPow2(kSortWidth));\n\n////////////////////////////////////////////////////////////////////////////////\n// Forward declare functions used in this file by main()\ntemplate <typename ValueT, typename IndexT, typename KernelPtrType>\ndouble FPGASort(queue &q, ValueT *in_vec, ValueT *out_vec, IndexT count);\n\ntemplate <typename T>\nbool Validate(T *val, T *ref, unsigned int count);\n////////////////////////////////////////////////////////////////////////////////\n\n\nint main(int argc, char *argv[]) {\n  // the type to sort, needs a compare function!\n  using ValueT = int;\n\n  // the type used to index in the sorter\n  // below we do a runtime check to make sure this type has enough bits to\n  // count all the elements to be sorted.\n  using IndexT = unsigned int;\n\n  /////////////////////////////////////////////////////////////\n  // reading and validating the command line arguments\n  // defaults\n  bool passed = true;\n#if defined(FPGA_EMULATOR)\n  IndexT count = 128;\n  int runs = 2;\n#elif defined(FPGA_SIMULATOR)\n  IndexT count = 16;\n  int runs = 2;\n#else\n  IndexT count = 1 << 24;\n  int runs = 17;\n#endif\n  int seed = 777;\n\n  // get the size of the input as the first command line argument\n  if (argc > 1) {\n    count = atoi(argv[1]);\n  }\n\n  // get the number of runs as the second command line argument\n  if (argc > 2) {\n    runs = atoi(argv[2]);\n  }\n\n  // get the random number generator seed as the third command line argument\n  if (argc > 3) {\n    seed = atoi(argv[3]);\n  }\n\n  // enforce at least two runs\n  if (runs < 2) {\n    std::cerr << \"ERROR: 'runs' must be 2 or more\\n\";\n    std::terminate();\n  }\n\n  // check args\n  if (count <= kMergeUnits) {\n    std::cerr << \"ERROR: 'count' must be greater than number of merge units\\n\";\n    std::terminate();\n  } else if (count > std::numeric_limits<IndexT>::max()) {\n    std::cerr << \"ERROR: the index type (IndexT) does not have enough bits to \"\n              << \"count to 'count'\\n\";\n    std::terminate();\n  } else if ((count % kSortWidth) != 0) {\n    std::cerr << \"ERROR: 'count' must be a multiple of the sorter width\\n\";\n    std::terminate();\n  }\n  /////////////////////////////////////////////////////////////\n\n  // the device selector\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  // create the device queue\n  queue q(selector, fpga_tools::exception_handler);\n\n  auto device = q.get_device();\n\n  // make sure the device supports USM device allocations in BSP mode\n#if defined(IS_BSP)\n  if (!device.has(aspect::usm_device_allocations)) {\n    std::cerr << \"ERROR: The selected device does not support USM device\"\n              << \" allocations\\n\";\n    std::terminate();\n  }\n#endif\n\n  // make sure the device support USM host allocations if we chose to use them\n  if (!device.has(aspect::usm_host_allocations) &&\n      kUseUSMHostAllocation) {\n    std::cerr << \"ERROR: The selected device does not support USM host\"\n              << \" allocations\\n\";\n    std::terminate();\n  }\n\n  std::cout << \"Running on device: \"\n            << device.get_info<sycl::info::device::name>().c_str() \n            << std::endl;\n\n  // the input, output, and reference data\n  std::vector<ValueT> in_vec(count), out_vec(count), ref(count);\n\n  // generate some random input data\n  srand(seed);\n  std::generate(in_vec.begin(), in_vec.end(), [] { return rand() % 100; });\n\n  // copy the input to the output reference and compute the expected result\n  std::copy(in_vec.begin(), in_vec.end(), ref.begin());\n  std::sort(ref.begin(), ref.end());\n\n  // allocate the input and output data either in USM host or device allocations\n  ValueT *in, *out;\n  if constexpr (kUseUSMHostAllocation) {\n    // using USM host allocations\n    if ((in = malloc_host<ValueT>(count, q)) == nullptr) {\n      std::cerr << \"ERROR: could not allocate space for 'in' using \"\n                << \"malloc_host\\n\";\n      std::terminate();\n    }\n    if ((out = malloc_host<ValueT>(count, q)) == nullptr) {\n      std::cerr << \"ERROR: could not allocate space for 'out' using \"\n                << \"malloc_host\\n\";\n      std::terminate();\n    }\n\n    // Copy the input to USM memory and reset the output.\n    // This is NOT efficient since, in the case of USM host allocations,\n    // we could have simply generated the input data into the host allocation\n    // and avoided this copy. However, it makes the code cleaner to assume the\n    // input is always in 'in_vec' and this portion of the code is not part of\n    // the performance timing.\n    std::copy(in_vec.begin(), in_vec.end(), in);\n    std::fill(out, out + count, ValueT(0));\n  } else {\n    // using device allocations\n    if ((in = malloc_device<ValueT>(count, q)) == nullptr) {\n      std::cerr << \"ERROR: could not allocate space for 'in' using \"\n                << \"malloc_device\\n\";\n      std::terminate();\n    }\n    if ((out = malloc_device<ValueT>(count, q)) == nullptr) {\n      std::cerr << \"ERROR: could not allocate space for 'out' using \"\n                << \"malloc_device\\n\";\n      std::terminate();\n    }\n\n    // copy the input to the device memory and wait for the copy to finish\n    q.memcpy(in, in_vec.data(), count * sizeof(ValueT)).wait();\n  }\n\n  // track timing information, in ms\n  std::vector<double> time(runs);\n\n  try {\n    std::cout << \"Running sort \" << runs << \" times for an \"\n              << \"input size of \" << count << \" using \" << kMergeUnits\n              << \" \" << kSortWidth << \"-way merge units\\n\";\n    std::cout << \"Streaming data from \"\n              << (kUseUSMHostAllocation ? \"host\" : \"device\") << \" memory\\n\";\n\n    // the pointer type for the kernel depends on whether data is coming from\n    // USM host or device allocations\n    using KernelPtrType =\n        typename std::conditional_t<kUseUSMHostAllocation, \n                                    sycl::ext::intel::host_ptr<ValueT>,\n                                    sycl::ext::intel::device_ptr<ValueT>>;\n\n    // run the sort multiple times to increase the accuracy of the timing\n    for (int i = 0; i < runs; i++) {\n      // run the sort\n      time[i] = FPGASort<ValueT, IndexT, KernelPtrType>(q, in, out, count);\n\n      // Copy the output to 'out_vec'. In the case where we are using USM host\n      // allocations this is unnecessary since we could simply deference\n      // 'out'. However, it makes the following code cleaner since the output\n      // is always in 'out_vec' and this copy is not part of the performance\n      // timing.\n      q.memcpy(out_vec.data(), out, count * sizeof(ValueT)).wait();\n\n      // validate the output\n      passed &= Validate(out_vec.data(), ref.data(), count);\n    }\n  } catch (exception const &e) {\n    std::cout << \"Caught a synchronous SYCL exception: \" << e.what() << \"\\n\";\n    std::terminate();\n  }\n\n  // free the memory allocated with malloc_host or malloc_device\n  sycl::free(in, q);\n  sycl::free(out, q);\n\n  // print the performance results\n  if (passed) {\n    // NOTE: when run in emulation, these results do not accurately represent\n    // the performance of the kernels in actual FPGA hardware\n    double avg_time_ms =\n      std::accumulate(time.begin() + 1, time.end(), 0.0) / (runs - 1);\n\n    IndexT input_count_mega = count * 1e-6;\n\n    std::cout << \"Execution time: \" << avg_time_ms << \" ms\\n\";\n    std::cout << \"Throughput: \" << (input_count_mega / (avg_time_ms * 1e-3))\n              << \" Melements/s\\n\";\n\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n\n// forward declare the kernel and pipe IDs to reduce name mangling\nclass InputKernelID;\nclass OutputKernelID;\nclass SortInPipeID;\nclass SortOutPipeID;\n\n//\n// perform the actual sort on the FPGA.\n//\ntemplate <typename ValueT, typename IndexT, typename KernelPtrType>\ndouble FPGASort(queue &q, ValueT *in_ptr, ValueT *out_ptr, IndexT count) {\n  // the input and output pipe for the sorter\n  using SortInPipe =\n      sycl::ext::intel::pipe<SortInPipeID, sycl::vec<ValueT, kSortWidth>>;\n  using SortOutPipe =\n      sycl::ext::intel::pipe<SortOutPipeID, sycl::vec<ValueT, kSortWidth>>;\n\n  // the sorter must sort a power of 2, so round up the requested count\n  // to the nearest power of 2; we will pad the input to make sure the\n  // output is still correct\n  const IndexT sorter_count = fpga_tools::RoundUpPow2(count);\n\n  // allocate some memory for the merge sort to use as temporary storage\n  ValueT *buf_0, *buf_1;\n#if defined (IS_BSP)\n  if ((buf_0 = malloc_device<ValueT>(sorter_count, q)) == nullptr) {\n    std::cerr << \"ERROR: could not allocate memory for 'buf_0'\\n\";\n    std::terminate();\n  }\n  if ((buf_1 = malloc_device<ValueT>(sorter_count, q)) == nullptr) {\n    std::cerr << \"ERROR: could not allocate memory for 'buf_1'\\n\";\n    std::terminate();\n  }\n#else\n  if ((buf_0 = malloc_shared<ValueT>(sorter_count, q)) == nullptr) {\n    std::cerr << \"ERROR: could not allocate memory for 'buf_0'\\n\";\n    std::terminate();\n  }\n  if ((buf_1 = malloc_shared<ValueT>(sorter_count, q)) == nullptr) {\n    std::cerr << \"ERROR: could not allocate memory for 'buf_1'\\n\";\n    std::terminate();\n  }\n#endif\n\n  // This is the element we will pad the input with. In the case of this design,\n  // we are sorting from smallest to largest and we want the last elements out\n  // to be this element, so pad with MAX. If you are sorting from largest to\n  // smallest, make this the MIN element. If you are sorting custom types\n  // which are not supported by std::numeric_limits, then you will have to set\n  // this padding element differently.\n  const auto padding_element = std::numeric_limits<ValueT>::max();\n\n  // We are sorting kSortWidth elements per cycle, so we will have \n  // sorter_count/kSortWidth pipe reads/writes from/to the sorter\n  const IndexT total_pipe_accesses = sorter_count / kSortWidth;\n\n  // launch the kernel that provides data into the sorter\n  auto input_kernel_event =\n    q.single_task<InputKernelID>([=]() [[intel::kernel_args_restrict]] {\n      // read from the input pointer and write it to the sorter's input pipe\n      KernelPtrType in(in_ptr);\n\n      for (IndexT i = 0; i < total_pipe_accesses; i++) {\n        // read data from device memory\n        bool in_range = i * kSortWidth < count;\n\n        // build the input pipe data\n        sycl::vec<ValueT, kSortWidth> data;\n        #pragma unroll\n        for (unsigned char j = 0; j < kSortWidth; j++) {\n          data[j] = in_range ? in[i * kSortWidth + j] : padding_element;\n        }\n\n        // write it into the sorter\n        SortInPipe::write(data);\n      }\n    });\n\n  // launch the kernel that reads out data from the sorter\n  auto output_kernel_event =\n    q.single_task<OutputKernelID>([=]() [[intel::kernel_args_restrict]] {\n      // read from the sorter's output pipe and write to the output pointer\n      KernelPtrType out(out_ptr);\n      \n      for (IndexT i = 0; i < total_pipe_accesses; i++) {\n        // read data from the sorter\n        auto data = SortOutPipe::read();\n\n        // sorter_count is a multiple of kSortWidth\n        bool in_range = i * kSortWidth < count;\n\n        // only write out to device memory if the index is in range\n        if (in_range) {\n          // write output to device memory\n          #pragma unroll\n          for (unsigned char j = 0; j < kSortWidth; j++) {\n            out[i * kSortWidth + j] = data[j];\n          }\n        }\n      }\n    });\n\n  // launch the merge sort kernels\n  auto merge_sort_events =\n      SubmitMergeSort<ValueT, IndexT, SortInPipe, SortOutPipe, kSortWidth,\n                      kMergeUnits>(q, sorter_count, buf_0, buf_1);\n\n  // wait for the input and output kernels to finish\n  auto start = high_resolution_clock::now();\n  input_kernel_event.wait();\n  output_kernel_event.wait();\n  auto end = high_resolution_clock::now();\n\n  // wait for the merge sort kernels to finish\n  for (auto &e : merge_sort_events) {\n    e.wait();\n  }\n\n  // free the memory allocated for the merge sort temporary buffers\n  sycl::free(buf_0, q);\n  sycl::free(buf_1, q);\n\n  // return the duration of the sort in milliseconds, excluding memory transfers\n  duration<double, std::milli> diff = end - start;\n  return diff.count();\n}\n\n//\n// simple function to check if two regions of memory contain the same values\n//\ntemplate <typename T>\nbool Validate(T *val, T *ref, unsigned int count) {\n  for (unsigned int i = 0; i < count; i++) {\n    if (val[i] != ref[i]) {\n      std::cout << \"ERROR: mismatch at entry \" << i << \"\\n\";\n      std::cout << \"\\t\" << val[i] << \" != \" << ref[i]\n                << \" (val[i] != ref[i])\\n\";\n      return false;\n    }\n  }\n\n  return true;\n}\n"
    },
    {
        "label": "main.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <algorithm>\n#include <array>\n#include <chrono>\n#include <cmath>\n#include <limits>\n#include <numeric>\n#include <sstream>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\n#include \"anr.hpp\"\n#include \"anr_params.hpp\"\n#include \"constants.hpp\"\n#include \"data_bundle.hpp\"\n#include \"dma_kernels.hpp\"\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\nusing namespace std::chrono;\n\n////////////////////////////////////////////////////////////////////////////////\n// Forward declare functions used in this file by main()\nvoid ParseFiles(std::string data_dir, std::vector<PixelT>& in_pixels,\n                std::vector<PixelT>& ref_pixels, int& cols, int& rows,\n                ANRParams& params);\n\nvoid WriteOutputFile(std::string data_dir, std::vector<PixelT>& pixels,\n                     int cols, int rows);\n\ndouble RunANR(queue& q, PixelT* in_ptr, PixelT* out_ptr, int cols, int rows,\n              int frames, ANRParams params, float* sig_i_lut_data_ptr);\n\nbool Validate(PixelT* val, PixelT* ref, int rows, int cols,\n              double psnr_thresh = kPSNRDefaultThreshold);\n////////////////////////////////////////////////////////////////////////////////\n\nint main(int argc, char* argv[]) {\n  /////////////////////////////////////////////////////////////\n  // reading and validating the command line arguments\n  std::string data_dir = \"../test_data\";\n  bool passed = true;\n#if defined(FPGA_EMULATOR)\n  int runs = 2;\n  int frames = 2;\n#elif defined(FPGA_SIMULATOR)\n  int runs = 2;\n  int frames = 1;\n#else\n  int runs = 2;\n  int frames = 8;\n#endif\n\n  // get the input data directory\n  if (argc > 1) {\n    data_dir = std::string(argv[1]);\n  }\n\n  // get the number of runs as the second command line argument\n  if (argc > 2) {\n    runs = atoi(argv[2]);\n  }\n\n  // get the number of frames as the third command line argument\n  if (argc > 3) {\n    frames = atoi(argv[3]);\n  }\n\n  // enforce at least two runs\n  if (runs < 2) {\n    std::cerr << \"ERROR: 'runs' must be 2 or more\\n\";\n    std::terminate();\n  }\n\n  // enforce at least one batch\n  if (frames < 1) {\n    std::cerr << \"ERROR: 'frames' must be atleast 1\\n\";\n    std::terminate();\n  }\n  /////////////////////////////////////////////////////////////\n\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  // create the device queue\n  queue q(selector, fpga_tools::exception_handler);\n\n  // make sure the device supports USM device allocations\n  auto device = q.get_device();\n#if defined(IS_BSP)\n  if (!device.has(aspect::usm_device_allocations)) {\n    std::cerr << \"ERROR: The selected device does not support USM device\"\n              << \" allocations\\n\";\n    std::terminate();\n  }\n#endif\n\n  std::cout << \"Running on device: \"\n            << device.get_info<sycl::info::device::name>().c_str() \n            << std::endl;\n\n\n  // parse the input files\n  int cols, rows, pixel_count;\n  ANRParams params;\n  std::vector<PixelT> in_pixels, ref_pixels;\n  ParseFiles(data_dir, in_pixels, ref_pixels, cols, rows, params);\n  pixel_count = cols * rows;\n\n  // create the output pixels (initialize to all 0s)\n  std::vector<PixelT> out_pixels(in_pixels.size(), 0);\n\n#if defined (IS_BSP)\n  // allocate memory on the device for the input and output\n  PixelT *in, *out;\n  if ((in = malloc_device<PixelT>(pixel_count, q)) == nullptr) {\n    std::cerr << \"ERROR: could not allocate space for 'in'\\n\";\n    std::terminate();\n  }\n  if ((out = malloc_device<PixelT>(pixel_count, q)) == nullptr) {\n    std::cerr << \"ERROR: could not allocate space for 'out'\\n\";\n    std::terminate();\n  }\n#else \n  // allocate memory on the host for the input and output\n  PixelT *in, *out;\n  if ((in = malloc_shared<PixelT>(pixel_count, q)) == nullptr) {\n    std::cerr << \"ERROR: could not allocate space for 'in'\\n\";\n    std::terminate();\n  }\n  if ((out = malloc_shared<PixelT>(pixel_count, q)) == nullptr) {\n    std::cerr << \"ERROR: could not allocate space for 'out'\\n\";\n    std::terminate();\n  }\n#endif   \n\n\n  // copy the input data to the device memory and wait for the copy to finish\n  q.memcpy(in, in_pixels.data(), pixel_count * sizeof(PixelT)).wait();\n\n  // allocate space for the intensity sigma LUT\n  float* sig_i_lut_data_ptr = IntensitySigmaLUT::Allocate(q);\n\n  // create the intensity sigma LUT data locally on the host\n  IntensitySigmaLUT sig_i_lut_host(params);\n\n  // copy the intensity sigma LUT to the device\n  sig_i_lut_host.CopyData(q, sig_i_lut_data_ptr).wait();\n  //////////////////////////////////////////////////////////////////////////////\n\n  // track timing information in ms\n  std::vector<double> time(runs);\n\n  // print out some info\n  std::cout << \"Runs:             \" << runs << \"\\n\";\n  std::cout << \"Columns:          \" << cols << \"\\n\";\n  std::cout << \"Rows:             \" << rows << \"\\n\";\n  std::cout << \"Frames:           \" << frames << \"\\n\";\n  std::cout << \"Filter Size:      \" << kFilterSize << \"\\n\";\n  std::cout << \"Pixels Per Cycle: \" << kPixelsPerCycle << \"\\n\";\n  std::cout << \"Maximum Columns:  \" << kMaxCols << \"\\n\";\n  std::cout << \"\\n\";\n\n  try {\n    // run the design multiple times to increase the accuracy of the timing\n    for (int i = 0; i < runs; i++) {\n      // run ANR\n      time[i] =\n          RunANR(q, in, out, cols, rows, frames, params, sig_i_lut_data_ptr);\n\n      // Copy the output back from the device\n      q.memcpy(out_pixels.data(), out, pixel_count * sizeof(PixelT)).wait();\n\n      // validate the output on the last iteration\n      if (i == (runs-1)) {\n        passed &= Validate(out_pixels.data(), ref_pixels.data(), rows, cols);\n      } else {\n        passed &= true;\n      }\n    }\n  } catch (exception const& e) {\n    std::cout << \"Caught a synchronous SYCL exception: \" << e.what() << \"\\n\";\n    std::terminate();\n  }\n\n  // free the allocated device memory\n  sycl::free(in, q);\n  sycl::free(out, q);\n  sycl::free(sig_i_lut_data_ptr, q);\n\n  // write the output files if device memory was used (output is meaningless\n  // otherwise)\n  WriteOutputFile(data_dir, out_pixels, cols, rows);\n\n  // print the performance results\n  if (passed) {\n    // NOTE: when run in emulation, these results do not accurately represent\n    // the performance of the kernels in actual FPGA hardware\n    double avg_time_ms =\n        std::accumulate(time.begin() + 1, time.end(), 0.0) / (runs - 1);\n\n    size_t input_count_mega = pixel_count * frames * sizeof(PixelT) * 1e-6;\n\n    std::cout << \"Execution time: \" << avg_time_ms << \" ms\\n\";\n    std::cout << \"Throughput: \" << (input_count_mega / (avg_time_ms * 1e-3))\n              << \" MB/s\\n\";\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n\n// declare kernel and pipe names globally to reduce name mangling\nclass ANRInPipeID;\nclass ANROutPipeID;\nclass InputKernelID;\nclass OutputKernelID;\n\n//\n// Run the ANR algorithm on the device\n//\ndouble RunANR(queue& q, PixelT* in_ptr, PixelT* out_ptr, int cols, int rows,\n              int frames, ANRParams params, float* sig_i_lut_data_ptr) {\n  // the input and output pipe for the sorter\n  using PipeType = DataBundle<PixelT, kPixelsPerCycle>;\n  using ANRInPipe = sycl::ext::intel::pipe<ANRInPipeID, PipeType>;\n  using ANROutPipe = sycl::ext::intel::pipe<ANROutPipeID, PipeType>;\n\n  // launch the input and output kernels that read from and write to the device\n  auto input_kernel_event =\n      SubmitInputDMA<InputKernelID, PixelT, ANRInPipe, kPixelsPerCycle>(q,\n                     in_ptr, rows, cols, frames);\n\n  auto output_kernel_event =\n      SubmitOutputDMA<OutputKernelID, PixelT, ANROutPipe, kPixelsPerCycle>(q,\n                      out_ptr, rows, cols, frames);\n\n  // launch all ANR kernels\n  std::vector<std::vector<event>> anr_kernel_events(frames);\n  for (int i = 0; i < frames; i++) {\n    anr_kernel_events[i] =\n        SubmitANRKernels<IndexT, ANRInPipe, ANROutPipe, kFilterSize,\n                       kPixelsPerCycle, kMaxCols>(q, cols, rows, params,\n                       sig_i_lut_data_ptr);\n  }\n\n  // wait for the input and output kernels to finish\n  auto start = high_resolution_clock::now();\n  input_kernel_event.wait();\n  output_kernel_event.wait();\n  auto end = high_resolution_clock::now();\n\n  // wait for the ANR kernels to finish\n  for (auto& one_event_set : anr_kernel_events) {\n    for (auto& e : one_event_set) {\n      e.wait();\n    }\n  }\n\n  // return the duration in milliseconds, excluding memory transfers\n  duration<double, std::milli> diff = end - start;\n  return diff.count();\n}\n\n//\n// Helper to parse pixel data files\n//\nvoid ParseDataFile(std::string filename, std::vector<PixelT>& pixels, int& cols,\n                   int& rows) {\n  // create the file stream to parse\n  std::ifstream ifs(filename);\n\n  // make sure we opened the file\n  if (!ifs.is_open() || ifs.fail()) {\n    std::cerr << \"ERROR: failed to open \" << filename << \" for reading\\n\";\n    std::terminate();\n  }\n\n  // get the header and data\n  std::string header_str, data_str;\n  if (!std::getline(ifs, header_str)) {\n    std::cerr << \"ERROR: failed to get header line from \" << filename << \"\\n\";\n    std::terminate();\n  }\n  if (!std::getline(ifs, data_str)) {\n    std::cerr << \"ERROR: failed to get data line from \" << filename << \"\\n\";\n    std::terminate();\n  }\n\n  // first two elements are the image dimensions\n  std::stringstream header_ss(header_str);\n  header_ss >> rows >> cols;\n\n  // expecting to parse cols*rows pixels from the 'data_str' line\n  pixels.resize(cols * rows);\n\n  // parse all of the pixels\n  std::stringstream data_ss(data_str);\n  for (int i = 0; i < cols * rows; i++) {\n    // parse using 64 bit integer\n    TmpT x;\n\n    // parse the pixel value\n    if (!(data_ss >> x)) {\n      std::cerr << \"ERROR: ran out of pixels when parsing \" << filename << \"\\n\";\n      std::terminate();\n    }\n\n    // check for parsing failure\n    if (data_ss.fail()) {\n      std::cerr << \"ERROR: failed to parse pixel in \" << filename << \"\\n\";\n      std::terminate();\n    }\n\n    // check if the parsed value fits in the pixel type\n    if (x > static_cast<TmpT>(std::numeric_limits<PixelT>::max())) {\n      std::cerr << \"ERROR: value (\" << x\n                << \") is too big to store in pixel type 'T'\\n\";\n      std::terminate();\n    }\n    if (x < static_cast<TmpT>(std::numeric_limits<PixelT>::min())) {\n      std::cerr << \"ERROR: value (\" << x\n                << \") is too small to store in pixel type 'T'\\n\";\n      std::terminate();\n    }\n\n    // set the value\n    pixels[i] = static_cast<PixelT>(x);\n  }\n}\n\n//\n// Function that parses all of the input files\n//\nvoid ParseFiles(std::string data_dir, std::vector<PixelT>& in_pixels,\n                std::vector<PixelT>& ref_pixels, int& cols, int& rows,\n                ANRParams& params) {\n  // parse the pixel data files\n  int noisy_w, noisy_h;\n#if FPGA_SIMULATOR\n  ParseDataFile(data_dir + \"/small_input_noisy.data\", in_pixels, noisy_w, noisy_h);\n#else\n  ParseDataFile(data_dir + \"/input_noisy.data\", in_pixels, noisy_w, noisy_h);\n#endif\n  int ref_w, ref_h;\n#if FPGA_SIMULATOR\n  ParseDataFile(data_dir + \"/small_output_ref.data\", ref_pixels, ref_w, ref_h);\n#else\n  ParseDataFile(data_dir + \"/output_ref.data\", ref_pixels, ref_w, ref_h);\n#endif\n\n  // ensure the dimensions match\n  if (noisy_w != ref_w) {\n    std::cerr << \"noisy input and reference widths do not match \" << noisy_w\n              << \" != \" << ref_w << \"\\n\";\n    std::terminate();\n  }\n  if (noisy_h != ref_h) {\n    std::cerr << \"noisy input and reference heights do not match \" << noisy_h\n              << \" != \" << ref_h << \"\\n\";\n    std::terminate();\n  }\n\n  // set the width and height\n  cols = ref_w;\n  rows = ref_h;\n\n  // parse the ANR config parameters file\n  params = ANRParams::FromFile(data_dir + \"/param_config.data\");\n\n  // ensure the parsed filter size matches the compile time constant\n  if (params.filter_size != kFilterSize) {\n    std::cerr << \"ERROR: the filter size parsed from \" << data_dir\n              << \"/param_config.data (\" << params.filter_size\n              << \") does not match the compile time constant filter size \"\n              << \"(kFilterSize = \" << kFilterSize << \")\\n\";\n    std::terminate();\n  }\n\n  // ensure the parsed number of pixel bits matches the compile time constant\n  if (params.pixel_bits != kPixelBits) {\n    std::cerr << \"ERROR: the number of bits per pixel parsed from \" << data_dir\n              << \"/param_config.data (\" << params.pixel_bits\n              << \") does not match the compile time constant pixel size \"\n              << \"kPixelBits = \" << kPixelBits << \")\\n\";\n    std::terminate();\n  }\n}\n\n//\n// Function to write the output to a file\n//\nvoid WriteOutputFile(std::string data_dir, std::vector<PixelT>& pixels,\n                     int cols, int rows) {\n  std::string filename = data_dir + \"/output.data\";\n  std::ofstream ofs(filename);\n\n  // make sure we opened the file fine\n  if (!ofs.is_open() || ofs.fail()) {\n    std::cerr << \"ERROR: failed to open \" << filename << \" for writing\\n\";\n    std::terminate();\n  }\n\n  // write the image dimensions\n  ofs << rows << \" \" << cols << \"\\n\";\n\n  // write the pixels\n  for (auto& p : pixels) {\n    ofs << static_cast<TmpT>(p) << \" \";\n  }\n}\n\n//\n// Validate the output pixels using Peak signal-to-noise ratio (PSNR)\n// https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio\n//\n// Also check the max individual pixel difference.\n//\nbool Validate(PixelT* val, PixelT* ref, int rows, int cols,\n              double psnr_thresh) {\n  // get the maximum value of the pixel\n  constexpr double max_i = std::numeric_limits<PixelT>::max();\n\n  // total number of pixels to check\n  int count = rows * cols;\n\n  // compute the MSE by summing the squared differences\n  // also find the maximum difference between the output pixel and the reference\n  double mse = 0.0;\n  for (int i = 0; i < count; i++) {\n    // cast to a double here because we are subtracting\n    auto diff = double(val[i]) - double(ref[i]);\n    mse += diff * diff;\n  }\n  mse /= count;\n\n  // compute the PSNR\n  double psnr = (20 * std::log10(max_i)) - (10 * std::log10(mse));\n\n  // check PSNR and maximum pixel difference\n  bool passed = true;\n  if (psnr <= psnr_thresh) {\n    std::cerr << \"ERROR: Peak signal-to-noise ratio (PSNR) is too low: \" << psnr\n              << \"\\n\";\n    passed = false;\n  }\n\n  return passed;\n}\n"
    },
    {
        "label": "main.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <algorithm>\n#include <array>\n#include <fstream>\n#include <limits>\n#include <numeric>\n#include <optional>\n#include <sstream>\n#include <string>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <thread>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\n#include \"constexpr_math.hpp\"  // included from ../../../include\n\n#include \"common/common.hpp\"\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// ensure only one of GZIP and SNAPPY is defined\n#if defined(GZIP) and defined(SNAPPY)\nstatic_assert(false, \"Only one of GZIP and SNAPPY can be defined!\");\n#endif\n\n// if neither of GZIP and SNAPPY is defined, default to SNAPPY\n#if not defined(GZIP) and not defined(SNAPPY)\n#define SNAPPY\n#endif\n\n// the number of literals to process at once can be set from the command line\n// use the macro -DLITERALS_PER_CYCLE=<literals_per_cycle>\n// This is sent to the LZ77 decoder to read multiple elements at once from\n// the history buffer.\n#if not defined(LITERALS_PER_CYCLE)\n// default LITERALS_PER_CYCLE for GZIP\n#if defined(GZIP)\n#define LITERALS_PER_CYCLE 4\n#endif\n// default LITERALS_PER_CYCLE for SNAPPY\n#if defined(SNAPPY)\n#define LITERALS_PER_CYCLE 8\n#endif\n#endif\nconstexpr unsigned kLiteralsPerCycle = LITERALS_PER_CYCLE;\nstatic_assert(kLiteralsPerCycle > 0);\nstatic_assert(fpga_tools::IsPow2(kLiteralsPerCycle));\n\n// include files and aliases specific to GZIP and SNAPPY decompression\n#if defined(GZIP)\n#include \"gzip/gzip_decompressor.hpp\"\n#else\n#include \"snappy/snappy_data_gen.hpp\"\n#include \"snappy/snappy_decompressor.hpp\"\n#endif\n\n// aliases and testing functions specific to GZIP and SNAPPY decompression\n#if defined(GZIP)\nusing GzipDecompressorT = GzipDecompressor<kLiteralsPerCycle>;\nbool RunGzipTest(sycl::queue& q, GzipDecompressorT decompressor,\n                 const std::string test_dir);\nstd::string decompressor_name = \"GZIP\";\n#else\nusing SnappyDecompressorT = SnappyDecompressor<kLiteralsPerCycle>;\nbool RunSnappyTest(sycl::queue& q, SnappyDecompressorT decompressor,\n                   const std::string test_dir);\nstd::string decompressor_name = \"SNAPPY\";\n#endif\n\n// Prints the usage for the executable command line args\nvoid PrintUsage(std::string exe_name) {\n  std::cerr << \"USAGE: \\n\"\n            << exe_name << \" <input filename> <output filename> [runs]\\n\"\n            << exe_name << \" <test directory>\" << std::endl;\n}\n\nint main(int argc, char* argv[]) {\n  // reading and validating the command line arguments\n  // if no arguments are given, we will run the default tests for uncompressed,\n  // statically compressed, and dynamically compressed blocks\n  // if arguments are given, we will assume the user wants to decompress a\n  // specific file\n#if defined(GZIP)\n  std::string test_dir = \"../data/gzip\";\n#else\n  std::string test_dir = \"../data/snappy\";\n#endif\n\n  std::string in_filename;\n  std::string out_filename;\n  int runs;\n  bool default_test_mode = false;\n\n  if (argc == 1 || argc == 2) {\n    default_test_mode = true;\n  } else if (argc > 4) {\n    PrintUsage(argv[0]);\n    return 1;\n  }\n\n  if (default_test_mode) {\n    if (argc > 1) test_dir = argv[1];\n  } else {\n    // default the number of runs based on emulation, simulation, or hardware\n#if defined(FPGA_EMULATOR)\n    runs = 2;\n#elif defined(FPGA_SIMULATOR)\n    runs = 1;\n#else\n    runs = 9;\n#endif\n\n    in_filename = argv[1];\n    out_filename = argv[2];\n    if (argc > 3) runs = atoi(argv[3]);\n    if (runs < 1) {\n      std::cerr << \"ERROR: 'runs' must be greater than 0\\n\";\n      std::terminate();\n    }\n  }\n\n  std::cout << \"Using \" << decompressor_name << \" decompression\\n\";\n  std::cout << std::endl;\n\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  // create the device queue\n  queue q(selector, fpga_tools::exception_handler);\n\n  device device = q.get_device();\n\n  std::cout << \"Running on device: \"\n            << device.get_info<info::device::name>().c_str() \n            << std::endl;\n\n  // create the decompressor based on which decompression version we are using\n#if defined(GZIP)\n  GzipDecompressorT decompressor;\n#else\n  SnappyDecompressorT decompressor;\n#endif\n\n  // perform the test or single file decompression\n  bool passed;\n  if (default_test_mode) {\n#if defined(GZIP)\n    passed = RunGzipTest(q, decompressor, test_dir);\n#else\n    passed = RunSnappyTest(q, decompressor, test_dir);\n#endif\n  } else {\n    // decompress a specific file specified at the command line\n    passed = decompressor.DecompressFile(q, in_filename, out_filename, runs,\n                                         true, true);\n  }\n\n  if (passed) {\n    std::cout << \"PASSED\" << std::endl;\n    return 0;\n  } else {\n    std::cout << \"FAILED\" << std::endl;\n    return 1;\n  }\n}\n\n//\n// Pretty formatting for printing the result of a test\n//\nvoid PrintTestResults(std::string test_name, bool passed) {\n  if (passed)\n    std::cout << \">>>>> \" << test_name << \": PASSED <<<<<\\n\";\n  else\n    std::cerr << \">>>>> \" << test_name << \": FAILED <<<<<\\n\";\n}\n\n#if defined(GZIP)\nbool RunGzipTest(sycl::queue& q, GzipDecompressorT decompressor,\n                 const std::string test_dir) {\n\n\n#ifdef FPGA_SIMULATOR\n  // the name of the file for the simulator is fixed\n  std::string small_filename = test_dir + \"/small.gz\";\n  \n  std::cout << \">>>>> Small File Test <<<<<\" << std::endl;\n  bool small_test_pass = decompressor.DecompressFile(\n      q, small_filename, \"\", 1, false, false);\n  PrintTestResults(\"Small File Test\", small_test_pass);\n  std::cout << std::endl;\n\n  return small_test_pass;\n#else\n  // the name of the files for the default test are fixed\n  std::string uncompressed_filename = test_dir + \"/uncompressed.gz\";\n  std::string static_compress_filename = test_dir + \"/static_compressed.gz\";\n  std::string dynamic_compress_filename = test_dir + \"/dynamic_compressed.gz\";\n  std::string tp_test_filename = test_dir + \"/tp_test.gz\";\n\n  std::cout << \">>>>> Uncompressed File Test <<<<<\" << std::endl;\n  bool uncompressed_test_pass = decompressor.DecompressFile(\n      q, uncompressed_filename, \"\", 1, false, false);\n  PrintTestResults(\"Uncompressed File Test\", uncompressed_test_pass);\n  std::cout << std::endl;\n\n  std::cout << \">>>>> Statically Compressed File Test <<<<<\" << std::endl;\n  bool static_test_pass = decompressor.DecompressFile(\n      q, static_compress_filename, \"\", 1, false, false);\n  PrintTestResults(\"Statically Compressed File Test\", static_test_pass);\n  std::cout << std::endl;\n\n  std::cout << \">>>>> Dynamically Compressed File Test <<<<<\" << std::endl;\n  bool dynamic_test_pass = decompressor.DecompressFile(\n      q, dynamic_compress_filename, \"\", 1, false, false);\n  PrintTestResults(\"Dynamically Compressed File Test\", dynamic_test_pass);\n  std::cout << std::endl;\n\n  std::cout << \">>>>> Throughput Test <<<<<\" << std::endl;\n  constexpr int kTPTestRuns = 5;\n  bool tp_test_pass = decompressor.DecompressFile(q, tp_test_filename, \"\",\n                                                  kTPTestRuns, true, false);\n  PrintTestResults(\"Throughput Test\", tp_test_pass);\n  std::cout << std::endl;\n\n  return uncompressed_test_pass && static_test_pass && dynamic_test_pass &&\n         tp_test_pass;    \n#endif\n\n}\n#endif\n\n#if defined(SNAPPY)\nbool RunSnappyTest(sycl::queue& q, SnappyDecompressorT decompressor,\n                   const std::string test_dir) {\n\n\n#ifdef FPGA_SIMULATOR\n  std::cout << \">>>>> Alice In Wonderland Test <<<<<\" << std::endl;\n  std::string alice_in_file = test_dir + \"/alice29_small.txt.sz\";\n  auto in_bytes = ReadInputFile(alice_in_file);\n  auto result = decompressor.DecompressBytes(q, in_bytes, 1, false);\n\n  std::string alice_ref_file = test_dir + \"/alice29_small_ref.txt\";\n  auto ref_bytes = ReadInputFile(alice_ref_file);\n  bool alice_test_pass =\n      (result != std::nullopt) && (result.value() == ref_bytes);\n\n  PrintTestResults(\"Alice In Wonderland Test\", alice_test_pass);\n  std::cout << std::endl;\n\n  return alice_test_pass;\n#else\n\n  std::cout << \">>>>> Alice In Wonderland Test <<<<<\" << std::endl;\n  std::string alice_in_file = test_dir + \"/alice29.txt.sz\";\n  auto in_bytes = ReadInputFile(alice_in_file);\n  auto result = decompressor.DecompressBytes(q, in_bytes, 1, false);\n\n  std::string alice_ref_file = test_dir + \"/alice29.ref.txt\";\n  auto ref_bytes = ReadInputFile(alice_ref_file);\n  bool alice_test_pass =\n      (result != std::nullopt) && (result.value() == ref_bytes);\n\n  PrintTestResults(\"Alice In Wonderland Test\", alice_test_pass);\n  std::cout << std::endl;\n\n  std::cout << \">>>>> Only Literal Strings Test <<<<<\" << std::endl;\n  auto test1_bytes = GenerateSnappyCompressedData(333, 3, 0, 0, 3);\n  auto test1_ret = decompressor.DecompressBytes(q, test1_bytes, 1, false);\n  bool test1_pass = test1_ret != std::nullopt;\n  PrintTestResults(\"Only Literal Strings Test\", test1_pass);\n  std::cout << std::endl;\n\n  std::cout << \">>>>> Many Copies Test <<<<<\" << std::endl;\n  auto test2_bytes = GenerateSnappyCompressedData(65535, 1, 64, 13, 9);\n  auto test2_ret = decompressor.DecompressBytes(q, test2_bytes, 1, false);\n  bool test2_pass = test2_ret != std::nullopt;\n  PrintTestResults(\"Many Copies Test\", test2_pass);\n  std::cout << std::endl;\n\n  std::cout << \">>>>> Mixed Literal Strings and Copies Test <<<<<\" << std::endl;\n  auto test3_bytes = GenerateSnappyCompressedData(16065, 7, 13, 5, 3);\n  auto test3_ret = decompressor.DecompressBytes(q, test3_bytes, 1, false);\n  bool test3_pass = test3_ret != std::nullopt;\n  PrintTestResults(\"Mixed Literal Strings and Copies Test\", test3_pass);\n  std::cout << std::endl;\n\n  std::cout << \">>>>> Throughput Test <<<<<\" << std::endl;\n  constexpr int kTPTestRuns = 5;\n#ifndef FPGA_EMULATOR\n  auto test_tp_bytes = GenerateSnappyCompressedData(65536, 2, 0, 0, 128);\n#else\n  auto test_tp_bytes = GenerateSnappyCompressedData(65536, 2, 0, 0, 2);\n#endif\n  auto test_tp_ret =\n      decompressor.DecompressBytes(q, test_tp_bytes, kTPTestRuns, true);\n  bool test_tp_pass = test_tp_ret != std::nullopt;\n  PrintTestResults(\"Throughput Test\", test_tp_pass);\n  std::cout << std::endl;\n\n  return alice_test_pass && test1_pass && test2_pass && test3_pass &&\n         test_tp_pass;\n#endif\n\n}\n#endif\n"
    },
    {
        "label": "gzipkernel.cpp",
        "data": "#include <sycl/sycl.hpp>\n\n#include \"gzipkernel.hpp\"\n#include \"kernels.hpp\"\n\n\nusing namespace sycl;\n\n// This reference design uses a template-based unroller. It's also possible\n// to specify this in a more concise way using a pragma. See the loop unroll\n// tutorial for more information.\ntemplate <int Begin, int End>\nstruct Unroller {\n  template <typename Action>\n  static void step(const Action &action) {\n    action(Begin);\n    Unroller<Begin + 1, End>::step(action);\n  }\n};\n\ntemplate <int End>\nstruct Unroller<End, End> {\n  template <typename Action>\n  static void step(const Action &action) {}\n};\n\nint GetHuffLiteralBits(unsigned char ch) {\n  CtData static_ltree[kLCodes + 2] = {\n      {12, 8},  {140, 8}, {76, 8},  {204, 8}, {44, 8},  {172, 8}, {108, 8},\n      {236, 8}, {28, 8},  {156, 8}, {92, 8},  {220, 8}, {60, 8},  {188, 8},\n      {124, 8}, {252, 8}, {2, 8},   {130, 8}, {66, 8},  {194, 8}, {34, 8},\n      {162, 8}, {98, 8},  {226, 8}, {18, 8},  {146, 8}, {82, 8},  {210, 8},\n      {50, 8},  {178, 8}, {114, 8}, {242, 8}, {10, 8},  {138, 8}, {74, 8},\n      {202, 8}, {42, 8},  {170, 8}, {106, 8}, {234, 8}, {26, 8},  {154, 8},\n      {90, 8},  {218, 8}, {58, 8},  {186, 8}, {122, 8}, {250, 8}, {6, 8},\n      {134, 8}, {70, 8},  {198, 8}, {38, 8},  {166, 8}, {102, 8}, {230, 8},\n      {22, 8},  {150, 8}, {86, 8},  {214, 8}, {54, 8},  {182, 8}, {118, 8},\n      {246, 8}, {14, 8},  {142, 8}, {78, 8},  {206, 8}, {46, 8},  {174, 8},\n      {110, 8}, {238, 8}, {30, 8},  {158, 8}, {94, 8},  {222, 8}, {62, 8},\n      {190, 8}, {126, 8}, {254, 8}, {1, 8},   {129, 8}, {65, 8},  {193, 8},\n      {33, 8},  {161, 8}, {97, 8},  {225, 8}, {17, 8},  {145, 8}, {81, 8},\n      {209, 8}, {49, 8},  {177, 8}, {113, 8}, {241, 8}, {9, 8},   {137, 8},\n      {73, 8},  {201, 8}, {41, 8},  {169, 8}, {105, 8}, {233, 8}, {25, 8},\n      {153, 8}, {89, 8},  {217, 8}, {57, 8},  {185, 8}, {121, 8}, {249, 8},\n      {5, 8},   {133, 8}, {69, 8},  {197, 8}, {37, 8},  {165, 8}, {101, 8},\n      {229, 8}, {21, 8},  {149, 8}, {85, 8},  {213, 8}, {53, 8},  {181, 8},\n      {117, 8}, {245, 8}, {13, 8},  {141, 8}, {77, 8},  {205, 8}, {45, 8},\n      {173, 8}, {109, 8}, {237, 8}, {29, 8},  {157, 8}, {93, 8},  {221, 8},\n      {61, 8},  {189, 8}, {125, 8}, {253, 8}, {19, 9},  {275, 9}, {147, 9},\n      {403, 9}, {83, 9},  {339, 9}, {211, 9}, {467, 9}, {51, 9},  {307, 9},\n      {179, 9}, {435, 9}, {115, 9}, {371, 9}, {243, 9}, {499, 9}, {11, 9},\n      {267, 9}, {139, 9}, {395, 9}, {75, 9},  {331, 9}, {203, 9}, {459, 9},\n      {43, 9},  {299, 9}, {171, 9}, {427, 9}, {107, 9}, {363, 9}, {235, 9},\n      {491, 9}, {27, 9},  {283, 9}, {155, 9}, {411, 9}, {91, 9},  {347, 9},\n      {219, 9}, {475, 9}, {59, 9},  {315, 9}, {187, 9}, {443, 9}, {123, 9},\n      {379, 9}, {251, 9}, {507, 9}, {7, 9},   {263, 9}, {135, 9}, {391, 9},\n      {71, 9},  {327, 9}, {199, 9}, {455, 9}, {39, 9},  {295, 9}, {167, 9},\n      {423, 9}, {103, 9}, {359, 9}, {231, 9}, {487, 9}, {23, 9},  {279, 9},\n      {151, 9}, {407, 9}, {87, 9},  {343, 9}, {215, 9}, {471, 9}, {55, 9},\n      {311, 9}, {183, 9}, {439, 9}, {119, 9}, {375, 9}, {247, 9}, {503, 9},\n      {15, 9},  {271, 9}, {143, 9}, {399, 9}, {79, 9},  {335, 9}, {207, 9},\n      {463, 9}, {47, 9},  {303, 9}, {175, 9}, {431, 9}, {111, 9}, {367, 9},\n      {239, 9}, {495, 9}, {31, 9},  {287, 9}, {159, 9}, {415, 9}, {95, 9},\n      {351, 9}, {223, 9}, {479, 9}, {63, 9},  {319, 9}, {191, 9}, {447, 9},\n      {127, 9}, {383, 9}, {255, 9}, {511, 9}, {0, 7},   {64, 7},  {32, 7},\n      {96, 7},  {16, 7},  {80, 7},  {48, 7},  {112, 7}, {8, 7},   {72, 7},\n      {40, 7},  {104, 7}, {24, 7},  {88, 7},  {56, 7},  {120, 7}, {4, 7},\n      {68, 7},  {36, 7},  {100, 7}, {20, 7},  {84, 7},  {52, 7},  {116, 7},\n      {3, 8},   {131, 8}, {67, 8},  {195, 8}, {35, 8},  {163, 8}, {99, 8},\n      {227, 8},\n  };\n  return static_ltree[ch].code;\n}\n\nint GetHuffLiteralLen(unsigned char ch) {\n  CtData static_ltree[kLCodes + 2] = {\n      {12, 8},  {140, 8}, {76, 8},  {204, 8}, {44, 8},  {172, 8}, {108, 8},\n      {236, 8}, {28, 8},  {156, 8}, {92, 8},  {220, 8}, {60, 8},  {188, 8},\n      {124, 8}, {252, 8}, {2, 8},   {130, 8}, {66, 8},  {194, 8}, {34, 8},\n      {162, 8}, {98, 8},  {226, 8}, {18, 8},  {146, 8}, {82, 8},  {210, 8},\n      {50, 8},  {178, 8}, {114, 8}, {242, 8}, {10, 8},  {138, 8}, {74, 8},\n      {202, 8}, {42, 8},  {170, 8}, {106, 8}, {234, 8}, {26, 8},  {154, 8},\n      {90, 8},  {218, 8}, {58, 8},  {186, 8}, {122, 8}, {250, 8}, {6, 8},\n      {134, 8}, {70, 8},  {198, 8}, {38, 8},  {166, 8}, {102, 8}, {230, 8},\n      {22, 8},  {150, 8}, {86, 8},  {214, 8}, {54, 8},  {182, 8}, {118, 8},\n      {246, 8}, {14, 8},  {142, 8}, {78, 8},  {206, 8}, {46, 8},  {174, 8},\n      {110, 8}, {238, 8}, {30, 8},  {158, 8}, {94, 8},  {222, 8}, {62, 8},\n      {190, 8}, {126, 8}, {254, 8}, {1, 8},   {129, 8}, {65, 8},  {193, 8},\n      {33, 8},  {161, 8}, {97, 8},  {225, 8}, {17, 8},  {145, 8}, {81, 8},\n      {209, 8}, {49, 8},  {177, 8}, {113, 8}, {241, 8}, {9, 8},   {137, 8},\n      {73, 8},  {201, 8}, {41, 8},  {169, 8}, {105, 8}, {233, 8}, {25, 8},\n      {153, 8}, {89, 8},  {217, 8}, {57, 8},  {185, 8}, {121, 8}, {249, 8},\n      {5, 8},   {133, 8}, {69, 8},  {197, 8}, {37, 8},  {165, 8}, {101, 8},\n      {229, 8}, {21, 8},  {149, 8}, {85, 8},  {213, 8}, {53, 8},  {181, 8},\n      {117, 8}, {245, 8}, {13, 8},  {141, 8}, {77, 8},  {205, 8}, {45, 8},\n      {173, 8}, {109, 8}, {237, 8}, {29, 8},  {157, 8}, {93, 8},  {221, 8},\n      {61, 8},  {189, 8}, {125, 8}, {253, 8}, {19, 9},  {275, 9}, {147, 9},\n      {403, 9}, {83, 9},  {339, 9}, {211, 9}, {467, 9}, {51, 9},  {307, 9},\n      {179, 9}, {435, 9}, {115, 9}, {371, 9}, {243, 9}, {499, 9}, {11, 9},\n      {267, 9}, {139, 9}, {395, 9}, {75, 9},  {331, 9}, {203, 9}, {459, 9},\n      {43, 9},  {299, 9}, {171, 9}, {427, 9}, {107, 9}, {363, 9}, {235, 9},\n      {491, 9}, {27, 9},  {283, 9}, {155, 9}, {411, 9}, {91, 9},  {347, 9},\n      {219, 9}, {475, 9}, {59, 9},  {315, 9}, {187, 9}, {443, 9}, {123, 9},\n      {379, 9}, {251, 9}, {507, 9}, {7, 9},   {263, 9}, {135, 9}, {391, 9},\n      {71, 9},  {327, 9}, {199, 9}, {455, 9}, {39, 9},  {295, 9}, {167, 9},\n      {423, 9}, {103, 9}, {359, 9}, {231, 9}, {487, 9}, {23, 9},  {279, 9},\n      {151, 9}, {407, 9}, {87, 9},  {343, 9}, {215, 9}, {471, 9}, {55, 9},\n      {311, 9}, {183, 9}, {439, 9}, {119, 9}, {375, 9}, {247, 9}, {503, 9},\n      {15, 9},  {271, 9}, {143, 9}, {399, 9}, {79, 9},  {335, 9}, {207, 9},\n      {463, 9}, {47, 9},  {303, 9}, {175, 9}, {431, 9}, {111, 9}, {367, 9},\n      {239, 9}, {495, 9}, {31, 9},  {287, 9}, {159, 9}, {415, 9}, {95, 9},\n      {351, 9}, {223, 9}, {479, 9}, {63, 9},  {319, 9}, {191, 9}, {447, 9},\n      {127, 9}, {383, 9}, {255, 9}, {511, 9}, {0, 7},   {64, 7},  {32, 7},\n      {96, 7},  {16, 7},  {80, 7},  {48, 7},  {112, 7}, {8, 7},   {72, 7},\n      {40, 7},  {104, 7}, {24, 7},  {88, 7},  {56, 7},  {120, 7}, {4, 7},\n      {68, 7},  {36, 7},  {100, 7}, {20, 7},  {84, 7},  {52, 7},  {116, 7},\n      {3, 8},   {131, 8}, {67, 8},  {195, 8}, {35, 8},  {163, 8}, {99, 8},\n      {227, 8},\n  };\n  return static_ltree[ch].len;\n}\n\nint GetHuffRunLen(int len, int initial_dist) {\n  int lc;\n  unsigned code;\n  int extra;\n  int dist;\n  //int local_lbits;\n  int local_llen;\n  //int local_dbits;\n  int local_dlen;\n  //local_lbits = 0;\n  local_llen = 0;\n\n  int base_length[kLengthCodes] = {\n      0,  1,  2,  3,  4,  5,  6,  7,  8,   10,  12,  14,  16,  20, 24,\n      28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0,\n  };\n\n  int extra_lbits[kLengthCodes]  // extra bits for each length code\n      = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2,\n         2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\n  CtData static_ltree[kLCodes + 2] = {\n      {12, 8},  {140, 8}, {76, 8},  {204, 8}, {44, 8},  {172, 8}, {108, 8},\n      {236, 8}, {28, 8},  {156, 8}, {92, 8},  {220, 8}, {60, 8},  {188, 8},\n      {124, 8}, {252, 8}, {2, 8},   {130, 8}, {66, 8},  {194, 8}, {34, 8},\n      {162, 8}, {98, 8},  {226, 8}, {18, 8},  {146, 8}, {82, 8},  {210, 8},\n      {50, 8},  {178, 8}, {114, 8}, {242, 8}, {10, 8},  {138, 8}, {74, 8},\n      {202, 8}, {42, 8},  {170, 8}, {106, 8}, {234, 8}, {26, 8},  {154, 8},\n      {90, 8},  {218, 8}, {58, 8},  {186, 8}, {122, 8}, {250, 8}, {6, 8},\n      {134, 8}, {70, 8},  {198, 8}, {38, 8},  {166, 8}, {102, 8}, {230, 8},\n      {22, 8},  {150, 8}, {86, 8},  {214, 8}, {54, 8},  {182, 8}, {118, 8},\n      {246, 8}, {14, 8},  {142, 8}, {78, 8},  {206, 8}, {46, 8},  {174, 8},\n      {110, 8}, {238, 8}, {30, 8},  {158, 8}, {94, 8},  {222, 8}, {62, 8},\n      {190, 8}, {126, 8}, {254, 8}, {1, 8},   {129, 8}, {65, 8},  {193, 8},\n      {33, 8},  {161, 8}, {97, 8},  {225, 8}, {17, 8},  {145, 8}, {81, 8},\n      {209, 8}, {49, 8},  {177, 8}, {113, 8}, {241, 8}, {9, 8},   {137, 8},\n      {73, 8},  {201, 8}, {41, 8},  {169, 8}, {105, 8}, {233, 8}, {25, 8},\n      {153, 8}, {89, 8},  {217, 8}, {57, 8},  {185, 8}, {121, 8}, {249, 8},\n      {5, 8},   {133, 8}, {69, 8},  {197, 8}, {37, 8},  {165, 8}, {101, 8},\n      {229, 8}, {21, 8},  {149, 8}, {85, 8},  {213, 8}, {53, 8},  {181, 8},\n      {117, 8}, {245, 8}, {13, 8},  {141, 8}, {77, 8},  {205, 8}, {45, 8},\n      {173, 8}, {109, 8}, {237, 8}, {29, 8},  {157, 8}, {93, 8},  {221, 8},\n      {61, 8},  {189, 8}, {125, 8}, {253, 8}, {19, 9},  {275, 9}, {147, 9},\n      {403, 9}, {83, 9},  {339, 9}, {211, 9}, {467, 9}, {51, 9},  {307, 9},\n      {179, 9}, {435, 9}, {115, 9}, {371, 9}, {243, 9}, {499, 9}, {11, 9},\n      {267, 9}, {139, 9}, {395, 9}, {75, 9},  {331, 9}, {203, 9}, {459, 9},\n      {43, 9},  {299, 9}, {171, 9}, {427, 9}, {107, 9}, {363, 9}, {235, 9},\n      {491, 9}, {27, 9},  {283, 9}, {155, 9}, {411, 9}, {91, 9},  {347, 9},\n      {219, 9}, {475, 9}, {59, 9},  {315, 9}, {187, 9}, {443, 9}, {123, 9},\n      {379, 9}, {251, 9}, {507, 9}, {7, 9},   {263, 9}, {135, 9}, {391, 9},\n      {71, 9},  {327, 9}, {199, 9}, {455, 9}, {39, 9},  {295, 9}, {167, 9},\n      {423, 9}, {103, 9}, {359, 9}, {231, 9}, {487, 9}, {23, 9},  {279, 9},\n      {151, 9}, {407, 9}, {87, 9},  {343, 9}, {215, 9}, {471, 9}, {55, 9},\n      {311, 9}, {183, 9}, {439, 9}, {119, 9}, {375, 9}, {247, 9}, {503, 9},\n      {15, 9},  {271, 9}, {143, 9}, {399, 9}, {79, 9},  {335, 9}, {207, 9},\n      {463, 9}, {47, 9},  {303, 9}, {175, 9}, {431, 9}, {111, 9}, {367, 9},\n      {239, 9}, {495, 9}, {31, 9},  {287, 9}, {159, 9}, {415, 9}, {95, 9},\n      {351, 9}, {223, 9}, {479, 9}, {63, 9},  {319, 9}, {191, 9}, {447, 9},\n      {127, 9}, {383, 9}, {255, 9}, {511, 9}, {0, 7},   {64, 7},  {32, 7},\n      {96, 7},  {16, 7},  {80, 7},  {48, 7},  {112, 7}, {8, 7},   {72, 7},\n      {40, 7},  {104, 7}, {24, 7},  {88, 7},  {56, 7},  {120, 7}, {4, 7},\n      {68, 7},  {36, 7},  {100, 7}, {20, 7},  {84, 7},  {52, 7},  {116, 7},\n      {3, 8},   {131, 8}, {67, 8},  {195, 8}, {35, 8},  {163, 8}, {99, 8},\n      {227, 8},\n  };\n\n  // distance codes. The first 256 values correspond to the distances\n  // 3 .. 258, the last 256 values correspond to the top 8 bits of\n  // the 15 bit distances.\n  unsigned char dist_code[512] = {\n      0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,\n      8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10, 10,\n      10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11,\n      11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,\n      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n      12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n      13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 0,  0,  16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21,\n      21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29,\n  };\n  // length code for each normalized match length (0 == kMinMatch)\n  unsigned char length_code[kMaxMatch - kMinMatch + 1] = {\n      0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9,  10, 10, 11, 11, 12, 12,\n      12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,\n      16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18,\n      18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n      21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n      23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 28,\n  };\n\n  int extra_dbits[kDCodes]  // extra bits for each distance code\n      = {0, 0, 0, 0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,\n         6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};\n\n  int base_dist[kDCodes] = {\n      0,    1,    2,    3,    4,    6,    8,    12,    16,    24,\n      32,   48,   64,   96,   128,  192,  256,  384,   512,   768,\n      1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576,\n  };\n\n  CtData static_dtree[kDCodes] = {\n      {0, 5}, {16, 5}, {8, 5},  {24, 5}, {4, 5}, {20, 5}, {12, 5}, {28, 5},\n      {2, 5}, {18, 5}, {10, 5}, {26, 5}, {6, 5}, {22, 5}, {14, 5}, {30, 5},\n      {1, 5}, {17, 5}, {9, 5},  {25, 5}, {5, 5}, {21, 5}, {13, 5}, {29, 5},\n      {3, 5}, {19, 5}, {11, 5}, {27, 5}, {7, 5}, {23, 5},\n  };\n\n  lc = len - kMinMatch;\n  code = length_code[lc];\n\n  //local_lbits = static_ltree[code + kLiterals + 1].code;\n  local_llen = static_ltree[code + kLiterals + 1].len;\n  extra = extra_lbits[code];\n  if (extra) {\n    lc -= base_length[code];\n    //local_lbits |= lc << local_llen;\n    local_llen += extra;\n  }\n\n  dist = initial_dist;\n  dist--;\n  code = d_code(dist);\n  //local_dbits = static_dtree[code].code;\n  local_dlen = static_dtree[code].len;\n  extra = extra_dbits[code];\n  if (extra) {\n    dist -= base_dist[code];\n    //local_dbits |= dist << local_dlen;\n    local_dlen += extra;\n  }\n\n  //local_lbits |= local_dbits << local_llen;\n  local_llen += local_dlen;\n\n  return local_llen;\n}\n\nint GetHuffRunBits(int len, int initial_dist) {\n  int lc;\n  unsigned code;\n  int extra;\n  int dist;\n  int local_lbits, local_llen;\n  int local_dbits, local_dlen;\n  local_lbits = 0;\n  local_llen = 0;\n\n  int base_length[kLengthCodes] = {\n      0,  1,  2,  3,  4,  5,  6,  7,  8,   10,  12,  14,  16,  20, 24,\n      28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0,\n  };\n\n  int extra_lbits[kLengthCodes]  // extra bits for each length code\n      = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2,\n         2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\n  CtData static_ltree[kLCodes + 2] = {\n      {12, 8},  {140, 8}, {76, 8},  {204, 8}, {44, 8},  {172, 8}, {108, 8},\n      {236, 8}, {28, 8},  {156, 8}, {92, 8},  {220, 8}, {60, 8},  {188, 8},\n      {124, 8}, {252, 8}, {2, 8},   {130, 8}, {66, 8},  {194, 8}, {34, 8},\n      {162, 8}, {98, 8},  {226, 8}, {18, 8},  {146, 8}, {82, 8},  {210, 8},\n      {50, 8},  {178, 8}, {114, 8}, {242, 8}, {10, 8},  {138, 8}, {74, 8},\n      {202, 8}, {42, 8},  {170, 8}, {106, 8}, {234, 8}, {26, 8},  {154, 8},\n      {90, 8},  {218, 8}, {58, 8},  {186, 8}, {122, 8}, {250, 8}, {6, 8},\n      {134, 8}, {70, 8},  {198, 8}, {38, 8},  {166, 8}, {102, 8}, {230, 8},\n      {22, 8},  {150, 8}, {86, 8},  {214, 8}, {54, 8},  {182, 8}, {118, 8},\n      {246, 8}, {14, 8},  {142, 8}, {78, 8},  {206, 8}, {46, 8},  {174, 8},\n      {110, 8}, {238, 8}, {30, 8},  {158, 8}, {94, 8},  {222, 8}, {62, 8},\n      {190, 8}, {126, 8}, {254, 8}, {1, 8},   {129, 8}, {65, 8},  {193, 8},\n      {33, 8},  {161, 8}, {97, 8},  {225, 8}, {17, 8},  {145, 8}, {81, 8},\n      {209, 8}, {49, 8},  {177, 8}, {113, 8}, {241, 8}, {9, 8},   {137, 8},\n      {73, 8},  {201, 8}, {41, 8},  {169, 8}, {105, 8}, {233, 8}, {25, 8},\n      {153, 8}, {89, 8},  {217, 8}, {57, 8},  {185, 8}, {121, 8}, {249, 8},\n      {5, 8},   {133, 8}, {69, 8},  {197, 8}, {37, 8},  {165, 8}, {101, 8},\n      {229, 8}, {21, 8},  {149, 8}, {85, 8},  {213, 8}, {53, 8},  {181, 8},\n      {117, 8}, {245, 8}, {13, 8},  {141, 8}, {77, 8},  {205, 8}, {45, 8},\n      {173, 8}, {109, 8}, {237, 8}, {29, 8},  {157, 8}, {93, 8},  {221, 8},\n      {61, 8},  {189, 8}, {125, 8}, {253, 8}, {19, 9},  {275, 9}, {147, 9},\n      {403, 9}, {83, 9},  {339, 9}, {211, 9}, {467, 9}, {51, 9},  {307, 9},\n      {179, 9}, {435, 9}, {115, 9}, {371, 9}, {243, 9}, {499, 9}, {11, 9},\n      {267, 9}, {139, 9}, {395, 9}, {75, 9},  {331, 9}, {203, 9}, {459, 9},\n      {43, 9},  {299, 9}, {171, 9}, {427, 9}, {107, 9}, {363, 9}, {235, 9},\n      {491, 9}, {27, 9},  {283, 9}, {155, 9}, {411, 9}, {91, 9},  {347, 9},\n      {219, 9}, {475, 9}, {59, 9},  {315, 9}, {187, 9}, {443, 9}, {123, 9},\n      {379, 9}, {251, 9}, {507, 9}, {7, 9},   {263, 9}, {135, 9}, {391, 9},\n      {71, 9},  {327, 9}, {199, 9}, {455, 9}, {39, 9},  {295, 9}, {167, 9},\n      {423, 9}, {103, 9}, {359, 9}, {231, 9}, {487, 9}, {23, 9},  {279, 9},\n      {151, 9}, {407, 9}, {87, 9},  {343, 9}, {215, 9}, {471, 9}, {55, 9},\n      {311, 9}, {183, 9}, {439, 9}, {119, 9}, {375, 9}, {247, 9}, {503, 9},\n      {15, 9},  {271, 9}, {143, 9}, {399, 9}, {79, 9},  {335, 9}, {207, 9},\n      {463, 9}, {47, 9},  {303, 9}, {175, 9}, {431, 9}, {111, 9}, {367, 9},\n      {239, 9}, {495, 9}, {31, 9},  {287, 9}, {159, 9}, {415, 9}, {95, 9},\n      {351, 9}, {223, 9}, {479, 9}, {63, 9},  {319, 9}, {191, 9}, {447, 9},\n      {127, 9}, {383, 9}, {255, 9}, {511, 9}, {0, 7},   {64, 7},  {32, 7},\n      {96, 7},  {16, 7},  {80, 7},  {48, 7},  {112, 7}, {8, 7},   {72, 7},\n      {40, 7},  {104, 7}, {24, 7},  {88, 7},  {56, 7},  {120, 7}, {4, 7},\n      {68, 7},  {36, 7},  {100, 7}, {20, 7},  {84, 7},  {52, 7},  {116, 7},\n      {3, 8},   {131, 8}, {67, 8},  {195, 8}, {35, 8},  {163, 8}, {99, 8},\n      {227, 8},\n  };\n\n  // distance codes. The first 256 values correspond to the distances\n  // 3 .. 258, the last 256 values correspond to the top 8 bits of\n  // the 15 bit distances.\n  unsigned char dist_code[512] = {\n      0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,\n      8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10, 10,\n      10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11,\n      11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,\n      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n      12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n      13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 0,  0,  16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21,\n      21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29,\n  };\n  // length code for each normalized match length (0 == kMinMatch)\n  unsigned char length_code[kMaxMatch - kMinMatch + 1] = {\n      0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9,  10, 10, 11, 11, 12, 12,\n      12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,\n      16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18,\n      18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n      21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n      23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 28,\n  };\n\n  int extra_dbits[kDCodes]  // extra bits for each distance code\n      = {0, 0, 0, 0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,\n         6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};\n\n  int base_dist[kDCodes] = {\n      0,    1,    2,    3,    4,    6,    8,    12,    16,    24,\n      32,   48,   64,   96,   128,  192,  256,  384,   512,   768,\n      1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576,\n  };\n\n  CtData static_dtree[kDCodes] = {\n      {0, 5}, {16, 5}, {8, 5},  {24, 5}, {4, 5}, {20, 5}, {12, 5}, {28, 5},\n      {2, 5}, {18, 5}, {10, 5}, {26, 5}, {6, 5}, {22, 5}, {14, 5}, {30, 5},\n      {1, 5}, {17, 5}, {9, 5},  {25, 5}, {5, 5}, {21, 5}, {13, 5}, {29, 5},\n      {3, 5}, {19, 5}, {11, 5}, {27, 5}, {7, 5}, {23, 5},\n  };\n\n  lc = len - kMinMatch;\n  code = length_code[lc];\n\n  local_lbits = static_ltree[code + kLiterals + 1].code;\n  local_llen = static_ltree[code + kLiterals + 1].len;\n  extra = extra_lbits[code];\n  if (extra) {\n    lc -= base_length[code];\n    local_lbits |= lc << local_llen;\n    local_llen += extra;\n  }\n\n  dist = initial_dist;\n  dist--;\n  code = d_code(dist);\n  local_dbits = static_dtree[code].code;\n  local_dlen = static_dtree[code].len;\n  extra = extra_dbits[code];\n  if (extra) {\n    dist -= base_dist[code];\n    local_dbits |= dist << local_dlen;\n    local_dlen += extra;\n  }\n\n  local_lbits |= local_dbits << local_llen;\n  local_llen += local_dlen;\n\n  return local_lbits;\n}\n\nint GetHuffLen(int len, int dist, unsigned char ch) {\n  int returned_len;\n\n  CtData static_ltree[kLCodes + 2] = {\n      {12, 8},  {140, 8}, {76, 8},  {204, 8}, {44, 8},  {172, 8}, {108, 8},\n      {236, 8}, {28, 8},  {156, 8}, {92, 8},  {220, 8}, {60, 8},  {188, 8},\n      {124, 8}, {252, 8}, {2, 8},   {130, 8}, {66, 8},  {194, 8}, {34, 8},\n      {162, 8}, {98, 8},  {226, 8}, {18, 8},  {146, 8}, {82, 8},  {210, 8},\n      {50, 8},  {178, 8}, {114, 8}, {242, 8}, {10, 8},  {138, 8}, {74, 8},\n      {202, 8}, {42, 8},  {170, 8}, {106, 8}, {234, 8}, {26, 8},  {154, 8},\n      {90, 8},  {218, 8}, {58, 8},  {186, 8}, {122, 8}, {250, 8}, {6, 8},\n      {134, 8}, {70, 8},  {198, 8}, {38, 8},  {166, 8}, {102, 8}, {230, 8},\n      {22, 8},  {150, 8}, {86, 8},  {214, 8}, {54, 8},  {182, 8}, {118, 8},\n      {246, 8}, {14, 8},  {142, 8}, {78, 8},  {206, 8}, {46, 8},  {174, 8},\n      {110, 8}, {238, 8}, {30, 8},  {158, 8}, {94, 8},  {222, 8}, {62, 8},\n      {190, 8}, {126, 8}, {254, 8}, {1, 8},   {129, 8}, {65, 8},  {193, 8},\n      {33, 8},  {161, 8}, {97, 8},  {225, 8}, {17, 8},  {145, 8}, {81, 8},\n      {209, 8}, {49, 8},  {177, 8}, {113, 8}, {241, 8}, {9, 8},   {137, 8},\n      {73, 8},  {201, 8}, {41, 8},  {169, 8}, {105, 8}, {233, 8}, {25, 8},\n      {153, 8}, {89, 8},  {217, 8}, {57, 8},  {185, 8}, {121, 8}, {249, 8},\n      {5, 8},   {133, 8}, {69, 8},  {197, 8}, {37, 8},  {165, 8}, {101, 8},\n      {229, 8}, {21, 8},  {149, 8}, {85, 8},  {213, 8}, {53, 8},  {181, 8},\n      {117, 8}, {245, 8}, {13, 8},  {141, 8}, {77, 8},  {205, 8}, {45, 8},\n      {173, 8}, {109, 8}, {237, 8}, {29, 8},  {157, 8}, {93, 8},  {221, 8},\n      {61, 8},  {189, 8}, {125, 8}, {253, 8}, {19, 9},  {275, 9}, {147, 9},\n      {403, 9}, {83, 9},  {339, 9}, {211, 9}, {467, 9}, {51, 9},  {307, 9},\n      {179, 9}, {435, 9}, {115, 9}, {371, 9}, {243, 9}, {499, 9}, {11, 9},\n      {267, 9}, {139, 9}, {395, 9}, {75, 9},  {331, 9}, {203, 9}, {459, 9},\n      {43, 9},  {299, 9}, {171, 9}, {427, 9}, {107, 9}, {363, 9}, {235, 9},\n      {491, 9}, {27, 9},  {283, 9}, {155, 9}, {411, 9}, {91, 9},  {347, 9},\n      {219, 9}, {475, 9}, {59, 9},  {315, 9}, {187, 9}, {443, 9}, {123, 9},\n      {379, 9}, {251, 9}, {507, 9}, {7, 9},   {263, 9}, {135, 9}, {391, 9},\n      {71, 9},  {327, 9}, {199, 9}, {455, 9}, {39, 9},  {295, 9}, {167, 9},\n      {423, 9}, {103, 9}, {359, 9}, {231, 9}, {487, 9}, {23, 9},  {279, 9},\n      {151, 9}, {407, 9}, {87, 9},  {343, 9}, {215, 9}, {471, 9}, {55, 9},\n      {311, 9}, {183, 9}, {439, 9}, {119, 9}, {375, 9}, {247, 9}, {503, 9},\n      {15, 9},  {271, 9}, {143, 9}, {399, 9}, {79, 9},  {335, 9}, {207, 9},\n      {463, 9}, {47, 9},  {303, 9}, {175, 9}, {431, 9}, {111, 9}, {367, 9},\n      {239, 9}, {495, 9}, {31, 9},  {287, 9}, {159, 9}, {415, 9}, {95, 9},\n      {351, 9}, {223, 9}, {479, 9}, {63, 9},  {319, 9}, {191, 9}, {447, 9},\n      {127, 9}, {383, 9}, {255, 9}, {511, 9}, {0, 7},   {64, 7},  {32, 7},\n      {96, 7},  {16, 7},  {80, 7},  {48, 7},  {112, 7}, {8, 7},   {72, 7},\n      {40, 7},  {104, 7}, {24, 7},  {88, 7},  {56, 7},  {120, 7}, {4, 7},\n      {68, 7},  {36, 7},  {100, 7}, {20, 7},  {84, 7},  {52, 7},  {116, 7},\n      {3, 8},   {131, 8}, {67, 8},  {195, 8}, {35, 8},  {163, 8}, {99, 8},\n      {227, 8},\n  };\n  switch (len) {\n    case -3:\n      returned_len = static_ltree[kEndBlock].len;\n      break;\n    case -2:\n      returned_len = 3;\n      break;\n    case -1:\n      returned_len = 0;\n      break;\n    case 0:\n      returned_len = GetHuffLiteralLen(ch);\n      break;\n    default:\n      returned_len = GetHuffRunLen(len, dist);\n      break;\n  }\n  return returned_len;\n}\n\nint IsValid(int len, int dist, unsigned char ch) {\n  switch (len) {\n    case -3:\n      return 1;\n    case -2:\n      return 1;\n    case -1:\n      return 0;\n    case 0:\n      return 1;\n    default:\n      return 1;\n  }\n}\n\nint GetHuffBits(int len, int dist, unsigned char ch) {\n  int bits;\n  CtData static_ltree[kLCodes + 2] = {\n      {12, 8},  {140, 8}, {76, 8},  {204, 8}, {44, 8},  {172, 8}, {108, 8},\n      {236, 8}, {28, 8},  {156, 8}, {92, 8},  {220, 8}, {60, 8},  {188, 8},\n      {124, 8}, {252, 8}, {2, 8},   {130, 8}, {66, 8},  {194, 8}, {34, 8},\n      {162, 8}, {98, 8},  {226, 8}, {18, 8},  {146, 8}, {82, 8},  {210, 8},\n      {50, 8},  {178, 8}, {114, 8}, {242, 8}, {10, 8},  {138, 8}, {74, 8},\n      {202, 8}, {42, 8},  {170, 8}, {106, 8}, {234, 8}, {26, 8},  {154, 8},\n      {90, 8},  {218, 8}, {58, 8},  {186, 8}, {122, 8}, {250, 8}, {6, 8},\n      {134, 8}, {70, 8},  {198, 8}, {38, 8},  {166, 8}, {102, 8}, {230, 8},\n      {22, 8},  {150, 8}, {86, 8},  {214, 8}, {54, 8},  {182, 8}, {118, 8},\n      {246, 8}, {14, 8},  {142, 8}, {78, 8},  {206, 8}, {46, 8},  {174, 8},\n      {110, 8}, {238, 8}, {30, 8},  {158, 8}, {94, 8},  {222, 8}, {62, 8},\n      {190, 8}, {126, 8}, {254, 8}, {1, 8},   {129, 8}, {65, 8},  {193, 8},\n      {33, 8},  {161, 8}, {97, 8},  {225, 8}, {17, 8},  {145, 8}, {81, 8},\n      {209, 8}, {49, 8},  {177, 8}, {113, 8}, {241, 8}, {9, 8},   {137, 8},\n      {73, 8},  {201, 8}, {41, 8},  {169, 8}, {105, 8}, {233, 8}, {25, 8},\n      {153, 8}, {89, 8},  {217, 8}, {57, 8},  {185, 8}, {121, 8}, {249, 8},\n      {5, 8},   {133, 8}, {69, 8},  {197, 8}, {37, 8},  {165, 8}, {101, 8},\n      {229, 8}, {21, 8},  {149, 8}, {85, 8},  {213, 8}, {53, 8},  {181, 8},\n      {117, 8}, {245, 8}, {13, 8},  {141, 8}, {77, 8},  {205, 8}, {45, 8},\n      {173, 8}, {109, 8}, {237, 8}, {29, 8},  {157, 8}, {93, 8},  {221, 8},\n      {61, 8},  {189, 8}, {125, 8}, {253, 8}, {19, 9},  {275, 9}, {147, 9},\n      {403, 9}, {83, 9},  {339, 9}, {211, 9}, {467, 9}, {51, 9},  {307, 9},\n      {179, 9}, {435, 9}, {115, 9}, {371, 9}, {243, 9}, {499, 9}, {11, 9},\n      {267, 9}, {139, 9}, {395, 9}, {75, 9},  {331, 9}, {203, 9}, {459, 9},\n      {43, 9},  {299, 9}, {171, 9}, {427, 9}, {107, 9}, {363, 9}, {235, 9},\n      {491, 9}, {27, 9},  {283, 9}, {155, 9}, {411, 9}, {91, 9},  {347, 9},\n      {219, 9}, {475, 9}, {59, 9},  {315, 9}, {187, 9}, {443, 9}, {123, 9},\n      {379, 9}, {251, 9}, {507, 9}, {7, 9},   {263, 9}, {135, 9}, {391, 9},\n      {71, 9},  {327, 9}, {199, 9}, {455, 9}, {39, 9},  {295, 9}, {167, 9},\n      {423, 9}, {103, 9}, {359, 9}, {231, 9}, {487, 9}, {23, 9},  {279, 9},\n      {151, 9}, {407, 9}, {87, 9},  {343, 9}, {215, 9}, {471, 9}, {55, 9},\n      {311, 9}, {183, 9}, {439, 9}, {119, 9}, {375, 9}, {247, 9}, {503, 9},\n      {15, 9},  {271, 9}, {143, 9}, {399, 9}, {79, 9},  {335, 9}, {207, 9},\n      {463, 9}, {47, 9},  {303, 9}, {175, 9}, {431, 9}, {111, 9}, {367, 9},\n      {239, 9}, {495, 9}, {31, 9},  {287, 9}, {159, 9}, {415, 9}, {95, 9},\n      {351, 9}, {223, 9}, {479, 9}, {63, 9},  {319, 9}, {191, 9}, {447, 9},\n      {127, 9}, {383, 9}, {255, 9}, {511, 9}, {0, 7},   {64, 7},  {32, 7},\n      {96, 7},  {16, 7},  {80, 7},  {48, 7},  {112, 7}, {8, 7},   {72, 7},\n      {40, 7},  {104, 7}, {24, 7},  {88, 7},  {56, 7},  {120, 7}, {4, 7},\n      {68, 7},  {36, 7},  {100, 7}, {20, 7},  {84, 7},  {52, 7},  {116, 7},\n      {3, 8},   {131, 8}, {67, 8},  {195, 8}, {35, 8},  {163, 8}, {99, 8},\n      {227, 8},\n  };\n  switch (len) {\n    case -3:\n      bits = static_ltree[kEndBlock].code;\n      break;\n    case -2:\n      bits = ch;\n      break;\n    case -1:\n      bits = 0;\n      break;\n    case 0:\n      bits = GetHuffLiteralBits(ch);\n      break;\n    default:\n      bits = GetHuffRunBits(len, dist);\n      break;\n  }\n  return bits;\n}\n\n// assembles up to kVecX2 unsigned char values based on given huffman encoding\n// writes up to kMaxHuffcodeBits * kVecX2 bits to memory\nbool HufEnc(char *len, short *dist, unsigned char *data, unsigned int *outdata,\n            unsigned int *leftover, unsigned short *leftover_size) {\n  // array that contains the bit position of each symbol\n  unsigned short bitpos[kVec + 1];\n  bitpos[0] = 0;\n\n  Unroller<0, kVec>::step([&](int i) {\n    bitpos[i + 1] = bitpos[i] + (IsValid(len[i], dist[i], data[i])\n                                     ? GetHuffLen(len[i], dist[i], data[i])\n                                     : 0);\n  });\n\n  // leftover is an array that carries huffman encoded data not yet written to\n  // memory adjust leftover_size with the number of bits to write this time\n  unsigned short prev_cycle_offset = *leftover_size;\n  *leftover_size += (bitpos[kVec] & 0x3fff);\n\n  // we'll write this cycle if we have collected enough data (kVec shorts or\n  // more)\n  bool write = *leftover_size & (kVec * (kMaxHuffcodeBits * 2));\n\n  // subtract kVec shorts from leftover size (if it's bigger\n  // than kVec) because we'll write those out this cycle\n  *leftover_size &= ~(kVec * (kMaxHuffcodeBits * 2));\n\n  // Adjust bitpos based on leftover offset from previous cycle\n  Unroller<0, kVec>::step(\n      [&](int i) { bitpos[i] += (prev_cycle_offset & 0x3fff); });\n\n  // Huffman codes have any bit alignement, so they can spill\n  // onto two shorts in the output array\n  // use ushort2 to keep each part of the code separate\n  // Iterate over all codes and construct ushort2 containing\n  // the code properly aligned\n  struct Uint2Gzip code[kVec];\n  Unroller<0, kVec>::step([&](int i) {\n    code[i].x = 0;\n    code[i].y = 0;\n  });\n\n  Unroller<0, kVec>::step([&](int i) {\n    // Codes can be more than 16 bits, so use uint32\n    unsigned int curr_code = GetHuffBits(len[i], dist[i], data[i]);\n    unsigned char bitpos_in_short = bitpos[i] & 0x01F;\n\n    unsigned long long temp = (unsigned long long)curr_code << bitpos_in_short;\n    unsigned int temp1 = (unsigned int)temp;\n    unsigned int temp2 = temp >> 32ULL;\n\n    if (IsValid(len[i], dist[i], data[i])) {\n      code[i].x = temp1;\n      code[i].y = temp2;\n    } else {\n      code[i].x = temp1;\n      code[i].y = temp2;\n    }\n  });\n\n  // Iterate over all destination locations and gather the required data\n  unsigned int new_leftover[kVec];\n  Unroller<0, kVec>::step([&](int i) {\n    new_leftover[i] = 0;\n    outdata[i] = 0;\n\n    Unroller<0, kVec>::step([&](int j) {\n      // figure out whether code[j] goes into bucket[i]\n      bool match_first = ((bitpos[j] >> 5) & (kVec - 1)) == i;\n      bool match_second =\n          ((bitpos[j] >> 5) & (kVec - 1)) == ((i - 1) & (kVec - 1));\n\n      // if code[j] maps onto current bucket then OR its code, else OR with 0\n      unsigned int component =\n          match_first ? code[j].x : (match_second ? code[j].y : 0);\n\n      // overflow from kVec shorts, need to move onto new_leftover\n      bool use_later =\n          (bitpos[j] & (kVec * (kMaxHuffcodeBits * 2))) ||\n          (match_second && (((bitpos[j] >> 5) & (kVec - 1)) == kVec - 1));\n\n      // write to output\n      outdata[i] |= use_later ? 0 : component;\n      new_leftover[i] |= use_later ? component : 0;\n    });\n  });\n\n  // Apply previous leftover on the outdata\n  // Also, if didn't write, apply prev leftover onto newleftover\n  Unroller<0, kVec>::step([&](int i) {\n    outdata[i] |= leftover[i];\n    leftover[i] = outdata[i];\n  });\n\n  // Split unroll into two unrolls to avoid compiler crash. This is a temporary\n  // workaround while awaiting a compiler feature.\n  if (write) {\n    Unroller<0, kVec>::step([&](int i) { leftover[i] = new_leftover[i]; });\n  }\n\n  return write;\n}\n\ntemplate <int engineID>\nclass CRC;\ntemplate <int engineID>\nclass LZReduction;\ntemplate <int engineID>\nclass StaticHuffman;\ntemplate <int engineID>\nvoid SubmitGzipTasksSingleEngine(\n    queue &q,\n    size_t block_size,  // size of block to compress.\n    buffer<char, 1> *pibuf, buffer<char, 1> *pobuf,\n    buffer<struct GzipOutInfo, 1> *gzip_out_buf,\n    buffer<unsigned, 1> *result_crc, bool last_block, std::vector<event> &e_crc, std::vector<event> &e_lz,\n    std::vector<event> &e_huff, int buffer_index) {\n  using acc_dist_channel = ext::intel::pipe<class some_pipe, struct DistLen>;\n  using acc_dist_channel_last = ext::intel::pipe<class some_pipe2, struct DistLen>;\n\n  e_crc[buffer_index] = q.submit([&](handler &h) {\n    auto accessor_isz = block_size;\n    auto acc_pibuf = pibuf->get_access<access::mode::read>(h);\n    auto accresult_crc = result_crc->get_access<access::mode::discard_write>(h);\n    h.single_task<CRC<engineID>>([=]() [[intel::kernel_args_restrict]] {\n      const unsigned int table64[64][16] = {\n          {\n              0x0,\n              0xf1da05aa,\n              0x38c50d15,\n              0xc91f08bf,\n              0x718a1a2a,\n              0x80501f80,\n              0x494f173f,\n              0xb8951295,\n              0xe3143454,\n              0x12ce31fe,\n              0xdbd13941,\n              0x2a0b3ceb,\n              0x929e2e7e,\n              0x63442bd4,\n              0xaa5b236b,\n              0x5b8126c1,\n          },\n\n          {\n              0x0,\n              0x1d596ee9,\n              0x3ab2ddd2,\n              0x27ebb33b,\n              0x7565bba4,\n              0x683cd54d,\n              0x4fd76676,\n              0x528e089f,\n              0xeacb7748,\n              0xf79219a1,\n              0xd079aa9a,\n              0xcd20c473,\n              0x9faeccec,\n              0x82f7a205,\n              0xa51c113e,\n              0xb8457fd7,\n          },\n\n          {\n              0x0,\n              0xee7e8d1,\n              0x1dcfd1a2,\n              0x13283973,\n              0x3b9fa344,\n              0x35784b95,\n              0x265072e6,\n              0x28b79a37,\n              0x773f4688,\n              0x79d8ae59,\n              0x6af0972a,\n              0x64177ffb,\n              0x4ca0e5cc,\n              0x42470d1d,\n              0x516f346e,\n              0x5f88dcbf,\n          },\n\n          {\n              0x0,\n              0xee7e8d10,\n              0x78c1c61,\n              0xe9f29171,\n              0xf1838c2,\n              0xe166b5d2,\n              0x89424a3,\n              0xe6eaa9b3,\n              0x1e307184,\n              0xf04efc94,\n              0x19bc6de5,\n              0xf7c2e0f5,\n              0x11284946,\n              0xff56c456,\n              0x16a45527,\n              0xf8dad837,\n          },\n\n          {\n              0x0,\n              0x3c60e308,\n              0x78c1c610,\n              0x44a12518,\n              0xf1838c20,\n              0xcde36f28,\n              0x89424a30,\n              0xb522a938,\n              0x38761e01,\n              0x416fd09,\n              0x40b7d811,\n              0x7cd73b19,\n              0xc9f59221,\n              0xf5957129,\n              0xb1345431,\n              0x8d54b739,\n          },\n\n          {\n              0x0,\n              0x70ec3c02,\n              0xe1d87804,\n              0x91344406,\n              0x18c1f649,\n              0x682dca4b,\n              0xf9198e4d,\n              0x89f5b24f,\n              0x3183ec92,\n              0x416fd090,\n              0xd05b9496,\n              0xa0b7a894,\n              0x29421adb,\n              0x59ae26d9,\n              0xc89a62df,\n              0xb8765edd,\n          },\n\n          {\n              0x0,\n              0x6307d924,\n              0xc60fb248,\n              0xa5086b6c,\n              0x576e62d1,\n              0x3469bbf5,\n              0x9161d099,\n              0xf26609bd,\n              0xaedcc5a2,\n              0xcddb1c86,\n              0x68d377ea,\n              0xbd4aece,\n              0xf9b2a773,\n              0x9ab57e57,\n              0x3fbd153b,\n              0x5cbacc1f,\n          },\n\n          {\n              0x0,\n              0x86c88d05,\n              0xd6e01c4b,\n              0x5028914e,\n              0x76b13ed7,\n              0xf079b3d2,\n              0xa051229c,\n              0x2699af99,\n              0xed627dae,\n              0x6baaf0ab,\n              0x3b8261e5,\n              0xbd4aece0,\n              0x9bd34379,\n              0x1d1bce7c,\n              0x4d335f32,\n              0xcbfbd237,\n          },\n\n          {\n              0x0,\n              0x1b5fd1d,\n              0x36bfa3a,\n              0x2de0727,\n              0x6d7f474,\n              0x7620969,\n              0x5bc0e4e,\n              0x409f353,\n              0xdafe8e8,\n              0xc1a15f5,\n              0xec412d2,\n              0xf71efcf,\n              0xb781c9c,\n              0xacde181,\n              0x813e6a6,\n              0x9a61bbb,\n          },\n\n          {\n              0x0,\n              0x1b5fd1d0,\n              0x36bfa3a0,\n              0x2de07270,\n              0x6d7f4740,\n              0x76209690,\n              0x5bc0e4e0,\n              0x409f3530,\n              0xdafe8e80,\n              0xc1a15f50,\n              0xec412d20,\n              0xf71efcf0,\n              0xb781c9c0,\n              0xacde1810,\n              0x813e6a60,\n              0x9a61bbb0,\n          },\n\n          {\n              0x0,\n              0x6e8c1b41,\n              0xdd183682,\n              0xb3942dc3,\n              0x61416b45,\n              0xfcd7004,\n              0xbc595dc7,\n              0xd2d54686,\n              0xc282d68a,\n              0xac0ecdcb,\n              0x1f9ae008,\n              0x7116fb49,\n              0xa3c3bdcf,\n              0xcd4fa68e,\n              0x7edb8b4d,\n              0x1057900c,\n          },\n\n          {\n              0x0,\n              0x5e74ab55,\n              0xbce956aa,\n              0xe29dfdff,\n              0xa2a3ab15,\n              0xfcd70040,\n              0x1e4afdbf,\n              0x403e56ea,\n              0x9e36506b,\n              0xc042fb3e,\n              0x22df06c1,\n              0x7cabad94,\n              0x3c95fb7e,\n              0x62e1502b,\n              0x807cadd4,\n              0xde080681,\n          },\n\n          {\n              0x0,\n              0xe71da697,\n              0x154a4b6f,\n              0xf257edf8,\n              0x2a9496de,\n              0xcd893049,\n              0x3fdeddb1,\n              0xd8c37b26,\n              0x55292dbc,\n              0xb2348b2b,\n              0x406366d3,\n              0xa77ec044,\n              0x7fbdbb62,\n              0x98a01df5,\n              0x6af7f00d,\n              0x8dea569a,\n          },\n\n          {\n              0x0,\n              0xaa525b78,\n              0x8fd5b0b1,\n              0x2587ebc9,\n              0xc4da6723,\n              0x6e883c5b,\n              0x4b0fd792,\n              0xe15d8cea,\n              0x52c5c807,\n              0xf897937f,\n              0xdd1078b6,\n              0x774223ce,\n              0x961faf24,\n              0x3c4df45c,\n              0x19ca1f95,\n              0xb39844ed,\n          },\n\n          {\n              0x0,\n              0xa58b900e,\n              0x9066265d,\n              0x35edb653,\n              0xfbbd4afb,\n              0x5e36daf5,\n              0x6bdb6ca6,\n              0xce50fca8,\n              0x2c0b93b7,\n              0x898003b9,\n              0xbc6db5ea,\n              0x19e625e4,\n              0xd7b6d94c,\n              0x723d4942,\n              0x47d0ff11,\n              0xe25b6f1f,\n          },\n\n          {\n              0x0,\n              0x5817276e,\n              0xb02e4edc,\n              0xe83969b2,\n              0xbb2d9bf9,\n              0xe33abc97,\n              0xb03d525,\n              0x5314f24b,\n              0xad2a31b3,\n              0xf53d16dd,\n              0x1d047f6f,\n              0x45135801,\n              0x1607aa4a,\n              0x4e108d24,\n              0xa629e496,\n              0xfe3ec3f8,\n          },\n\n          {\n              0x0,\n              0x81256527,\n              0xd93bcc0f,\n              0x581ea928,\n              0x69069e5f,\n              0xe823fb78,\n              0xb03d5250,\n              0x31183777,\n              0xd20d3cbe,\n              0x53285999,\n              0xb36f0b1,\n              0x8a139596,\n              0xbb0ba2e1,\n              0x3a2ec7c6,\n              0x62306eee,\n              0xe3150bc9,\n          },\n\n          {\n              0x0,\n              0x7f6b7f3d,\n              0xfed6fe7a,\n              0x81bd8147,\n              0x26dcfab5,\n              0x59b78588,\n              0xd80a04cf,\n              0xa7617bf2,\n              0x4db9f56a,\n              0x32d28a57,\n              0xb36f0b10,\n              0xcc04742d,\n              0x6b650fdf,\n              0x140e70e2,\n              0x95b3f1a5,\n              0xead88e98,\n          },\n\n          {\n              0x0,\n              0x9b73ead4,\n              0xed96d3e9,\n              0x76e5393d,\n              0x5ca193,\n              0x9b2f4b47,\n              0xedca727a,\n              0x76b998ae,\n              0xb94326,\n              0x9bcaa9f2,\n              0xed2f90cf,\n              0x765c7a1b,\n              0xe5e2b5,\n              0x9b960861,\n              0xed73315c,\n              0x7600db88,\n          },\n\n          {\n              0x0,\n              0x172864c,\n              0x2e50c98,\n              0x3978ad4,\n              0x5ca1930,\n              0x4b89f7c,\n              0x72f15a8,\n              0x65d93e4,\n              0xb943260,\n              0xae6b42c,\n              0x9713ef8,\n              0x803b8b4,\n              0xe5e2b50,\n              0xf2cad1c,\n              0xcbb27c8,\n              0xdc9a184,\n          },\n\n          {\n              0x0,\n              0x172864c0,\n              0x2e50c980,\n              0x3978ad40,\n              0x5ca19300,\n              0x4b89f7c0,\n              0x72f15a80,\n              0x65d93e40,\n              0xb9432600,\n              0xae6b42c0,\n              0x9713ef80,\n              0x803b8b40,\n              0xe5e2b500,\n              0xf2cad1c0,\n              0xcbb27c80,\n              0xdc9a1840,\n          },\n\n          {\n              0x0,\n              0xa9f74a41,\n              0x889f92c3,\n              0x2168d882,\n              0xca4e23c7,\n              0x63b96986,\n              0x42d1b104,\n              0xeb26fb45,\n              0x4fed41cf,\n              0xe61a0b8e,\n              0xc772d30c,\n              0x6e85994d,\n              0x85a36208,\n              0x2c542849,\n              0xd3cf0cb,\n              0xa4cbba8a,\n          },\n\n          {\n              0x0,\n              0x9fda839e,\n              0xe4c4017d,\n              0x7b1e82e3,\n              0x12f904bb,\n              0x8d238725,\n              0xf63d05c6,\n              0x69e78658,\n              0x25f20976,\n              0xba288ae8,\n              0xc136080b,\n              0x5eec8b95,\n              0x370b0dcd,\n              0xa8d18e53,\n              0xd3cf0cb0,\n              0x4c158f2e,\n          },\n\n          {\n              0x0,\n              0x4be412ec,\n              0x97c825d8,\n              0xdc2c3734,\n              0xf4e14df1,\n              0xbf055f1d,\n              0x63296829,\n              0x28cd7ac5,\n              0x32b39da3,\n              0x79578f4f,\n              0xa57bb87b,\n              0xee9faa97,\n              0xc652d052,\n              0x8db6c2be,\n              0x519af58a,\n              0x1a7ee766,\n          },\n\n          {\n              0x0,\n              0x65673b46,\n              0xcace768c,\n              0xafa94dca,\n              0x4eedeb59,\n              0x2b8ad01f,\n              0x84239dd5,\n              0xe144a693,\n              0x9ddbd6b2,\n              0xf8bcedf4,\n              0x5715a03e,\n              0x32729b78,\n              0xd3363deb,\n              0xb65106ad,\n              0x19f84b67,\n              0x7c9f7021,\n          },\n\n          {\n              0x0,\n              0xe0c6ab25,\n              0x1afc500b,\n              0xfa3afb2e,\n              0x35f8a016,\n              0xd53e0b33,\n              0x2f04f01d,\n              0xcfc25b38,\n              0x6bf1402c,\n              0x8b37eb09,\n              0x710d1027,\n              0x91cbbb02,\n              0x5e09e03a,\n              0xbecf4b1f,\n              0x44f5b031,\n              0xa4331b14,\n          },\n\n          {\n              0x0,\n              0xd7e28058,\n              0x74b406f1,\n              0xa35686a9,\n              0xe9680de2,\n              0x3e8a8dba,\n              0x9ddc0b13,\n              0x4a3e8b4b,\n              0x9a11d85,\n              0xde439ddd,\n              0x7d151b74,\n              0xaaf79b2c,\n              0xe0c91067,\n              0x372b903f,\n              0x947d1696,\n              0x439f96ce,\n          },\n\n          {\n              0x0,\n              0x13423b0a,\n              0x26847614,\n              0x35c64d1e,\n              0x4d08ec28,\n              0x5e4ad722,\n              0x6b8c9a3c,\n              0x78cea136,\n              0x9a11d850,\n              0x8953e35a,\n              0xbc95ae44,\n              0xafd7954e,\n              0xd7193478,\n              0xc45b0f72,\n              0xf19d426c,\n              0xe2df7966,\n          },\n\n          {\n              0x0,\n              0xef52b6e1,\n              0x5d46b83,\n              0xea86dd62,\n              0xba8d706,\n              0xe4fa61e7,\n              0xe7cbc85,\n              0xe12e0a64,\n              0x1751ae0c,\n              0xf80318ed,\n              0x1285c58f,\n              0xfdd7736e,\n              0x1cf9790a,\n              0xf3abcfeb,\n              0x192d1289,\n              0xf67fa468,\n          },\n\n          {\n              0x0,\n              0x2ea35c18,\n              0x5d46b830,\n              0x73e5e428,\n              0xba8d7060,\n              0x942e2c78,\n              0xe7cbc850,\n              0xc9689448,\n              0xae6be681,\n              0x80c8ba99,\n              0xf32d5eb1,\n              0xdd8e02a9,\n              0x14e696e1,\n              0x3a45caf9,\n              0x49a02ed1,\n              0x670372c9,\n          },\n\n          {\n              0x0,\n              0x87a6cb43,\n              0xd43c90c7,\n              0x539a5b84,\n              0x730827cf,\n              0xf4aeec8c,\n              0xa734b708,\n              0x20927c4b,\n              0xe6104f9e,\n              0x61b684dd,\n              0x322cdf59,\n              0xb58a141a,\n              0x95186851,\n              0x12bea312,\n              0x4124f896,\n              0xc68233d5,\n          },\n\n          {\n              0x0,\n              0x1751997d,\n              0x2ea332fa,\n              0x39f2ab87,\n              0x5d4665f4,\n              0x4a17fc89,\n              0x73e5570e,\n              0x64b4ce73,\n              0xba8ccbe8,\n              0xaddd5295,\n              0x942ff912,\n              0x837e606f,\n              0xe7caae1c,\n              0xf09b3761,\n              0xc9699ce6,\n              0xde38059b,\n          },\n\n          {\n              0x0,\n              0xae689191,\n              0x87a02563,\n              0x29c8b4f2,\n              0xd4314c87,\n              0x7a59dd16,\n              0x539169e4,\n              0xfdf9f875,\n              0x73139f4f,\n              0xdd7b0ede,\n              0xf4b3ba2c,\n              0x5adb2bbd,\n              0xa722d3c8,\n              0x94a4259,\n              0x2082f6ab,\n              0x8eea673a,\n          },\n\n          {\n              0x0,\n              0xe6273e9e,\n              0x173f7b7d,\n              0xf11845e3,\n              0x2e7ef6fa,\n              0xc859c864,\n              0x39418d87,\n              0xdf66b319,\n              0x5cfdedf4,\n              0xbadad36a,\n              0x4bc29689,\n              0xade5a817,\n              0x72831b0e,\n              0x94a42590,\n              0x65bc6073,\n              0x839b5eed,\n          },\n\n          {\n              0x0,\n              0xb9fbdbe8,\n              0xa886b191,\n              0x117d6a79,\n              0x8a7c6563,\n              0x3387be8b,\n              0x22fad4f2,\n              0x9b010f1a,\n              0xcf89cc87,\n              0x7672176f,\n              0x670f7d16,\n              0xdef4a6fe,\n              0x45f5a9e4,\n              0xfc0e720c,\n              0xed731875,\n              0x5488c39d,\n          },\n\n          {\n              0x0,\n              0x44629f4f,\n              0x88c53e9e,\n              0xcca7a1d1,\n              0xcafb7b7d,\n              0x8e99e432,\n              0x423e45e3,\n              0x65cdaac,\n              0x4e87f0bb,\n              0xae56ff4,\n              0xc642ce25,\n              0x8220516a,\n              0x847c8bc6,\n              0xc01e1489,\n              0xcb9b558,\n              0x48db2a17,\n          },\n\n          {\n              0x0,\n              0x9d0fe176,\n              0xe16ec4ad,\n              0x7c6125db,\n              0x19ac8f1b,\n              0x84a36e6d,\n              0xf8c24bb6,\n              0x65cdaac0,\n              0x33591e36,\n              0xae56ff40,\n              0xd237da9b,\n              0x4f383bed,\n              0x2af5912d,\n              0xb7fa705b,\n              0xcb9b5580,\n              0x5694b4f6,\n          },\n\n          {\n              0x0,\n              0x66b23c6c,\n              0xcd6478d8,\n              0xabd644b4,\n              0x41b9f7f1,\n              0x270bcb9d,\n              0x8cdd8f29,\n              0xea6fb345,\n              0x8373efe2,\n              0xe5c1d38e,\n              0x4e17973a,\n              0x28a5ab56,\n              0xc2ca1813,\n              0xa478247f,\n              0xfae60cb,\n              0x691c5ca7,\n          },\n\n          {\n              0x0,\n              0xdd96d985,\n              0x605cb54b,\n              0xbdca6cce,\n              0xc0b96a96,\n              0x1d2fb313,\n              0xa0e5dfdd,\n              0x7d730658,\n              0x5a03d36d,\n              0x87950ae8,\n              0x3a5f6626,\n              0xe7c9bfa3,\n              0x9abab9fb,\n              0x472c607e,\n              0xfae60cb0,\n              0x2770d535,\n          },\n\n          {\n              0x0,\n              0xb407a6da,\n              0xb37e4bf5,\n              0x779ed2f,\n              0xbd8d91ab,\n              0x98a3771,\n              0xef3da5e,\n              0xbaf47c84,\n              0xa06a2517,\n              0x146d83cd,\n              0x13146ee2,\n              0xa713c838,\n              0x1de7b4bc,\n              0xa9e01266,\n              0xae99ff49,\n              0x1a9e5993,\n          },\n\n          {\n              0x0,\n              0x9ba54c6f,\n              0xec3b9e9f,\n              0x779ed2f0,\n              0x3063b7f,\n              0x98a37710,\n              0xef3da5e0,\n              0x7498e98f,\n              0x60c76fe,\n              0x9da93a91,\n              0xea37e861,\n              0x7192a40e,\n              0x50a4d81,\n              0x9eaf01ee,\n              0xe931d31e,\n              0x72949f71,\n          },\n\n          {\n              0x0,\n              0xc18edfc,\n              0x1831dbf8,\n              0x14293604,\n              0x3063b7f0,\n              0x3c7b5a0c,\n              0x28526c08,\n              0x244a81f4,\n              0x60c76fe0,\n              0x6cdf821c,\n              0x78f6b418,\n              0x74ee59e4,\n              0x50a4d810,\n              0x5cbc35ec,\n              0x489503e8,\n              0x448dee14,\n          },\n\n          {\n              0x0,\n              0xc18edfc0,\n              0x586cb9c1,\n              0x99e26601,\n              0xb0d97382,\n              0x7157ac42,\n              0xe8b5ca43,\n              0x293b1583,\n              0xbac3e145,\n              0x7b4d3e85,\n              0xe2af5884,\n              0x23218744,\n              0xa1a92c7,\n              0xcb944d07,\n              0x52762b06,\n              0x93f8f4c6,\n          },\n\n          {\n              0x0,\n              0xaef6c4cb,\n              0x869c8fd7,\n              0x286a4b1c,\n              0xd64819ef,\n              0x78bedd24,\n              0x50d49638,\n              0xfe2252f3,\n              0x77e1359f,\n              0xd917f154,\n              0xf17dba48,\n              0x5f8b7e83,\n              0xa1a92c70,\n              0xf5fe8bb,\n              0x2735a3a7,\n              0x89c3676c,\n          },\n\n          {\n              0x0,\n              0xefc26b3e,\n              0x4f5d03d,\n              0xeb37bb03,\n              0x9eba07a,\n              0xe629cb44,\n              0xd1e7047,\n              0xe2dc1b79,\n              0x13d740f4,\n              0xfc152bca,\n              0x172290c9,\n              0xf8e0fbf7,\n              0x1a3ce08e,\n              0xf5fe8bb0,\n              0x1ec930b3,\n              0xf10b5b8d,\n          },\n\n          {\n              0x0,\n              0x27ae81e8,\n              0x4f5d03d0,\n              0x68f38238,\n              0x9eba07a0,\n              0xb9148648,\n              0xd1e70470,\n              0xf6498598,\n              0xe6050901,\n              0xc1ab88e9,\n              0xa9580ad1,\n              0x8ef68b39,\n              0x78bf0ea1,\n              0x5f118f49,\n              0x37e20d71,\n              0x104c8c99,\n          },\n\n          {\n              0x0,\n              0x177b1443,\n              0x2ef62886,\n              0x398d3cc5,\n              0x5dec510c,\n              0x4a97454f,\n              0x731a798a,\n              0x64616dc9,\n              0xbbd8a218,\n              0xaca3b65b,\n              0x952e8a9e,\n              0x82559edd,\n              0xe634f314,\n              0xf14fe757,\n              0xc8c2db92,\n              0xdfb9cfd1,\n          },\n\n          {\n              0x0,\n              0xacc04271,\n              0x82f182a3,\n              0x2e31c0d2,\n              0xde920307,\n              0x72524176,\n              0x5c6381a4,\n              0xf0a3c3d5,\n              0x6655004f,\n              0xca95423e,\n              0xe4a482ec,\n              0x4864c09d,\n              0xb8c70348,\n              0x14074139,\n              0x3a3681eb,\n              0x96f6c39a,\n          },\n\n          {\n              0x0,\n              0xccaa009e,\n              0x4225077d,\n              0x8e8f07e3,\n              0x844a0efa,\n              0x48e00e64,\n              0xc66f0987,\n              0xac50919,\n              0xd3e51bb5,\n              0x1f4f1b2b,\n              0x91c01cc8,\n              0x5d6a1c56,\n              0x57af154f,\n              0x9b0515d1,\n              0x158a1232,\n              0xd92012ac,\n          },\n\n          {\n              0x0,\n              0x7cbb312b,\n              0xf9766256,\n              0x85cd537d,\n              0x299dc2ed,\n              0x5526f3c6,\n              0xd0eba0bb,\n              0xac509190,\n              0x533b85da,\n              0x2f80b4f1,\n              0xaa4de78c,\n              0xd6f6d6a7,\n              0x7aa64737,\n              0x61d761c,\n              0x83d02561,\n              0xff6b144a,\n          },\n\n          {\n              0x0,\n              0xa6770bb4,\n              0x979f1129,\n              0x31e81a9d,\n              0xf44f2413,\n              0x52382fa7,\n              0x63d0353a,\n              0xc5a73e8e,\n              0x33ef4e67,\n              0x959845d3,\n              0xa4705f4e,\n              0x20754fa,\n              0xc7a06a74,\n              0x61d761c0,\n              0x503f7b5d,\n              0xf64870e9,\n          },\n\n          {\n              0x0,\n              0x67de9cce,\n              0xcfbd399c,\n              0xa863a552,\n              0x440b7579,\n              0x23d5e9b7,\n              0x8bb64ce5,\n              0xec68d02b,\n              0x8816eaf2,\n              0xefc8763c,\n              0x47abd36e,\n              0x20754fa0,\n              0xcc1d9f8b,\n              0xabc30345,\n              0x3a0a617,\n              0x647e3ad9,\n          },\n\n          {\n              0x0,\n              0xcb5cd3a5,\n              0x4dc8a10b,\n              0x869472ae,\n              0x9b914216,\n              0x50cd91b3,\n              0xd659e31d,\n              0x1d0530b8,\n              0xec53826d,\n              0x270f51c8,\n              0xa19b2366,\n              0x6ac7f0c3,\n              0x77c2c07b,\n              0xbc9e13de,\n              0x3a0a6170,\n              0xf156b2d5,\n          },\n\n          {\n              0x0,\n              0x3d6029b,\n              0x7ac0536,\n              0x47a07ad,\n              0xf580a6c,\n              0xc8e08f7,\n              0x8f40f5a,\n              0xb220dc1,\n              0x1eb014d8,\n              0x1d661643,\n              0x191c11ee,\n              0x1aca1375,\n              0x11e81eb4,\n              0x123e1c2f,\n              0x16441b82,\n              0x15921919,\n          },\n\n          {\n              0x0,\n              0x3d6029b0,\n              0x7ac05360,\n              0x47a07ad0,\n              0xf580a6c0,\n              0xc8e08f70,\n              0x8f40f5a0,\n              0xb220dc10,\n              0x30704bc1,\n              0xd106271,\n              0x4ab018a1,\n              0x77d03111,\n              0xc5f0ed01,\n              0xf890c4b1,\n              0xbf30be61,\n              0x825097d1,\n          },\n\n          {\n              0x0,\n              0x60e09782,\n              0xc1c12f04,\n              0xa121b886,\n              0x58f35849,\n              0x3813cfcb,\n              0x9932774d,\n              0xf9d2e0cf,\n              0xb1e6b092,\n              0xd1062710,\n              0x70279f96,\n              0x10c70814,\n              0xe915e8db,\n              0x89f57f59,\n              0x28d4c7df,\n              0x4834505d,\n          },\n\n          {\n              0x0,\n              0xb8bc6765,\n              0xaa09c88b,\n              0x12b5afee,\n              0x8f629757,\n              0x37def032,\n              0x256b5fdc,\n              0x9dd738b9,\n              0xc5b428ef,\n              0x7d084f8a,\n              0x6fbde064,\n              0xd7018701,\n              0x4ad6bfb8,\n              0xf26ad8dd,\n              0xe0df7733,\n              0x58631056,\n          },\n\n          {\n              0x0,\n              0x5019579f,\n              0xa032af3e,\n              0xf02bf8a1,\n              0x9b14583d,\n              0xcb0d0fa2,\n              0x3b26f703,\n              0x6b3fa09c,\n              0xed59b63b,\n              0xbd40e1a4,\n              0x4d6b1905,\n              0x1d724e9a,\n              0x764dee06,\n              0x2654b999,\n              0xd67f4138,\n              0x866616a7,\n          },\n\n          {\n              0x0,\n              0x1c26a37,\n              0x384d46e,\n              0x246be59,\n              0x709a8dc,\n              0x6cbc2eb,\n              0x48d7cb2,\n              0x54f1685,\n              0xe1351b8,\n              0xfd13b8f,\n              0xd9785d6,\n              0xc55efe1,\n              0x91af964,\n              0x8d89353,\n              0xa9e2d0a,\n              0xb5c473d,\n          },\n\n          {\n              0x0,\n              0x1c26a370,\n              0x384d46e0,\n              0x246be590,\n              0x709a8dc0,\n              0x6cbc2eb0,\n              0x48d7cb20,\n              0x54f16850,\n              0xe1351b80,\n              0xfd13b8f0,\n              0xd9785d60,\n              0xc55efe10,\n              0x91af9640,\n              0x8d893530,\n              0xa9e2d0a0,\n              0xb5c473d0,\n          },\n\n          {\n              0x0,\n              0x191b3141,\n              0x32366282,\n              0x2b2d53c3,\n              0x646cc504,\n              0x7d77f445,\n              0x565aa786,\n              0x4f4196c7,\n              0xc8d98a08,\n              0xd1c2bb49,\n              0xfaefe88a,\n              0xe3f4d9cb,\n              0xacb54f0c,\n              0xb5ae7e4d,\n              0x9e832d8e,\n              0x87981ccf,\n          },\n\n          {\n              0x0,\n              0x4ac21251,\n              0x958424a2,\n              0xdf4636f3,\n              0xf0794f05,\n              0xbabb5d54,\n              0x65fd6ba7,\n              0x2f3f79f6,\n              0x3b83984b,\n              0x71418a1a,\n              0xae07bce9,\n              0xe4c5aeb8,\n              0xcbfad74e,\n              0x8138c51f,\n              0x5e7ef3ec,\n              0x14bce1bd,\n          },\n\n          {\n              0x0,\n              0x77073096,\n              0xee0e612c,\n              0x990951ba,\n              0x76dc419,\n              0x706af48f,\n              0xe963a535,\n              0x9e6495a3,\n              0xedb8832,\n              0x79dcb8a4,\n              0xe0d5e91e,\n              0x97d2d988,\n              0x9b64c2b,\n              0x7eb17cbd,\n              0xe7b82d07,\n              0x90bf1d91,\n          },\n\n          {\n              0x0,\n              0x1db71064,\n              0x3b6e20c8,\n              0x26d930ac,\n              0x76dc4190,\n              0x6b6b51f4,\n              0x4db26158,\n              0x5005713c,\n              0xedb88320,\n              0xf00f9344,\n              0xd6d6a3e8,\n              0xcb61b38c,\n              0x9b64c2b0,\n              0x86d3d2d4,\n              0xa00ae278,\n              0xbdbdf21c,\n          },\n      };\n\n      const int num_nibbles_parallel = 64;\n\n      const int num_sections = accessor_isz / (num_nibbles_parallel /\n                                               2);  // how many loop iterations\n      unsigned int result = ~0;\n\n      for (int i = 0; i < num_sections; i++) {\n        unsigned int result_update_odd = 0;\n        unsigned int result_update_even = 0;\n// which 4 bit chunk within the section -- this loop can be unrolled, the\n// total update for the crc is the xor of the updates from the nibbles\n        #pragma unroll\n        for (int nib = 0; nib < num_nibbles_parallel; nib++) {\n          unsigned char this_input_nibble =\n              (acc_pibuf[(i * num_nibbles_parallel + nib) / 2] >>\n               (4 * (nib % 2)));\n          unsigned char this_result_nibble =\n              (nib < 8) ? (result >> (4 * nib)) : 0;\n          unsigned char this_table_index =\n              this_input_nibble ^ this_result_nibble;\n          if (nib % 2) {\n            result_update_odd ^= table64[nib][this_table_index & 0xf];\n          } else {\n            result_update_even ^= table64[nib][this_table_index & 0xf];\n          }\n        }\n        result = result_update_odd ^ result_update_even;\n      }\n\n      accresult_crc[0] = ~result;\n    });\n  });\n\n  e_lz[buffer_index] = q.submit([&](handler &h) {\n    auto accessor_isz = block_size;\n    auto acc_pibuf = pibuf->get_access<access::mode::read>(h);\n\n    h.single_task<LZReduction<engineID>>([=]() [[intel::kernel_args_restrict]] {\n      //-------------------------------------\n      //   Hash Table(s)\n      //-------------------------------------\n\n      [[intel::singlepump]] [[intel::numbanks(kVec)]] [\n          [intel::max_replicates(kVec)]] struct {\n        unsigned char s[kLen];\n      } dictionary[kDepth][kVec];\n\n      [[intel::singlepump]] [[intel::numbanks(kVec)]] [\n          [intel::max_replicates(\n              kVec)]] unsigned int dict_offset[kDepth][kVec];\n\n      // Initialize history to empty.\n      for (int i = 0; i < kDepth; i++) {\n        Unroller<0, kVec>::step([&](int k) { dict_offset[i][k] = 0; });\n      }\n\n      // This is the window of data on which we look for matches\n      // We fetch twice our data size because we have kVec offsets\n      unsigned char current_window[kVecX2];\n\n      // This is the window of data on which we look for matches\n      // We fetch twice our data size because we have kVec offsets\n      unsigned char compare_window[kLen][kVec][kVec];\n      // kVec bytes per dict----------|    |   |\n      // kVec dictionaries-----------------|   |\n      // one for each curr win offset---------|\n\n      // load offset into these arrays\n      unsigned int compare_offset[kVec][kVec];\n      // one per kVec bytes----------|     |\n      // one for each compwin-------------|\n\n      // Initialize input stream position\n      unsigned int inpos_minus_vec_div_16 = 0;\n\n      // this is ceiling of (insize-kVec)/16, original comparison was\n      // inpos < insize, now inpos is carried as (inpos-kVec)/16 so this is what\n      // we compare to\n      unsigned int insize_compare = (accessor_isz) / kVec;\n\n      int ctr = insize_compare - 1;\n\n      char first_valid_pos = 0;\n\n      struct DistLen dist_offs_data;\n\n      size_t inpos = 0;\n\n      // load in new data\n      struct LzInput in;\n      Unroller<0, kVec>::step([&](int i) { in.data[i] = acc_pibuf[inpos++]; });\n      Unroller<0, kVec>::step([&](int i) {\n        current_window[i + kVec] = in.data[i];\n      });\n\n      do {\n        //-----------------------------\n        // Prepare current window\n        //-----------------------------\n\n        // shift current window\n        Unroller<0, kVec>::step(\n            [&](int i) { current_window[i] = current_window[i + kVec]; });\n\n        // load in new data\n        Unroller<0, kVec>::step(\n            [&](int i) { in.data[i] = acc_pibuf[inpos++]; });\n\n        Unroller<0, kVec>::step(\n            [&](int i) { current_window[kVec + i] = in.data[i]; });\n\n        //-----------------------------\n        // Compute hash\n        //-----------------------------\n\n        unsigned short hash[kVec];\n\n        Unroller<0, kVec>::step([&](int i) {\n          hash[i] = (current_window[i] ^ (current_window[i + 1] << 6) ^\n                     (current_window[i + 2] << 2) ^ current_window[i + 3]) &\n                    kHashMask;\n        });\n\n        //-----------------------------\n        // Dictionary look-up\n        //-----------------------------\n\n        // loop over kVec compare windows, each has a different hash\n        Unroller<0, kVec>::step([&](int i) {\n          // loop over all kVec bytes\n          Unroller<0, kLen>::step([&](int j) {\n            Unroller<0, kVec>::step([&](int k) {\n              compare_window[k][j][i] = dictionary[hash[i]][j].s[k];\n            });\n          });\n        });\n\n        // loop over compare windows\n        Unroller<0, kVec>::step([&](int i) {\n          Unroller<0, kLen>::step([&](int j) {\n            // loop over frames in this compare window\n            // (they come from different dictionaries)\n            compare_offset[j][i] = dict_offset[hash[i]][j];\n          });\n        });\n\n        //-----------------------------\n        // Dictionary update\n        //-----------------------------\n\n        // loop over different dictionaries to store different frames\n        // store one frame per dictionary\n        // loop over kVec bytes to store\n        Unroller<0, kLen>::step([&](int i) {\n          Unroller<0, kVec>::step([&](int j) {\n            // store actual bytes\n            dictionary[hash[i]][i].s[j] = current_window[i + j];\n          });\n        });\n\n        Unroller<0, kVec>::step([&](int i) {\n          // loop over kVec different dictionaries and write one word to each\n          dict_offset[hash[i]][i] =\n              (inpos_minus_vec_div_16 << 4) |\n              i;  // inpos - kVec + 0, we know that inpos - kVec has 0 as the 4\n                  // lower bits so really just concatenate\n        });\n\n        //-----------------------------\n        // Match search\n        //-----------------------------\n\n        // arrays to store length, best length etc..\n        unsigned char length[kVec];\n        bool done[kVec];\n        char best_length[kVec];\n        unsigned int best_offset[kVec];\n\n        // initialize best_length\n        Unroller<0, kVec>::step([&](int i) {\n          best_length[i] = 0;\n          best_offset[i] = 0;\n        });\n\n        // loop over each comparison window frame\n        // one comes from each dictionary\n        Unroller<0, kVec>::step([&](int i) {\n          // initialize length and done\n          Unroller<0, kVec>::step([&](int l) {\n            length[l] = 0;\n            done[l] = 0;\n          });\n\n          // loop over each current window\n          Unroller<0, kVec>::step([&](int j) {\n            // loop over each char in the current window\n            // and corresponding char in comparison window\n            Unroller<0, kLen>::step([&](int k) {\n              bool comp =\n                  current_window[k + j] == compare_window[k][i][j] && !done[j];\n              length[j] += comp;\n              done[j] = !comp;\n            });\n          });\n\n          // Check if this the best length\n          Unroller<0, kVec>::step([&](int m) {\n            bool update_best =\n                (length[m] > best_length[m]) && (compare_offset[i][m] != 0) &&\n                (((inpos_minus_vec_div_16 << kVecPow) | (i & (kVec - 1))) -\n                     (compare_offset[i][m]) <\n                 kMaxDistance);\n\n            unsigned int new_offset =\n                (((inpos_minus_vec_div_16 << kVecPow) | (m & (kVec - 1))) &\n                 0x7ffff) -\n                ((compare_offset[i][m] & 0x7ffff));\n\n            // Reconsider if new_offset is bigger than current offset, might\n            // take more bytes to encode\n            update_best = update_best && (length[m] == best_length[m]) &&\n                                  (new_offset > best_offset[m])\n                              ? false\n                              : update_best;\n\n            best_offset[m] = (update_best ? new_offset : best_offset[m]) &\n                             0x7ffff;  // 19 bits is sufficient\n\n            best_length[m] = (update_best ? length[m] : best_length[m]) &\n                             0x1f;  // 5 bits is sufficient\n          });\n        });\n\n        //-----------------------------\n        // Filter matches step 1\n        //-----------------------------\n\n        // remove matches with offsets that are <= 0: this means they're\n        // self-matching or didn't match and keep only the matches that, when\n        // encoded, take fewer bytes than the actual match length\n        Unroller<0, kVec>::step([&](int i) {\n          best_length[i] = (((best_length[i] & 0x1f) >= 3) &&\n                                    ((best_offset[i]) < kMaxDistance)\n                                ? best_length[i]\n                                : 0) &\n                           0x1f;  // 5 bits is sufficient\n\n          // Second level filter - remove matches with len 3, greater than\n          // kTooFar\n          best_length[i] =\n              (((best_length[i] & 0x1f) == 3) && ((best_offset[i]) > kTooFar)\n                   ? 0\n                   : best_length[i]) &\n              0x1f;  // 5 bits is sufficient\n                     // don't emmit matches for last iteration as some of the\n                     // second part of the window might be undefined\n          if (ctr == 0) best_length[i] = 0;\n        });\n\n        //-----------------------------\n        // Assign first_valid_pos\n        //-----------------------------\n\n        // first_valid_pos is loop-carried, and tricky to compute.  So first\n        // compute it speculatively in parallel for every possible value of the\n        // previous first_valid_pos.\n        char first_valid_pos_speculative[kVec];\n\n        Unroller<0, kVec>::step([&](int guess) {\n          unsigned char next_match_search = guess;\n          Unroller<0, kVec>::step([&](int i) {\n            unsigned int len = best_length[i];\n\n            // Skip to the next match\n            next_match_search =\n                i >= next_match_search && len > 0 ? i + len : next_match_search;\n          });\n\n          first_valid_pos_speculative[guess] =\n              next_match_search - kVec > 0 ? next_match_search - kVec : 0;\n        });\n\n        // For kVec=16 (the largest currently supported), this should be a 16:1\n        // mux, which is 2 6LUTs deep.  For larger kVec, it will be worse.\n        unsigned char current_valid_pos = first_valid_pos;\n        first_valid_pos =\n            first_valid_pos_speculative[first_valid_pos & (kVec - 1)] &\n            (kVec -\n             1);  // first_valid_pos only needs 4 bits, make this explicit\n\n        // greedy match selection\n        Unroller<0, (kVec)>::step([&](int i) {\n          unsigned int len = best_length[i];\n          best_length[i] = i < current_valid_pos ? -1 : best_length[i];\n          // Skip to the next match\n          current_valid_pos =\n              i >= current_valid_pos && len > 0 ? i + len : current_valid_pos;\n        });\n\n        //-----------------------------\n        // Setup LZ dist/len pairs to push to Huffman encode kernel\n        //-----------------------------\n\n        Unroller<0, kVec>::step([&](int i) {\n          dist_offs_data.data[i] = 0;\n          dist_offs_data.len[i] = -1;\n          dist_offs_data.dist[i] = -1;\n          if (best_length[i] >= 0) {\n            dist_offs_data.data[i] = current_window[i];\n            dist_offs_data.len[i] = best_length[i];\n            dist_offs_data.dist[i] = best_offset[i];\n          }\n        });\n\n        acc_dist_channel::write(dist_offs_data);\n\n        // increment input position\n        inpos_minus_vec_div_16++;\n        ctr--;\n\n      } while (ctr >= 0);\n\n      const char lasti = accessor_isz - (accessor_isz & ~(kVec - 1));\n      const char firstpos = first_valid_pos;\n      Unroller<0, kVec>::step([&](unsigned char i) {\n        dist_offs_data.data[i] = 0;\n        dist_offs_data.len[i] = -1;\n        dist_offs_data.dist[i] = -1;\n      });\n\n      Unroller<0, kVec>::step([&](unsigned char i) {\n        bool pred =\n            ((i - firstpos) < (lasti - firstpos)) && ((i - firstpos) >= 0);\n        dist_offs_data.data[i] = pred ? current_window[i + kVec] : 0;\n        dist_offs_data.len[i] = pred ? 0 : -1;\n      });\n\n      acc_dist_channel_last::write(dist_offs_data);\n    });\n  });\n\n  e_huff[buffer_index] = q.submit([&](handler &h) {\n    auto accessor_isz = block_size;\n    auto acc_gzip_out =\n        gzip_out_buf->get_access<access::mode::discard_write>(h);\n    auto accessor_output = pobuf->get_access<access::mode::discard_write>(h);\n    auto acc_eof = last_block ? 1 : 0;\n    h.single_task<StaticHuffman<engineID>>([=\n    ]() [[intel::kernel_args_restrict]] {\n      unsigned int leftover[kVec] = {0};\n      Unroller<0, kVec>::step([&](int i) { leftover[i] = 0; });\n\n      unsigned short leftover_size = 0;\n\n      unsigned int outpos_huffman = 0;\n\n      int ctr = ((accessor_isz) / kVec) + 2;\n      int odx = 0;\n\n      // Add the gzip start block marker. Assumes static huffman trees.\n      leftover_size = 3;\n      leftover[0] = ((kStaticTrees << 1) + (acc_eof));\n\n      do {\n        struct DistLen in;\n        // init the input structure for the gzip end block marker.\n        // this is the very last data block to be encoded and written.\n        Unroller<0, kVec>::step([&](int i) {\n          in.len[i] = -1;\n          in.dist[i] = -1;\n          in.data[i] = 0;\n        });\n        in.len[0] = ctr == 1 ? -3 : -1;\n        in.data[0] = 0;\n\n        in = ctr > 2 ? acc_dist_channel::read()\n                     : (ctr == 2 ? acc_dist_channel_last::read() : in);\n\n        struct HuffmanOutput outdata;\n        outdata.write = HufEnc(in.len, in.dist, in.data, outdata.data, leftover,\n                               &leftover_size);\n\n        // prevent out of bounds write\n        if (((ctr == 0) || outdata.write) && (odx < accessor_isz)) {\n          Unroller<0, kVec * sizeof(unsigned int)>::step([&](int i) {\n            accessor_output[odx + i] =\n                (ctr == 0) ? (unsigned char)(leftover[(i >> 2) & 0xf] >>\n                                             ((i & 3) << 3))\n                           : (unsigned char)(outdata.data[(i >> 2) & 0xf] >>\n                                             ((i & 3) << 3));\n          });\n        }\n\n        outpos_huffman = outdata.write ? outpos_huffman + 1 : outpos_huffman;\n        odx += outdata.write ? (sizeof(unsigned int) << kVecPow) : 0;\n\n      } while (ctr--);\n\n      // Store summary values from lz and huffman\n      acc_gzip_out[0].compression_sz =\n          (outpos_huffman * sizeof(unsigned int) * kVec) +\n          (leftover_size + 7) / 8;\n    });\n  });\n}\n\nvoid SubmitGzipTasks(queue &q,\n                     size_t block_size,  // size of block to compress.\n                     buffer<char, 1> *pibuf, buffer<char, 1> *pobuf,\n                     buffer<struct GzipOutInfo, 1> *gzip_out_buf,\n                     buffer<unsigned, 1> *result_crc, bool last_block,\n                     std::vector<event> &e_crc, std::vector<event> &e_lz, std::vector<event> &e_huff,\n                     size_t engineID, int buffer_index) {\n  // Statically declare the engines so that the hardware is created for them.\n  // But at run time, the host can dynamically select which engine(s) to use via\n  // engineID.\n  if (engineID == 0) {\n    SubmitGzipTasksSingleEngine<0>(q, block_size, pibuf, pobuf, gzip_out_buf,\n                                   result_crc, last_block, e_crc, e_lz, e_huff, buffer_index);\n  }\n\n  #if NUM_ENGINES > 1\n    if (engineID == 1) {\n      SubmitGzipTasksSingleEngine<1>(q, block_size, pibuf, pobuf, gzip_out_buf,\n                                     result_crc, last_block, e_crc, e_lz, e_huff, buffer_index);\n    }\n  #endif\n\n  // If this reference design is to be expanded to > 2 engines, declare them here.\n\n}\n"
    },
    {
        "label": "gzipkernel.hpp",
        "data": "#ifndef __GZIPKERNEL_H__\n#define __GZIPKERNEL_H__\n#pragma once\n\n#include <sycl/sycl.hpp>\n\nusing namespace sycl;\n\nextern \"C\" void SubmitGzipTasks(\n    queue &sycl_device,\n    size_t block_size,  // size of block to compress.\n    buffer<char, 1> *pibuf, buffer<char, 1> *pobuf,\n    buffer<struct GzipOutInfo, 1> *gzip_out_buf,\n    buffer<unsigned, 1> *current_crc, bool last_block, std::vector<event> &e_crc,\n    std::vector<event> &e_lz, std::vector<event> &e_huff, size_t engineID, int buffer_index);\n\n#endif  //__GZIPKERNEL_H__\n"
    },
    {
        "label": "crc32.cpp",
        "data": "#include \"crc32.hpp\"\n\n// This table is CRC32s for all single byte values created by using the\n// makecrc.c utility from gzip for compatibility with gzip. makecrc.c can be\n// found in the gzip source code project found at\n// https://git.savannah.gnu.org/git/gzip.git. The polynomial 0xedb88320 is used\n// for gzip, and thus used to create this table.\n//\n// Not copyrighted 1990, Mark Adler.\n//\nconst unsigned int crc32_table[] = {\n    0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,\n    0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,\n    0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,\n    0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,\n    0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,\n    0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,\n    0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,\n    0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,\n    0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,\n    0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,\n    0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,\n    0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,\n    0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,\n    0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,\n    0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,\n    0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,\n    0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,\n    0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,\n    0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,\n    0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,\n    0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,\n    0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,\n    0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,\n    0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,\n    0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,\n    0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,\n    0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,\n    0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,\n    0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,\n    0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,\n    0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,\n    0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,\n    0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,\n    0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,\n    0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,\n    0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,\n    0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,\n    0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,\n    0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,\n    0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,\n    0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,\n    0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,\n    0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,\n    0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,\n    0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,\n    0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,\n    0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,\n    0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,\n    0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,\n    0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,\n    0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,\n    0x2d02ef8dL};\n\n//\n// This routine creates a Crc32 from a memory buffer (address, and length), and\n// a previous crc. This routine can be called iteratively on different portions\n// of the same buffer, using a previously returned crc value. The\n// value 0xffffffff is used for the first buffer invocation.\nunsigned int Crc32Host(\n    const char *pbuf,           // pointer to the buffer to crc\n    size_t sz,                  // number of bytes\n    unsigned int previous_crc)  // previous CRC, allows combining.\n{\n  unsigned int curr_crc = ~previous_crc;\n  if (sz) do {\n      curr_crc =\n          crc32_table[((int)curr_crc ^ (*pbuf++)) & 0xff] ^ (curr_crc >> 8);\n    } while (--sz);\n  return curr_crc ^ 0xffffffffL;\n}\n\nunsigned int Crc32(const char *in, size_t buffer_sz,\n                   unsigned int previous_crc) {\n  const int num_nibbles_parallel = 64;\n  const int num_sections =\n      buffer_sz / (num_nibbles_parallel / 2);  // how many loop iterations\n  // now deal with the remainder, this should be done on the software host\n  // the post-invert also happens inside crc_reference\n  const char *remaining_data = &in[num_sections * (num_nibbles_parallel / 2)];\n  int remaining_bytes = buffer_sz % (num_nibbles_parallel / 2);\n  return Crc32Host(remaining_data, remaining_bytes, previous_crc);\n}\n"
    },
    {
        "label": "crc32.hpp",
        "data": "#ifndef __CRC32_H__\n#define __CRC32_H__\n#pragma once\n\n#include <stdint.h>\n#include <stdlib.h>\n\nuint32_t Crc32Host(\n    const char *pbuf,        // pointer to the buffer to crc\n    size_t sz,               // number of bytes\n    uint32_t previous_crc);  // previous CRC, allows combining. First invocation\n                             // would use 0xffffffff.\nuint32_t Crc32(const char *pbuf,        // pointer to the buffer to crc\n               size_t sz,               // number of bytes\n               uint32_t previous_crc);  // previous CRC, allows combining. First\n                                        // invocation would use 0xffffffff.\n\n#endif  //__CRC32_H__\n"
    },
    {
        "label": "gzip.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <chrono>\n#include <fstream>\n#include <string>\n\n#include \"CompareGzip.hpp\"\n#include \"WriteGzip.hpp\"\n#include \"crc32.hpp\"\n#include \"gzipkernel.hpp\"\n#include \"kernels.hpp\"\n\n#include \"exception_handler.hpp\"\n\n\nusing namespace sycl;\n\n// The minimum file size of a file to be compressed.\n// Any filesize less than this results in an error.\nconstexpr int minimum_filesize = kVec + 1;\n\nbool help = false;\n\nint CompressFile(queue &q, std::string &input_file, std::vector<std::string> outfilenames,\n                 int iterations, bool report);\n\nvoid Help(void) {\n  // Command line arguments.\n  // gzip [options] filetozip [options]\n  // -h,--help                    : help\n\n  // future options?\n  // -p,performance : output perf metrics\n  // -m,maxmapping=#  : maximum mapping size\n\n  std::cout << \"gzip filename [options]\\n\";\n  std::cout << \"  -h,--help                                : this help text\\n\";\n  std::cout\n      << \"  -o=<filename>,--output-file=<filename>   : specify output file\\n\";\n}\n\nbool FindGetArg(std::string &arg, const char *str, int defaultval, int *val) {\n  std::size_t found = arg.find(str, 0, strlen(str));\n  if (found != std::string::npos) {\n    int value = atoi(&arg.c_str()[strlen(str)]);\n    *val = value;\n    return true;\n  }\n  return false;\n}\n\nconstexpr int kMaxStringLen = 40;\n\nbool FindGetArgString(std::string &arg, const char *str, char *str_value,\n                      size_t maxchars) {\n  std::size_t found = arg.find(str, 0, strlen(str));\n  if (found != std::string::npos) {\n    const char *sptr = &arg.c_str()[strlen(str)];\n    for (int i = 0; i < maxchars - 1; i++) {\n      char ch = sptr[i];\n      switch (ch) {\n        case ' ':\n        case '\\t':\n        case '\\0':\n          str_value[i] = 0;\n          return true;\n          break;\n        default:\n          str_value[i] = ch;\n          break;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nsize_t SyclGetExecTimeNs(event e) {\n  size_t start_time =\n      e.get_profiling_info<info::event_profiling::command_start>();\n  size_t end_time =\n      e.get_profiling_info<info::event_profiling::command_end>();\n  return (end_time - start_time);\n}\n\nint main(int argc, char *argv[]) {\n  std::string infilename = \"\";\n\n  std::vector<std::string> outfilenames (kNumEngines);\n\n  char str_buffer[kMaxStringLen] = {0};\n\n  // Check the number of arguments specified\n  if (argc != 3) {\n    std::cerr << \"Incorrect number of arguments. Correct usage: \" << argv[0]\n              << \" <input-file> -o=<output-file>\\n\";\n    return 1;\n  }\n\n  for (int i = 1; i < argc; i++) {\n    if (argv[i][0] == '-') {\n      std::string sarg(argv[i]);\n      if (std::string(argv[i]) == \"-h\") {\n        help = true;\n      }\n      if (std::string(argv[i]) == \"--help\") {\n        help = true;\n      }\n\n      FindGetArgString(sarg, \"-o=\", str_buffer, kMaxStringLen);\n      FindGetArgString(sarg, \"--output-file=\", str_buffer, kMaxStringLen);\n    } else {\n      infilename = std::string(argv[i]);\n    }\n  }\n\n  if (help) {\n    Help();\n    return 1;\n  }\n\n  try {\n\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    auto prop_list = property_list{property::queue::enable_profiling()};\n    queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<info::device::name>().c_str() \n              << std::endl;\n\n    if (infilename == \"\") {\n      std::cout << \"Must specify a filename to compress\\n\\n\";\n      Help();\n      return 1;\n    }\n\n    // next, check valid and acceptable parameter ranges.\n    // if output filename not set, use the default\n    // name, else use the name specified by the user\n    outfilenames[0] = std::string(infilename) + \".gz\";\n    if (strlen(str_buffer)) {\n      outfilenames[0] = std::string(str_buffer);\n    }\n    for (size_t i=1; i< kNumEngines; i++) {\n      // Filenames will be of the form outfilename, outfilename2, outfilename3 etc.\n      outfilenames[i] = outfilenames[0] + std::to_string(i+1);\n    }\n\n    std::cout << \"Launching High-Bandwidth DMA GZIP application with \" << kNumEngines\n              << \" engines\\n\";\n\n#ifdef FPGA_EMULATOR\n    CompressFile(q, infilename, outfilenames, 1, true);\n#elif FPGA_SIMULATOR\n    CompressFile(q, infilename, outfilenames, 2, true);\n#else\n    // warmup run - use this run to warmup accelerator. There are some steps in\n    // the runtime that are only executed on the first kernel invocation but not\n    // on subsequent invocations. So execute all that stuff here before we\n    // measure performance (in the next call to CompressFile().\n    CompressFile(q, infilename, outfilenames, 1, false);\n    // profile performance\n    CompressFile(q, infilename, outfilenames, 200, true);\n#endif\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n      std::cerr << \"If you are targeting the FPGA simulator, compile with \"\n                   \"-DFPGA_SIMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n  return 0;\n}\n\nstruct KernelInfo {\n  buffer<struct GzipOutInfo, 1> *gzip_out_buf;\n  buffer<unsigned, 1> *current_crc;\n  buffer<char, 1> *pobuf;\n  buffer<char, 1> *pibuf;\n\n  uint32_t buffer_crc[kMinBufferSize];\n  uint32_t refcrc;\n\n  const char *pref_buffer;\n  char *poutput_buffer;\n  size_t file_size;\n  struct GzipOutInfo out_info[kMinBufferSize];\n  int iteration;\n  bool last_block;\n};\n\n// returns 0 on success, otherwise a non-zero failure code.\nint CompressFile(queue &q, std::string &input_file, std::vector<std::string> outfilenames,\n                 int iterations, bool report) {\n  size_t isz;\n  char *pinbuf;\n\n  // Read the input file\n  std::string device_string =\n      q.get_device().get_info<info::device::name>().c_str();\n\n  // If the device is supports USM allocations, we pre-pin some buffers to\n  // improve DMA performance, which is needed to\n  // achieve peak kernel throughput. Pre-pinning is\n  // only supported on the USM capable BSPs. It's not\n  // needed on non-USM capabale BSPs to achieve peak performance.\n#ifdef FPGA_SIMULATOR\n  bool prepin = false;\n#else\n  bool prepin = q.get_device().has(aspect::usm_host_allocations);\n#endif\n\n  // padding for the input and output buffers to deal with granularity of\n  // kernel reads and writes\n  constexpr size_t kInOutPadding = 16 * kVec;\n  \n  std::ifstream file(input_file,\n                     std::ios::in | std::ios::binary | std::ios::ate);\n  if (file.is_open()) {\n    isz = file.tellg();\n    if (prepin) {\n      pinbuf = (char *)malloc_host(\n          isz + kInOutPadding, q.get_context());  // Pre-pin the buffer, for faster DMA\n    } else {                      // throughput, using malloc_host().\n      pinbuf = new char[isz + kInOutPadding];\n    }\n    file.seekg(0, std::ios::beg);\n    file.read(pinbuf, isz);\n    file.close();\n  } else {\n    std::cout << \"Error: cannot read specified input file\\n\";\n    return 1;\n  }\n\n  if (isz < minimum_filesize) {\n    std::cout << \"Minimum filesize for compression is \" << minimum_filesize\n              << \"\\n\";\n    return 1;\n  }\n\n  int buffers_count = iterations;\n\n  // Create an array of kernel info structures and create buffers for kernel\n  // input/output. The buffers are re-used between iterations, but enough \n  // disjoint buffers are created to support double-buffering.\n  struct KernelInfo *kinfo[kNumEngines];\n  for (size_t eng = 0; eng < kNumEngines; eng++) {\n    kinfo[eng] =\n        (struct KernelInfo *)malloc(sizeof(struct KernelInfo) * buffers_count);\n    if (kinfo[eng] == NULL) {\n      std::cout << \"Cannot allocate kernel info buffer.\\n\";\n      return 1;\n    }\n    for (int i = 0; i < buffers_count; i++) {\n      kinfo[eng][i].file_size = isz;\n      // Allocating slightly larger buffers (+ 16 * kVec) to account for\n      // granularity of kernel writes\n      int outputSize =\n          ((isz + kInOutPadding) < kMinBufferSize) ? kMinBufferSize\n                                                   : (isz + kInOutPadding);\n      const size_t input_alloc_size = isz + kInOutPadding;\n\n      // Pre-pin buffer using malloc_host() to improve DMA bandwidth.\n      if (i >= 3) {\n        kinfo[eng][i].poutput_buffer = kinfo[eng][i - 3].poutput_buffer;\n      } else {\n        if (prepin) {\n          kinfo[eng][i].poutput_buffer =\n              (char *)malloc_host(outputSize, q.get_context());\n        } else {\n          kinfo[eng][i].poutput_buffer = (char *)malloc(outputSize);\n        }\n\n        std::cout << \"outputSize: \" << outputSize << \" Prepin: \"\n                << prepin << \"\\n\";\n        std::cout << \"kMinBufferSize: \" << kMinBufferSize << \" isz: \" << isz \n                << \" kInOutPadding: \" << kInOutPadding << \"\\n\";\n        if (kinfo[eng][i].poutput_buffer == NULL) {\n          std::cout << \"Cannot allocate output buffer.\\n\";\n          free(kinfo[eng]);\n          return 1;\n        }\n        // zero pages to fully allocate them\n        memset(kinfo[eng][i].poutput_buffer, 0, outputSize);\n      }\n\n      kinfo[eng][i].last_block = true;\n      kinfo[eng][i].iteration = i;\n      kinfo[eng][i].pref_buffer = pinbuf;\n\n      kinfo[eng][i].gzip_out_buf =\n          i >= 3 ? kinfo[eng][i - 3].gzip_out_buf\n                 : new buffer<struct GzipOutInfo, 1>(kMinBufferSize);\n      kinfo[eng][i].current_crc = i >= 3\n                                      ? kinfo[eng][i - 3].current_crc\n                                      : new buffer<unsigned, 1>(kMinBufferSize);\n      kinfo[eng][i].pibuf = i >= 3\n                                ? kinfo[eng][i - 3].pibuf\n                                : new buffer<char, 1>(input_alloc_size);\n      kinfo[eng][i].pobuf =\n          i >= 3 ? kinfo[eng][i - 3].pobuf : new buffer<char, 1>(outputSize);\n    }\n  }\n\n  // Create events for the various parts of the execution so that we can profile\n  // their performance.\n  std::vector<event> e_input_dma     [kNumEngines]; // Input to the GZIP engine. This is a transfer from host to device.\n  std::vector<event> e_output_dma    [kNumEngines]; // Output from the GZIP engine. This is transfer from device to host.\n  std::vector<event> e_crc_dma       [kNumEngines]; // Transfer CRC from device to host\n  std::vector<event> e_size_dma      [kNumEngines]; // Transfer compressed file size from device to host\n  std::vector<event> e_k_crc         [kNumEngines]; // CRC kernel\n  std::vector<event> e_k_lz          [kNumEngines]; // LZ77 kernel\n  std::vector<event> e_k_huff        [kNumEngines]; // Huffman Encoding kernel\n\n  for (int i = 0; i < kNumEngines; i++) {\n    e_input_dma[i].resize(buffers_count);\n    e_output_dma[i].resize(buffers_count);\n    e_crc_dma[i].resize(buffers_count);\n    e_size_dma[i].resize(buffers_count);\n    e_k_crc[i].resize(buffers_count);\n    e_k_lz[i].resize(buffers_count);\n    e_k_huff[i].resize(buffers_count);\n  }\n\n\n#ifdef FPGA_EMULATOR\n#elif FPGA_SIMULATOR\n#else\n  auto start = std::chrono::steady_clock::now();\n#endif\n\n  \n  /*************************************************/\n  /* Main loop where the actual execution happens  */\n  /*************************************************/\n  for (int i = 0; i < buffers_count; i++) {\n    for (size_t eng = 0; eng < kNumEngines; eng++) {\n      // Transfer the input data, to be compressed, from host to device.\n      e_input_dma[eng][i] = q.submit([&](handler &h) {\n        auto in_data =\n            kinfo[eng][i].pibuf->get_access<access::mode::discard_write>(h);\n        h.copy(kinfo[eng][i].pref_buffer, in_data);\n      });\n\n      /************************************/\n      /************************************/\n      /*         LAUNCH GZIP ENGINE       */\n      /************************************/\n      /************************************/\n      SubmitGzipTasks(q, kinfo[eng][i].file_size, kinfo[eng][i].pibuf,\n                      kinfo[eng][i].pobuf, kinfo[eng][i].gzip_out_buf,\n                      kinfo[eng][i].current_crc, kinfo[eng][i].last_block,\n                      e_k_crc[eng], e_k_lz[eng], e_k_huff[eng], eng, i);\n\n      // Transfer the output (compressed) data from device to host.\n      e_output_dma[eng][i] = q.submit([&](handler &h) {\n        auto out_data = kinfo[eng][i].pobuf->get_access<access::mode::read>(h);\n        h.copy(out_data, kinfo[eng][i].poutput_buffer);\n      });\n\n      // Transfer the file size of the compressed output file from device to host.\n      e_size_dma[eng][i] = q.submit([&](handler &h) {\n        auto out_data =\n            kinfo[eng][i].gzip_out_buf->get_access<access::mode::read>(h);\n        h.copy(out_data, kinfo[eng][i].out_info);\n      });\n\n      // Transfer the CRC of the compressed output file from device to host.\n      e_crc_dma[eng][i] = q.submit([&](handler &h) {\n        auto out_data =\n            kinfo[eng][i].current_crc->get_access<access::mode::read>(h);\n        h.copy(out_data, kinfo[eng][i].buffer_crc);\n      });\n    }\n  }\n\n  // Wait for all kernels to complete\n  for (int eng = 0; eng < kNumEngines; eng++) {\n    for (int i = 0; i < buffers_count; i++) {\n      e_output_dma[eng][i].wait();\n      e_size_dma[eng][i].wait();\n      e_crc_dma[eng][i].wait();\n    }\n  }\n\n// Stop the timer.\n#ifdef FPGA_EMULATOR\n#elif FPGA_SIMULATOR\n#else\n  auto end = std::chrono::steady_clock::now();\n  double diff_total = std::chrono::duration_cast<std::chrono::duration<double>>(end - start).count();\n  double gbps = iterations * isz / (double)diff_total / 1000000000.0;\n#endif\n\n  // Check the compressed file size from each iteration. Make sure the size is actually\n  // less-than-or-equal to the input size. Also calculate the remaining CRC.\n  size_t compressed_sz[kNumEngines];\n  for (int eng = 0; eng < kNumEngines; eng++) {\n    compressed_sz[eng] = 0;\n    for (int i = 0; i < buffers_count; i++) {\n      if (kinfo[eng][i].out_info[0].compression_sz > kinfo[eng][i].file_size) {\n        std::cerr << \"Unsupported: compressed file larger than input file( \"\n                  << kinfo[eng][i].out_info[0].compression_sz << \" )\\n\";\n        return 1;\n      }\n      // The majority of the CRC is calculated by the CRC kernel on the FPGA. But the kernel\n      // operates on quantized chunks of input data, so any remaining input data, that falls\n      // outside the quanta, is included in the overall CRC calculation via the following \n      // function that runs on the host. The last argument is the running CRC that was computed\n      // on the FPGA.\n      kinfo[eng][i].buffer_crc[0] =\n          Crc32(kinfo[eng][i].pref_buffer, kinfo[eng][i].file_size,\n                kinfo[eng][i].buffer_crc[0]);\n      // Accumulate the compressed size across all iterations. Used to \n      // compute compression ratio later.\n      compressed_sz[eng] += kinfo[eng][i].out_info[0].compression_sz;\n    }\n  }\n\n  // delete the file mapping now that all kernels are complete, and we've\n  // snapped the time delta\n  if (prepin) {\n    free(pinbuf, q.get_context());\n  } else {\n    delete pinbuf;\n  }\n\n  // Write the output compressed data from the first iteration of each engine, to a file.\n  for (int eng = 0; eng < kNumEngines; eng++) {\n    // WriteBlockGzip() returns 1 on failure\n    if (report && WriteBlockGzip(input_file, outfilenames[eng], kinfo[eng][0].poutput_buffer,\n                        kinfo[eng][0].out_info[0].compression_sz,\n                        kinfo[eng][0].file_size, kinfo[eng][0].buffer_crc[0])) {\n      std::cout << \"FAILED\\n\";\n      return 1;\n    }        \n  }\n\n  // Decompress the output from engine-0 and compare against the input file. Only engine-0's\n  // output is verified since all engines are fed the same input data.\n  if (report && CompareGzipFiles(input_file, outfilenames[0])) {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n\n  // Generate throughput report\n  // First gather all the execution times.\n  size_t time_k_crc[kNumEngines];\n  size_t time_k_lz[kNumEngines];\n  size_t time_k_huff[kNumEngines];\n  size_t time_input_dma[kNumEngines];\n  size_t time_output_dma[kNumEngines];\n  for (int eng = 0; eng < kNumEngines; eng++) {\n    time_k_crc[eng] = 0;\n    time_k_lz[eng] = 0;\n    time_k_huff[eng] = 0;\n    time_input_dma[eng] = 0;\n    time_output_dma[eng] = 0;\n    for (int i = 0; i < buffers_count; i++) {\n      e_k_crc[eng][i].wait();\n      e_k_lz[eng][i].wait();\n      e_k_huff[eng][i].wait();\n      time_k_crc[eng]       += SyclGetExecTimeNs(e_k_crc[eng][i]);\n      time_k_lz[eng]        += SyclGetExecTimeNs(e_k_lz[eng][i]);\n      time_k_huff[eng]      += SyclGetExecTimeNs(e_k_huff[eng][i]);\n      time_input_dma[eng]   += SyclGetExecTimeNs(e_input_dma[eng][i]);\n      time_output_dma[eng]  += SyclGetExecTimeNs(e_output_dma[eng][i]);\n    }\n  }\n\n  if (report) {\n    double compression_ratio =\n        (double)((double)compressed_sz[0] / (double)isz / iterations);\n#ifdef FPGA_EMULATOR\n#elif FPGA_SIMULATOR\n#else\n    std::cout << \"Throughput: \" << kNumEngines * gbps << \" GB/s\\n\\n\";\n    for (int eng = 0; eng < kNumEngines; eng++) {\n      std::cout << \"TP breakdown for engine #\" << eng << \" (GB/s)\\n\";\n      std::cout << \"CRC = \" << iterations * isz / (double)time_k_crc[eng]\n                << \"\\n\";\n      std::cout << \"LZ77 = \" << iterations * isz / (double)time_k_lz[eng]\n                << \"\\n\";\n      std::cout << \"Huffman Encoding = \"\n                << iterations * isz / (double)time_k_huff[eng] << \"\\n\";\n      std::cout << \"DMA host-to-device = \"\n                << iterations * isz / (double)time_input_dma[eng] << \"\\n\";\n      std::cout << \"DMA device-to-host = \"\n                << iterations * isz / (double)time_output_dma[eng] << \"\\n\\n\";\n    }\n#endif\n    std::cout << \"Compression Ratio \" << compression_ratio * 100 << \"%\\n\";\n  }\n\n  // Cleanup anything that was allocated by this routine.\n  for (int eng = 0; eng < kNumEngines; eng++) {\n    for (int i = 0; i < buffers_count; i++) {\n      if (i < 3) {\n        delete kinfo[eng][i].gzip_out_buf;\n        delete kinfo[eng][i].current_crc;\n        delete kinfo[eng][i].pibuf;\n        delete kinfo[eng][i].pobuf;\n        if (prepin) {\n          free(kinfo[eng][i].poutput_buffer, q.get_context());\n        } else {\n          free(kinfo[eng][i].poutput_buffer);\n        }\n      }\n    }\n    free(kinfo[eng]);\n  }\n\n  if (report) std::cout << \"PASSED\\n\";\n  return 0;\n}\n"
    },
    {
        "label": "gzipkernel_ll.cpp",
        "data": "/*\n  ** Batching **\n  This is the \"low-latency\" variant of the GZIP reference design. It differs\n  from the \"high-bandwidth\" variant in that it tries to minimize the latency\n  from when the input file is available in host memory to when the compressed\n  result is available in host memory, particulary for small (< 128KB) input\n  files. Universal Shared Memory (USM) is used to reduce latency whereby the\n  kernel directly accesses the input/output buffers, physically located in host\n  memory. This is in contrast to the \"high bandwidth\" variant where SYCL Buffers\n  are DMA'ed to/from the FPGA's attached DDR. USM instead allows for a \"zero\n  copy\" design, which reduces overall latency. It takes some time to relaunch\n  the gzip engine and therefore, in order to maximize system throughput, it's\n  important to feed the gzip engine with enough data to keep it busy while the\n  next launch is being prepared. If done successfully, the kernel relaunch time\n  overlaps with kernel execution and there is very little downtime between\n  kernel invocations. Since this reference design is intended to be used with\n  small files, it's typical that one file is not enough to keep the engine busy.\n  Therefore the concept of \"batching\" is introduced. This simply means that the\n  gzip engine compresses multiple input files, per invocation. The minimum size\n  of the batch should be chosen to cover the relaunch latency and the maximum\n  size should be chosen to result in a desireable overall execution time (i.e. a\n  large batch size may take longer than desired to execute, thereby elongating\n  overall system latency). Determining the proper batch size takes some\n  experimentation.\n\n  The 3 kernels that comprise the gzip engine are separated into separate\n  functions. Each function contains a \"batch loop\" which simply iterates over\n  the kernel code, once per file in the batch. The batch loop has loop\n  pipelining disabled. This is a clear way to communicate to the compiler that\n  files in the batch are independent from each other. This means there's a\n  little bit of ramp-down/up of the batch loop between files. It's possible to\n  pipeline the batch loop to slightly improve performance, at the cost of area\n  (all variables in the loop become privatized and copied).\n\n  The pointers to the buffers in a batch are passed to the kernel via kernel\n  args. By having separate kernel arguments for each pointer we are able to\n  clearly communicate to the compiler that these pointers should be treated as\n  'restrict' (i.e. they will not point to the same place, which is true in this\n  application). An alternative implementation to store an array of pointers in\n  host-memory which the kernel then reads, but this makes it more difficult to\n  communicate that these pointers don't alias.\n*/\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <vector>\n\n#include \"gzipkernel_ll.hpp\"\n#include \"kernels.hpp\"\n#include \"pipe_utils.hpp\" // Included from DirectProgramming/C++SYCL_FPGA/include/\n\n\nusing namespace sycl;\n\n// Pipes, for inter-kernel data transfer..\nusing acc_dist_channel_array =\n  fpga_tools::PipeArray<          // Defined in \"pipe_utils.hpp\".\n    class dist_channel_pipe_id,   // An identifier for the pipe.\n    struct DistLen,               // The type of data in the pipe.\n    32,                           // The capacity of each pipe.\n    NUM_ENGINES                   // array dimension.\n  >;\n\nusing acc_dist_channel_last_array =\n    fpga_tools::PipeArray<\n      class dist_channel_last_pipe_id,\n      struct DistLen,\n      32,\n      NUM_ENGINES\n    >;\n\nusing acc_lz_to_crc_channel_array =\n    fpga_tools::PipeArray<\n      class crc_channel_pipe_id,\n      char_arr_32,\n      32,\n      NUM_ENGINES\n    >;\n\ntemplate <int Begin, int End>\nstruct Unroller {\n  template <typename Action>\n  static void step(const Action &action) {\n    action(std::integral_constant<int, Begin>());\n    Unroller<Begin + 1, End>::step(action);\n  }\n};\n\ntemplate <int End>\nstruct Unroller<End, End> {\n  template <typename Action>\n  static void step(const Action &action) {}\n};\n\nint GetHuffLiteralBits(unsigned char ch) {\n  CtData static_ltree[kLCodes + 2] = {\n      {12, 8},  {140, 8}, {76, 8},  {204, 8}, {44, 8},  {172, 8}, {108, 8},\n      {236, 8}, {28, 8},  {156, 8}, {92, 8},  {220, 8}, {60, 8},  {188, 8},\n      {124, 8}, {252, 8}, {2, 8},   {130, 8}, {66, 8},  {194, 8}, {34, 8},\n      {162, 8}, {98, 8},  {226, 8}, {18, 8},  {146, 8}, {82, 8},  {210, 8},\n      {50, 8},  {178, 8}, {114, 8}, {242, 8}, {10, 8},  {138, 8}, {74, 8},\n      {202, 8}, {42, 8},  {170, 8}, {106, 8}, {234, 8}, {26, 8},  {154, 8},\n      {90, 8},  {218, 8}, {58, 8},  {186, 8}, {122, 8}, {250, 8}, {6, 8},\n      {134, 8}, {70, 8},  {198, 8}, {38, 8},  {166, 8}, {102, 8}, {230, 8},\n      {22, 8},  {150, 8}, {86, 8},  {214, 8}, {54, 8},  {182, 8}, {118, 8},\n      {246, 8}, {14, 8},  {142, 8}, {78, 8},  {206, 8}, {46, 8},  {174, 8},\n      {110, 8}, {238, 8}, {30, 8},  {158, 8}, {94, 8},  {222, 8}, {62, 8},\n      {190, 8}, {126, 8}, {254, 8}, {1, 8},   {129, 8}, {65, 8},  {193, 8},\n      {33, 8},  {161, 8}, {97, 8},  {225, 8}, {17, 8},  {145, 8}, {81, 8},\n      {209, 8}, {49, 8},  {177, 8}, {113, 8}, {241, 8}, {9, 8},   {137, 8},\n      {73, 8},  {201, 8}, {41, 8},  {169, 8}, {105, 8}, {233, 8}, {25, 8},\n      {153, 8}, {89, 8},  {217, 8}, {57, 8},  {185, 8}, {121, 8}, {249, 8},\n      {5, 8},   {133, 8}, {69, 8},  {197, 8}, {37, 8},  {165, 8}, {101, 8},\n      {229, 8}, {21, 8},  {149, 8}, {85, 8},  {213, 8}, {53, 8},  {181, 8},\n      {117, 8}, {245, 8}, {13, 8},  {141, 8}, {77, 8},  {205, 8}, {45, 8},\n      {173, 8}, {109, 8}, {237, 8}, {29, 8},  {157, 8}, {93, 8},  {221, 8},\n      {61, 8},  {189, 8}, {125, 8}, {253, 8}, {19, 9},  {275, 9}, {147, 9},\n      {403, 9}, {83, 9},  {339, 9}, {211, 9}, {467, 9}, {51, 9},  {307, 9},\n      {179, 9}, {435, 9}, {115, 9}, {371, 9}, {243, 9}, {499, 9}, {11, 9},\n      {267, 9}, {139, 9}, {395, 9}, {75, 9},  {331, 9}, {203, 9}, {459, 9},\n      {43, 9},  {299, 9}, {171, 9}, {427, 9}, {107, 9}, {363, 9}, {235, 9},\n      {491, 9}, {27, 9},  {283, 9}, {155, 9}, {411, 9}, {91, 9},  {347, 9},\n      {219, 9}, {475, 9}, {59, 9},  {315, 9}, {187, 9}, {443, 9}, {123, 9},\n      {379, 9}, {251, 9}, {507, 9}, {7, 9},   {263, 9}, {135, 9}, {391, 9},\n      {71, 9},  {327, 9}, {199, 9}, {455, 9}, {39, 9},  {295, 9}, {167, 9},\n      {423, 9}, {103, 9}, {359, 9}, {231, 9}, {487, 9}, {23, 9},  {279, 9},\n      {151, 9}, {407, 9}, {87, 9},  {343, 9}, {215, 9}, {471, 9}, {55, 9},\n      {311, 9}, {183, 9}, {439, 9}, {119, 9}, {375, 9}, {247, 9}, {503, 9},\n      {15, 9},  {271, 9}, {143, 9}, {399, 9}, {79, 9},  {335, 9}, {207, 9},\n      {463, 9}, {47, 9},  {303, 9}, {175, 9}, {431, 9}, {111, 9}, {367, 9},\n      {239, 9}, {495, 9}, {31, 9},  {287, 9}, {159, 9}, {415, 9}, {95, 9},\n      {351, 9}, {223, 9}, {479, 9}, {63, 9},  {319, 9}, {191, 9}, {447, 9},\n      {127, 9}, {383, 9}, {255, 9}, {511, 9}, {0, 7},   {64, 7},  {32, 7},\n      {96, 7},  {16, 7},  {80, 7},  {48, 7},  {112, 7}, {8, 7},   {72, 7},\n      {40, 7},  {104, 7}, {24, 7},  {88, 7},  {56, 7},  {120, 7}, {4, 7},\n      {68, 7},  {36, 7},  {100, 7}, {20, 7},  {84, 7},  {52, 7},  {116, 7},\n      {3, 8},   {131, 8}, {67, 8},  {195, 8}, {35, 8},  {163, 8}, {99, 8},\n      {227, 8},\n  };\n  return static_ltree[ch].code;\n}\n\nint GetHuffLiteralLen(unsigned char ch) {\n  CtData static_ltree[kLCodes + 2] = {\n      {12, 8},  {140, 8}, {76, 8},  {204, 8}, {44, 8},  {172, 8}, {108, 8},\n      {236, 8}, {28, 8},  {156, 8}, {92, 8},  {220, 8}, {60, 8},  {188, 8},\n      {124, 8}, {252, 8}, {2, 8},   {130, 8}, {66, 8},  {194, 8}, {34, 8},\n      {162, 8}, {98, 8},  {226, 8}, {18, 8},  {146, 8}, {82, 8},  {210, 8},\n      {50, 8},  {178, 8}, {114, 8}, {242, 8}, {10, 8},  {138, 8}, {74, 8},\n      {202, 8}, {42, 8},  {170, 8}, {106, 8}, {234, 8}, {26, 8},  {154, 8},\n      {90, 8},  {218, 8}, {58, 8},  {186, 8}, {122, 8}, {250, 8}, {6, 8},\n      {134, 8}, {70, 8},  {198, 8}, {38, 8},  {166, 8}, {102, 8}, {230, 8},\n      {22, 8},  {150, 8}, {86, 8},  {214, 8}, {54, 8},  {182, 8}, {118, 8},\n      {246, 8}, {14, 8},  {142, 8}, {78, 8},  {206, 8}, {46, 8},  {174, 8},\n      {110, 8}, {238, 8}, {30, 8},  {158, 8}, {94, 8},  {222, 8}, {62, 8},\n      {190, 8}, {126, 8}, {254, 8}, {1, 8},   {129, 8}, {65, 8},  {193, 8},\n      {33, 8},  {161, 8}, {97, 8},  {225, 8}, {17, 8},  {145, 8}, {81, 8},\n      {209, 8}, {49, 8},  {177, 8}, {113, 8}, {241, 8}, {9, 8},   {137, 8},\n      {73, 8},  {201, 8}, {41, 8},  {169, 8}, {105, 8}, {233, 8}, {25, 8},\n      {153, 8}, {89, 8},  {217, 8}, {57, 8},  {185, 8}, {121, 8}, {249, 8},\n      {5, 8},   {133, 8}, {69, 8},  {197, 8}, {37, 8},  {165, 8}, {101, 8},\n      {229, 8}, {21, 8},  {149, 8}, {85, 8},  {213, 8}, {53, 8},  {181, 8},\n      {117, 8}, {245, 8}, {13, 8},  {141, 8}, {77, 8},  {205, 8}, {45, 8},\n      {173, 8}, {109, 8}, {237, 8}, {29, 8},  {157, 8}, {93, 8},  {221, 8},\n      {61, 8},  {189, 8}, {125, 8}, {253, 8}, {19, 9},  {275, 9}, {147, 9},\n      {403, 9}, {83, 9},  {339, 9}, {211, 9}, {467, 9}, {51, 9},  {307, 9},\n      {179, 9}, {435, 9}, {115, 9}, {371, 9}, {243, 9}, {499, 9}, {11, 9},\n      {267, 9}, {139, 9}, {395, 9}, {75, 9},  {331, 9}, {203, 9}, {459, 9},\n      {43, 9},  {299, 9}, {171, 9}, {427, 9}, {107, 9}, {363, 9}, {235, 9},\n      {491, 9}, {27, 9},  {283, 9}, {155, 9}, {411, 9}, {91, 9},  {347, 9},\n      {219, 9}, {475, 9}, {59, 9},  {315, 9}, {187, 9}, {443, 9}, {123, 9},\n      {379, 9}, {251, 9}, {507, 9}, {7, 9},   {263, 9}, {135, 9}, {391, 9},\n      {71, 9},  {327, 9}, {199, 9}, {455, 9}, {39, 9},  {295, 9}, {167, 9},\n      {423, 9}, {103, 9}, {359, 9}, {231, 9}, {487, 9}, {23, 9},  {279, 9},\n      {151, 9}, {407, 9}, {87, 9},  {343, 9}, {215, 9}, {471, 9}, {55, 9},\n      {311, 9}, {183, 9}, {439, 9}, {119, 9}, {375, 9}, {247, 9}, {503, 9},\n      {15, 9},  {271, 9}, {143, 9}, {399, 9}, {79, 9},  {335, 9}, {207, 9},\n      {463, 9}, {47, 9},  {303, 9}, {175, 9}, {431, 9}, {111, 9}, {367, 9},\n      {239, 9}, {495, 9}, {31, 9},  {287, 9}, {159, 9}, {415, 9}, {95, 9},\n      {351, 9}, {223, 9}, {479, 9}, {63, 9},  {319, 9}, {191, 9}, {447, 9},\n      {127, 9}, {383, 9}, {255, 9}, {511, 9}, {0, 7},   {64, 7},  {32, 7},\n      {96, 7},  {16, 7},  {80, 7},  {48, 7},  {112, 7}, {8, 7},   {72, 7},\n      {40, 7},  {104, 7}, {24, 7},  {88, 7},  {56, 7},  {120, 7}, {4, 7},\n      {68, 7},  {36, 7},  {100, 7}, {20, 7},  {84, 7},  {52, 7},  {116, 7},\n      {3, 8},   {131, 8}, {67, 8},  {195, 8}, {35, 8},  {163, 8}, {99, 8},\n      {227, 8},\n  };\n  return static_ltree[ch].len;\n}\n\nint GetHuffRunLen(int _len, int _dist) {\n  int lc;\n  unsigned code;\n  int extra;\n  int dist;\n  //int local_lbits;\n  int local_llen;\n  //int local_dbits;\n  int local_dlen;\n  //local_lbits = 0;\n  local_llen = 0;\n\n  int base_length[kLengthCodes] = {\n      0,  1,  2,  3,  4,  5,  6,  7,  8,   10,  12,  14,  16,  20, 24,\n      28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0,\n  };\n\n  int extra_lbits[kLengthCodes]  // extra bits for each length code\n      = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2,\n         2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\n  CtData static_ltree[kLCodes + 2] = {\n      {12, 8},  {140, 8}, {76, 8},  {204, 8}, {44, 8},  {172, 8}, {108, 8},\n      {236, 8}, {28, 8},  {156, 8}, {92, 8},  {220, 8}, {60, 8},  {188, 8},\n      {124, 8}, {252, 8}, {2, 8},   {130, 8}, {66, 8},  {194, 8}, {34, 8},\n      {162, 8}, {98, 8},  {226, 8}, {18, 8},  {146, 8}, {82, 8},  {210, 8},\n      {50, 8},  {178, 8}, {114, 8}, {242, 8}, {10, 8},  {138, 8}, {74, 8},\n      {202, 8}, {42, 8},  {170, 8}, {106, 8}, {234, 8}, {26, 8},  {154, 8},\n      {90, 8},  {218, 8}, {58, 8},  {186, 8}, {122, 8}, {250, 8}, {6, 8},\n      {134, 8}, {70, 8},  {198, 8}, {38, 8},  {166, 8}, {102, 8}, {230, 8},\n      {22, 8},  {150, 8}, {86, 8},  {214, 8}, {54, 8},  {182, 8}, {118, 8},\n      {246, 8}, {14, 8},  {142, 8}, {78, 8},  {206, 8}, {46, 8},  {174, 8},\n      {110, 8}, {238, 8}, {30, 8},  {158, 8}, {94, 8},  {222, 8}, {62, 8},\n      {190, 8}, {126, 8}, {254, 8}, {1, 8},   {129, 8}, {65, 8},  {193, 8},\n      {33, 8},  {161, 8}, {97, 8},  {225, 8}, {17, 8},  {145, 8}, {81, 8},\n      {209, 8}, {49, 8},  {177, 8}, {113, 8}, {241, 8}, {9, 8},   {137, 8},\n      {73, 8},  {201, 8}, {41, 8},  {169, 8}, {105, 8}, {233, 8}, {25, 8},\n      {153, 8}, {89, 8},  {217, 8}, {57, 8},  {185, 8}, {121, 8}, {249, 8},\n      {5, 8},   {133, 8}, {69, 8},  {197, 8}, {37, 8},  {165, 8}, {101, 8},\n      {229, 8}, {21, 8},  {149, 8}, {85, 8},  {213, 8}, {53, 8},  {181, 8},\n      {117, 8}, {245, 8}, {13, 8},  {141, 8}, {77, 8},  {205, 8}, {45, 8},\n      {173, 8}, {109, 8}, {237, 8}, {29, 8},  {157, 8}, {93, 8},  {221, 8},\n      {61, 8},  {189, 8}, {125, 8}, {253, 8}, {19, 9},  {275, 9}, {147, 9},\n      {403, 9}, {83, 9},  {339, 9}, {211, 9}, {467, 9}, {51, 9},  {307, 9},\n      {179, 9}, {435, 9}, {115, 9}, {371, 9}, {243, 9}, {499, 9}, {11, 9},\n      {267, 9}, {139, 9}, {395, 9}, {75, 9},  {331, 9}, {203, 9}, {459, 9},\n      {43, 9},  {299, 9}, {171, 9}, {427, 9}, {107, 9}, {363, 9}, {235, 9},\n      {491, 9}, {27, 9},  {283, 9}, {155, 9}, {411, 9}, {91, 9},  {347, 9},\n      {219, 9}, {475, 9}, {59, 9},  {315, 9}, {187, 9}, {443, 9}, {123, 9},\n      {379, 9}, {251, 9}, {507, 9}, {7, 9},   {263, 9}, {135, 9}, {391, 9},\n      {71, 9},  {327, 9}, {199, 9}, {455, 9}, {39, 9},  {295, 9}, {167, 9},\n      {423, 9}, {103, 9}, {359, 9}, {231, 9}, {487, 9}, {23, 9},  {279, 9},\n      {151, 9}, {407, 9}, {87, 9},  {343, 9}, {215, 9}, {471, 9}, {55, 9},\n      {311, 9}, {183, 9}, {439, 9}, {119, 9}, {375, 9}, {247, 9}, {503, 9},\n      {15, 9},  {271, 9}, {143, 9}, {399, 9}, {79, 9},  {335, 9}, {207, 9},\n      {463, 9}, {47, 9},  {303, 9}, {175, 9}, {431, 9}, {111, 9}, {367, 9},\n      {239, 9}, {495, 9}, {31, 9},  {287, 9}, {159, 9}, {415, 9}, {95, 9},\n      {351, 9}, {223, 9}, {479, 9}, {63, 9},  {319, 9}, {191, 9}, {447, 9},\n      {127, 9}, {383, 9}, {255, 9}, {511, 9}, {0, 7},   {64, 7},  {32, 7},\n      {96, 7},  {16, 7},  {80, 7},  {48, 7},  {112, 7}, {8, 7},   {72, 7},\n      {40, 7},  {104, 7}, {24, 7},  {88, 7},  {56, 7},  {120, 7}, {4, 7},\n      {68, 7},  {36, 7},  {100, 7}, {20, 7},  {84, 7},  {52, 7},  {116, 7},\n      {3, 8},   {131, 8}, {67, 8},  {195, 8}, {35, 8},  {163, 8}, {99, 8},\n      {227, 8},\n  };\n\n  // distance codes. The first 256 values correspond to the distances\n  // 3 .. 258, the last 256 values correspond to the top 8 bits of\n  // the 15 bit distances.\n  unsigned char dist_code[512] = {\n      0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,\n      8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10, 10,\n      10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11,\n      11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,\n      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n      12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n      13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 0,  0,  16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21,\n      21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29,\n  };\n  // length code for each normalized match length (0 == kMinMatch)\n  unsigned char length_code[kMaxMatch - kMinMatch + 1] = {\n      0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9,  10, 10, 11, 11, 12, 12,\n      12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,\n      16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18,\n      18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n      21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n      23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 28,\n  };\n\n  int extra_dbits[kDCodes]  // extra bits for each distance code\n      = {0, 0, 0, 0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,\n         6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};\n\n  int base_dist[kDCodes] = {\n      0,    1,    2,    3,    4,    6,    8,    12,    16,    24,\n      32,   48,   64,   96,   128,  192,  256,  384,   512,   768,\n      1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576,\n  };\n\n  CtData static_dtree[kDCodes] = {\n      {0, 5}, {16, 5}, {8, 5},  {24, 5}, {4, 5}, {20, 5}, {12, 5}, {28, 5},\n      {2, 5}, {18, 5}, {10, 5}, {26, 5}, {6, 5}, {22, 5}, {14, 5}, {30, 5},\n      {1, 5}, {17, 5}, {9, 5},  {25, 5}, {5, 5}, {21, 5}, {13, 5}, {29, 5},\n      {3, 5}, {19, 5}, {11, 5}, {27, 5}, {7, 5}, {23, 5},\n  };\n\n  lc = _len - kMinMatch;\n  code = length_code[lc];\n\n  //local_lbits = static_ltree[code + kLiterals + 1].code;\n  local_llen = static_ltree[code + kLiterals + 1].len;\n  extra = extra_lbits[code];\n  if (extra) {\n    lc -= base_length[code];\n    //local_lbits |= lc << local_llen;\n    local_llen += extra;\n  }\n\n  dist = _dist;\n  dist--;\n  code = d_code(dist);\n  //local_dbits = static_dtree[code].code;\n  local_dlen = static_dtree[code].len;\n  extra = extra_dbits[code];\n  if (extra) {\n    dist -= base_dist[code];\n    //local_dbits |= dist << local_dlen;\n    local_dlen += extra;\n  }\n\n  //local_lbits |= local_dbits << local_llen;\n  local_llen += local_dlen;\n\n  return local_llen;\n}\n\nint GetHuffRunBits(int _len, int _dist) {\n  int lc;\n  unsigned code;\n  int extra;\n  int dist;\n  int local_lbits, local_llen;\n  int local_dbits, local_dlen;\n  local_lbits = 0;\n  local_llen = 0;\n\n  int base_length[kLengthCodes] = {\n      0,  1,  2,  3,  4,  5,  6,  7,  8,   10,  12,  14,  16,  20, 24,\n      28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0,\n  };\n\n  int extra_lbits[kLengthCodes]  // extra bits for each length code\n      = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2,\n         2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\n  CtData static_ltree[kLCodes + 2] = {\n      {12, 8},  {140, 8}, {76, 8},  {204, 8}, {44, 8},  {172, 8}, {108, 8},\n      {236, 8}, {28, 8},  {156, 8}, {92, 8},  {220, 8}, {60, 8},  {188, 8},\n      {124, 8}, {252, 8}, {2, 8},   {130, 8}, {66, 8},  {194, 8}, {34, 8},\n      {162, 8}, {98, 8},  {226, 8}, {18, 8},  {146, 8}, {82, 8},  {210, 8},\n      {50, 8},  {178, 8}, {114, 8}, {242, 8}, {10, 8},  {138, 8}, {74, 8},\n      {202, 8}, {42, 8},  {170, 8}, {106, 8}, {234, 8}, {26, 8},  {154, 8},\n      {90, 8},  {218, 8}, {58, 8},  {186, 8}, {122, 8}, {250, 8}, {6, 8},\n      {134, 8}, {70, 8},  {198, 8}, {38, 8},  {166, 8}, {102, 8}, {230, 8},\n      {22, 8},  {150, 8}, {86, 8},  {214, 8}, {54, 8},  {182, 8}, {118, 8},\n      {246, 8}, {14, 8},  {142, 8}, {78, 8},  {206, 8}, {46, 8},  {174, 8},\n      {110, 8}, {238, 8}, {30, 8},  {158, 8}, {94, 8},  {222, 8}, {62, 8},\n      {190, 8}, {126, 8}, {254, 8}, {1, 8},   {129, 8}, {65, 8},  {193, 8},\n      {33, 8},  {161, 8}, {97, 8},  {225, 8}, {17, 8},  {145, 8}, {81, 8},\n      {209, 8}, {49, 8},  {177, 8}, {113, 8}, {241, 8}, {9, 8},   {137, 8},\n      {73, 8},  {201, 8}, {41, 8},  {169, 8}, {105, 8}, {233, 8}, {25, 8},\n      {153, 8}, {89, 8},  {217, 8}, {57, 8},  {185, 8}, {121, 8}, {249, 8},\n      {5, 8},   {133, 8}, {69, 8},  {197, 8}, {37, 8},  {165, 8}, {101, 8},\n      {229, 8}, {21, 8},  {149, 8}, {85, 8},  {213, 8}, {53, 8},  {181, 8},\n      {117, 8}, {245, 8}, {13, 8},  {141, 8}, {77, 8},  {205, 8}, {45, 8},\n      {173, 8}, {109, 8}, {237, 8}, {29, 8},  {157, 8}, {93, 8},  {221, 8},\n      {61, 8},  {189, 8}, {125, 8}, {253, 8}, {19, 9},  {275, 9}, {147, 9},\n      {403, 9}, {83, 9},  {339, 9}, {211, 9}, {467, 9}, {51, 9},  {307, 9},\n      {179, 9}, {435, 9}, {115, 9}, {371, 9}, {243, 9}, {499, 9}, {11, 9},\n      {267, 9}, {139, 9}, {395, 9}, {75, 9},  {331, 9}, {203, 9}, {459, 9},\n      {43, 9},  {299, 9}, {171, 9}, {427, 9}, {107, 9}, {363, 9}, {235, 9},\n      {491, 9}, {27, 9},  {283, 9}, {155, 9}, {411, 9}, {91, 9},  {347, 9},\n      {219, 9}, {475, 9}, {59, 9},  {315, 9}, {187, 9}, {443, 9}, {123, 9},\n      {379, 9}, {251, 9}, {507, 9}, {7, 9},   {263, 9}, {135, 9}, {391, 9},\n      {71, 9},  {327, 9}, {199, 9}, {455, 9}, {39, 9},  {295, 9}, {167, 9},\n      {423, 9}, {103, 9}, {359, 9}, {231, 9}, {487, 9}, {23, 9},  {279, 9},\n      {151, 9}, {407, 9}, {87, 9},  {343, 9}, {215, 9}, {471, 9}, {55, 9},\n      {311, 9}, {183, 9}, {439, 9}, {119, 9}, {375, 9}, {247, 9}, {503, 9},\n      {15, 9},  {271, 9}, {143, 9}, {399, 9}, {79, 9},  {335, 9}, {207, 9},\n      {463, 9}, {47, 9},  {303, 9}, {175, 9}, {431, 9}, {111, 9}, {367, 9},\n      {239, 9}, {495, 9}, {31, 9},  {287, 9}, {159, 9}, {415, 9}, {95, 9},\n      {351, 9}, {223, 9}, {479, 9}, {63, 9},  {319, 9}, {191, 9}, {447, 9},\n      {127, 9}, {383, 9}, {255, 9}, {511, 9}, {0, 7},   {64, 7},  {32, 7},\n      {96, 7},  {16, 7},  {80, 7},  {48, 7},  {112, 7}, {8, 7},   {72, 7},\n      {40, 7},  {104, 7}, {24, 7},  {88, 7},  {56, 7},  {120, 7}, {4, 7},\n      {68, 7},  {36, 7},  {100, 7}, {20, 7},  {84, 7},  {52, 7},  {116, 7},\n      {3, 8},   {131, 8}, {67, 8},  {195, 8}, {35, 8},  {163, 8}, {99, 8},\n      {227, 8},\n  };\n\n  // distance codes. The first 256 values correspond to the distances\n  // 3 .. 258, the last 256 values correspond to the top 8 bits of\n  // the 15 bit distances.\n  unsigned char dist_code[512] = {\n      0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,\n      8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10, 10,\n      10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11,\n      11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,\n      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n      12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n      13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n      15, 15, 15, 15, 0,  0,  16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21,\n      21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n      29, 29, 29, 29, 29, 29, 29, 29,\n  };\n  // length code for each normalized match length (0 == kMinMatch)\n  unsigned char length_code[kMaxMatch - kMinMatch + 1] = {\n      0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9,  10, 10, 11, 11, 12, 12,\n      12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,\n      16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18,\n      18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n      21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n      23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n      27, 27, 27, 28,\n  };\n\n  int extra_dbits[kDCodes]  // extra bits for each distance code\n      = {0, 0, 0, 0, 1, 1, 2, 2,  3,  3,  4,  4,  5,  5,  6,\n         6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};\n\n  int base_dist[kDCodes] = {\n      0,    1,    2,    3,    4,    6,    8,    12,    16,    24,\n      32,   48,   64,   96,   128,  192,  256,  384,   512,   768,\n      1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576,\n  };\n\n  CtData static_dtree[kDCodes] = {\n      {0, 5}, {16, 5}, {8, 5},  {24, 5}, {4, 5}, {20, 5}, {12, 5}, {28, 5},\n      {2, 5}, {18, 5}, {10, 5}, {26, 5}, {6, 5}, {22, 5}, {14, 5}, {30, 5},\n      {1, 5}, {17, 5}, {9, 5},  {25, 5}, {5, 5}, {21, 5}, {13, 5}, {29, 5},\n      {3, 5}, {19, 5}, {11, 5}, {27, 5}, {7, 5}, {23, 5},\n  };\n\n  lc = _len - kMinMatch;\n  code = length_code[lc];\n\n  local_lbits = static_ltree[code + kLiterals + 1].code;\n  local_llen = static_ltree[code + kLiterals + 1].len;\n  extra = extra_lbits[code];\n  if (extra) {\n    lc -= base_length[code];\n    local_lbits |= lc << local_llen;\n    local_llen += extra;\n  }\n\n  dist = _dist;\n  dist--;\n  code = d_code(dist);\n  local_dbits = static_dtree[code].code;\n  local_dlen = static_dtree[code].len;\n  extra = extra_dbits[code];\n  if (extra) {\n    dist -= base_dist[code];\n    local_dbits |= dist << local_dlen;\n    local_dlen += extra;\n  }\n\n  local_lbits |= local_dbits << local_llen;\n  local_llen += local_dlen;\n\n  return local_lbits;\n}\n\nint GetHuffLen(int len, int dist, unsigned char ch) {\n  int returned_len;\n\n  CtData static_ltree[kLCodes + 2] = {\n      {12, 8},  {140, 8}, {76, 8},  {204, 8}, {44, 8},  {172, 8}, {108, 8},\n      {236, 8}, {28, 8},  {156, 8}, {92, 8},  {220, 8}, {60, 8},  {188, 8},\n      {124, 8}, {252, 8}, {2, 8},   {130, 8}, {66, 8},  {194, 8}, {34, 8},\n      {162, 8}, {98, 8},  {226, 8}, {18, 8},  {146, 8}, {82, 8},  {210, 8},\n      {50, 8},  {178, 8}, {114, 8}, {242, 8}, {10, 8},  {138, 8}, {74, 8},\n      {202, 8}, {42, 8},  {170, 8}, {106, 8}, {234, 8}, {26, 8},  {154, 8},\n      {90, 8},  {218, 8}, {58, 8},  {186, 8}, {122, 8}, {250, 8}, {6, 8},\n      {134, 8}, {70, 8},  {198, 8}, {38, 8},  {166, 8}, {102, 8}, {230, 8},\n      {22, 8},  {150, 8}, {86, 8},  {214, 8}, {54, 8},  {182, 8}, {118, 8},\n      {246, 8}, {14, 8},  {142, 8}, {78, 8},  {206, 8}, {46, 8},  {174, 8},\n      {110, 8}, {238, 8}, {30, 8},  {158, 8}, {94, 8},  {222, 8}, {62, 8},\n      {190, 8}, {126, 8}, {254, 8}, {1, 8},   {129, 8}, {65, 8},  {193, 8},\n      {33, 8},  {161, 8}, {97, 8},  {225, 8}, {17, 8},  {145, 8}, {81, 8},\n      {209, 8}, {49, 8},  {177, 8}, {113, 8}, {241, 8}, {9, 8},   {137, 8},\n      {73, 8},  {201, 8}, {41, 8},  {169, 8}, {105, 8}, {233, 8}, {25, 8},\n      {153, 8}, {89, 8},  {217, 8}, {57, 8},  {185, 8}, {121, 8}, {249, 8},\n      {5, 8},   {133, 8}, {69, 8},  {197, 8}, {37, 8},  {165, 8}, {101, 8},\n      {229, 8}, {21, 8},  {149, 8}, {85, 8},  {213, 8}, {53, 8},  {181, 8},\n      {117, 8}, {245, 8}, {13, 8},  {141, 8}, {77, 8},  {205, 8}, {45, 8},\n      {173, 8}, {109, 8}, {237, 8}, {29, 8},  {157, 8}, {93, 8},  {221, 8},\n      {61, 8},  {189, 8}, {125, 8}, {253, 8}, {19, 9},  {275, 9}, {147, 9},\n      {403, 9}, {83, 9},  {339, 9}, {211, 9}, {467, 9}, {51, 9},  {307, 9},\n      {179, 9}, {435, 9}, {115, 9}, {371, 9}, {243, 9}, {499, 9}, {11, 9},\n      {267, 9}, {139, 9}, {395, 9}, {75, 9},  {331, 9}, {203, 9}, {459, 9},\n      {43, 9},  {299, 9}, {171, 9}, {427, 9}, {107, 9}, {363, 9}, {235, 9},\n      {491, 9}, {27, 9},  {283, 9}, {155, 9}, {411, 9}, {91, 9},  {347, 9},\n      {219, 9}, {475, 9}, {59, 9},  {315, 9}, {187, 9}, {443, 9}, {123, 9},\n      {379, 9}, {251, 9}, {507, 9}, {7, 9},   {263, 9}, {135, 9}, {391, 9},\n      {71, 9},  {327, 9}, {199, 9}, {455, 9}, {39, 9},  {295, 9}, {167, 9},\n      {423, 9}, {103, 9}, {359, 9}, {231, 9}, {487, 9}, {23, 9},  {279, 9},\n      {151, 9}, {407, 9}, {87, 9},  {343, 9}, {215, 9}, {471, 9}, {55, 9},\n      {311, 9}, {183, 9}, {439, 9}, {119, 9}, {375, 9}, {247, 9}, {503, 9},\n      {15, 9},  {271, 9}, {143, 9}, {399, 9}, {79, 9},  {335, 9}, {207, 9},\n      {463, 9}, {47, 9},  {303, 9}, {175, 9}, {431, 9}, {111, 9}, {367, 9},\n      {239, 9}, {495, 9}, {31, 9},  {287, 9}, {159, 9}, {415, 9}, {95, 9},\n      {351, 9}, {223, 9}, {479, 9}, {63, 9},  {319, 9}, {191, 9}, {447, 9},\n      {127, 9}, {383, 9}, {255, 9}, {511, 9}, {0, 7},   {64, 7},  {32, 7},\n      {96, 7},  {16, 7},  {80, 7},  {48, 7},  {112, 7}, {8, 7},   {72, 7},\n      {40, 7},  {104, 7}, {24, 7},  {88, 7},  {56, 7},  {120, 7}, {4, 7},\n      {68, 7},  {36, 7},  {100, 7}, {20, 7},  {84, 7},  {52, 7},  {116, 7},\n      {3, 8},   {131, 8}, {67, 8},  {195, 8}, {35, 8},  {163, 8}, {99, 8},\n      {227, 8},\n  };\n  switch (len) {\n    case -3:\n      returned_len = static_ltree[kEndBlock].len;\n      break;\n    case -2:\n      returned_len = 3;\n      break;\n    case -1:\n      returned_len = 0;\n      break;\n    case 0:\n      returned_len = GetHuffLiteralLen(ch);\n      break;\n    default:\n      returned_len = GetHuffRunLen(len, dist);\n      break;\n  }\n  return returned_len;\n}\n\nint IsValid(int len, int dist, unsigned char ch) {\n  switch (len) {\n    case -3:\n      return 1;\n    case -2:\n      return 1;\n    case -1:\n      return 0;\n    case 0:\n      return 1;\n    default:\n      return 1;\n  }\n}\n\nint GetHuffBits(int len, int dist, unsigned char ch) {\n  int bits;\n  CtData static_ltree[kLCodes + 2] = {\n      {12, 8},  {140, 8}, {76, 8},  {204, 8}, {44, 8},  {172, 8}, {108, 8},\n      {236, 8}, {28, 8},  {156, 8}, {92, 8},  {220, 8}, {60, 8},  {188, 8},\n      {124, 8}, {252, 8}, {2, 8},   {130, 8}, {66, 8},  {194, 8}, {34, 8},\n      {162, 8}, {98, 8},  {226, 8}, {18, 8},  {146, 8}, {82, 8},  {210, 8},\n      {50, 8},  {178, 8}, {114, 8}, {242, 8}, {10, 8},  {138, 8}, {74, 8},\n      {202, 8}, {42, 8},  {170, 8}, {106, 8}, {234, 8}, {26, 8},  {154, 8},\n      {90, 8},  {218, 8}, {58, 8},  {186, 8}, {122, 8}, {250, 8}, {6, 8},\n      {134, 8}, {70, 8},  {198, 8}, {38, 8},  {166, 8}, {102, 8}, {230, 8},\n      {22, 8},  {150, 8}, {86, 8},  {214, 8}, {54, 8},  {182, 8}, {118, 8},\n      {246, 8}, {14, 8},  {142, 8}, {78, 8},  {206, 8}, {46, 8},  {174, 8},\n      {110, 8}, {238, 8}, {30, 8},  {158, 8}, {94, 8},  {222, 8}, {62, 8},\n      {190, 8}, {126, 8}, {254, 8}, {1, 8},   {129, 8}, {65, 8},  {193, 8},\n      {33, 8},  {161, 8}, {97, 8},  {225, 8}, {17, 8},  {145, 8}, {81, 8},\n      {209, 8}, {49, 8},  {177, 8}, {113, 8}, {241, 8}, {9, 8},   {137, 8},\n      {73, 8},  {201, 8}, {41, 8},  {169, 8}, {105, 8}, {233, 8}, {25, 8},\n      {153, 8}, {89, 8},  {217, 8}, {57, 8},  {185, 8}, {121, 8}, {249, 8},\n      {5, 8},   {133, 8}, {69, 8},  {197, 8}, {37, 8},  {165, 8}, {101, 8},\n      {229, 8}, {21, 8},  {149, 8}, {85, 8},  {213, 8}, {53, 8},  {181, 8},\n      {117, 8}, {245, 8}, {13, 8},  {141, 8}, {77, 8},  {205, 8}, {45, 8},\n      {173, 8}, {109, 8}, {237, 8}, {29, 8},  {157, 8}, {93, 8},  {221, 8},\n      {61, 8},  {189, 8}, {125, 8}, {253, 8}, {19, 9},  {275, 9}, {147, 9},\n      {403, 9}, {83, 9},  {339, 9}, {211, 9}, {467, 9}, {51, 9},  {307, 9},\n      {179, 9}, {435, 9}, {115, 9}, {371, 9}, {243, 9}, {499, 9}, {11, 9},\n      {267, 9}, {139, 9}, {395, 9}, {75, 9},  {331, 9}, {203, 9}, {459, 9},\n      {43, 9},  {299, 9}, {171, 9}, {427, 9}, {107, 9}, {363, 9}, {235, 9},\n      {491, 9}, {27, 9},  {283, 9}, {155, 9}, {411, 9}, {91, 9},  {347, 9},\n      {219, 9}, {475, 9}, {59, 9},  {315, 9}, {187, 9}, {443, 9}, {123, 9},\n      {379, 9}, {251, 9}, {507, 9}, {7, 9},   {263, 9}, {135, 9}, {391, 9},\n      {71, 9},  {327, 9}, {199, 9}, {455, 9}, {39, 9},  {295, 9}, {167, 9},\n      {423, 9}, {103, 9}, {359, 9}, {231, 9}, {487, 9}, {23, 9},  {279, 9},\n      {151, 9}, {407, 9}, {87, 9},  {343, 9}, {215, 9}, {471, 9}, {55, 9},\n      {311, 9}, {183, 9}, {439, 9}, {119, 9}, {375, 9}, {247, 9}, {503, 9},\n      {15, 9},  {271, 9}, {143, 9}, {399, 9}, {79, 9},  {335, 9}, {207, 9},\n      {463, 9}, {47, 9},  {303, 9}, {175, 9}, {431, 9}, {111, 9}, {367, 9},\n      {239, 9}, {495, 9}, {31, 9},  {287, 9}, {159, 9}, {415, 9}, {95, 9},\n      {351, 9}, {223, 9}, {479, 9}, {63, 9},  {319, 9}, {191, 9}, {447, 9},\n      {127, 9}, {383, 9}, {255, 9}, {511, 9}, {0, 7},   {64, 7},  {32, 7},\n      {96, 7},  {16, 7},  {80, 7},  {48, 7},  {112, 7}, {8, 7},   {72, 7},\n      {40, 7},  {104, 7}, {24, 7},  {88, 7},  {56, 7},  {120, 7}, {4, 7},\n      {68, 7},  {36, 7},  {100, 7}, {20, 7},  {84, 7},  {52, 7},  {116, 7},\n      {3, 8},   {131, 8}, {67, 8},  {195, 8}, {35, 8},  {163, 8}, {99, 8},\n      {227, 8},\n  };\n  switch (len) {\n    case -3:\n      bits = static_ltree[kEndBlock].code;\n      break;\n    case -2:\n      bits = ch;\n      break;\n    case -1:\n      bits = 0;\n      break;\n    case 0:\n      bits = GetHuffLiteralBits(ch);\n      break;\n    default:\n      bits = GetHuffRunBits(len, dist);\n      break;\n  }\n  return bits;\n}\n\n// assembles up to kVecX2 unsigned char values based on given huffman encoding\n// writes up to kMaxHuffcodeBits * kVecX2 bits to memory\nbool HufEnc(char *len, short *dist, unsigned char *data, unsigned int *outdata,\n            unsigned int *leftover, unsigned short *leftover_size) {\n  // array that contains the bit position of each symbol\n  unsigned short bitpos[kVec + 1];\n  bitpos[0] = 0;\n\n  Unroller<0, kVec>::step([&](int i) {\n    bitpos[i + 1] = bitpos[i] + (IsValid(len[i], dist[i], data[i])\n                                     ? GetHuffLen(len[i], dist[i], data[i])\n                                     : 0);\n  });\n\n  // leftover is an array that carries huffman encoded data not yet written to\n  // memory adjust leftover_size with the number of bits to write this time\n  unsigned short prev_cycle_offset = *leftover_size;\n  *leftover_size += (bitpos[kVec] & 0x3fff);\n\n  // we'll write this cycle if we have collected enough data (kVec shorts or\n  // more)\n  bool write = *leftover_size & (kVec * (kMaxHuffcodeBits * 2));\n\n  // subtract kVec shorts from leftover size (if it's bigger\n  // than kVec) because we'll write those out this cycle\n  *leftover_size &= ~(kVec * (kMaxHuffcodeBits * 2));\n\n  // Adjust bitpos based on leftover offset from previous cycle\n  Unroller<0, kVec>::step(\n      [&](int i) { bitpos[i] += (prev_cycle_offset & 0x3fff); });\n\n  // Huffman codes have any bit alignement, so they can spill\n  // onto two shorts in the output array\n  // use ushort2 to keep each part of the code separate\n  // Iterate over all codes and construct ushort2 containing\n  // the code properly aligned\n  struct Uint2Gzip code[kVec];\n  Unroller<0, kVec>::step([&](int i) {\n    code[i].x = 0;\n    code[i].y = 0;\n  });\n\n  Unroller<0, kVec>::step([&](int i) {\n    // Codes can be more than 16 bits, so use uint32\n    unsigned int curr_code = GetHuffBits(len[i], dist[i], data[i]);\n    unsigned char bitpos_in_short = bitpos[i] & 0x01F;\n\n    unsigned long long temp = (unsigned long long)curr_code << bitpos_in_short;\n    unsigned int temp1 = (unsigned int)temp;\n    unsigned int temp2 = temp >> 32ULL;\n\n    if (IsValid(len[i], dist[i], data[i])) {\n      code[i].x = temp1;\n      code[i].y = temp2;\n    } else {\n      code[i].x = temp1;\n      code[i].y = temp2;\n    }\n  });\n\n  // Iterate over all destination locations and gather the required data\n  unsigned int new_leftover[kVec];\n  Unroller<0, kVec>::step([&](int i) {\n    new_leftover[i] = 0;\n    outdata[i] = 0;\n\n    Unroller<0, kVec>::step([&](int j) {\n      // figure out whether code[j] goes into bucket[i]\n      bool match_first = ((bitpos[j] >> 5) & (kVec - 1)) == i;\n      bool match_second =\n          ((bitpos[j] >> 5) & (kVec - 1)) == ((i - 1) & (kVec - 1));\n\n      // if code[j] maps onto current bucket then OR its code, else OR with 0\n      unsigned int component =\n          match_first ? code[j].x : (match_second ? code[j].y : 0);\n\n      // overflow from kVec shorts, need to move onto new_leftover\n      bool use_later =\n          (bitpos[j] & (kVec * (kMaxHuffcodeBits * 2))) ||\n          (match_second && (((bitpos[j] >> 5) & (kVec - 1)) == kVec - 1));\n\n      // write to output\n      outdata[i] |= use_later ? 0 : component;\n      new_leftover[i] |= use_later ? component : 0;\n    });\n  });\n\n  // Apply previous leftover on the outdata\n  // Also, if didn't write, apply prev leftover onto newleftover\n  Unroller<0, kVec>::step([&](int i) {\n    outdata[i] |= leftover[i];\n    leftover[i] = outdata[i];\n  });\n\n  // HACK: split unroll into two unrolls to avoid compiler crash\n  if (write) {\n    Unroller<0, kVec>::step([&](int i) { leftover[i] = new_leftover[i]; });\n  }\n\n  return write;\n}\n\n// Helper, for accessing the parameter pack\ntemplate <int target, typename CurrentAccessor, typename... AccessorTys>\nauto get(CurrentAccessor &accessor, AccessorTys &... Args) {\n  if constexpr (target == 0)\n    return accessor;\n  else\n    return get<target - 1>(Args...);\n}\n\ntemplate <int engineID>\nclass CRC;\ntemplate <int engineID, int BatchSize>\nevent SubmitCRC(queue &q, size_t block_size, uint32_t *result_crc,\n                std::vector<event> &depend_on) {\n  event e = q.submit([&](handler &h) {\n    // Temporarily remove event dependences to work around a bug in 2024.2\n    // This is safe on FPGA because invocations of the same kernel are \n    // serialized for non-pipelined kernels\n    // Note: this is not portable\n    //if (!depend_on.empty()) {\n    //  h.depends_on(depend_on[kCRCIndex]);\n    //}\n\n    h.single_task<CRC<engineID>>([=]() [[intel::kernel_args_restrict]] {\n      auto accessor_isz = block_size;\n\n      sycl::ext::intel::host_ptr<uint32_t> accresult_crc(result_crc);\n\n      // See comments at top of file, regarding batching.\n      [[intel::disable_loop_pipelining]]\n      for (int iter=0;iter<BatchSize;iter++) {\n        const unsigned int table64[64][16] = {\n            {\n                0x0,\n                0xf1da05aa,\n                0x38c50d15,\n                0xc91f08bf,\n                0x718a1a2a,\n                0x80501f80,\n                0x494f173f,\n                0xb8951295,\n                0xe3143454,\n                0x12ce31fe,\n                0xdbd13941,\n                0x2a0b3ceb,\n                0x929e2e7e,\n                0x63442bd4,\n                0xaa5b236b,\n                0x5b8126c1,\n            },\n\n            {\n                0x0,\n                0x1d596ee9,\n                0x3ab2ddd2,\n                0x27ebb33b,\n                0x7565bba4,\n                0x683cd54d,\n                0x4fd76676,\n                0x528e089f,\n                0xeacb7748,\n                0xf79219a1,\n                0xd079aa9a,\n                0xcd20c473,\n                0x9faeccec,\n                0x82f7a205,\n                0xa51c113e,\n                0xb8457fd7,\n            },\n\n            {\n                0x0,\n                0xee7e8d1,\n                0x1dcfd1a2,\n                0x13283973,\n                0x3b9fa344,\n                0x35784b95,\n                0x265072e6,\n                0x28b79a37,\n                0x773f4688,\n                0x79d8ae59,\n                0x6af0972a,\n                0x64177ffb,\n                0x4ca0e5cc,\n                0x42470d1d,\n                0x516f346e,\n                0x5f88dcbf,\n            },\n\n            {\n                0x0,\n                0xee7e8d10,\n                0x78c1c61,\n                0xe9f29171,\n                0xf1838c2,\n                0xe166b5d2,\n                0x89424a3,\n                0xe6eaa9b3,\n                0x1e307184,\n                0xf04efc94,\n                0x19bc6de5,\n                0xf7c2e0f5,\n                0x11284946,\n                0xff56c456,\n                0x16a45527,\n                0xf8dad837,\n            },\n\n            {\n                0x0,\n                0x3c60e308,\n                0x78c1c610,\n                0x44a12518,\n                0xf1838c20,\n                0xcde36f28,\n                0x89424a30,\n                0xb522a938,\n                0x38761e01,\n                0x416fd09,\n                0x40b7d811,\n                0x7cd73b19,\n                0xc9f59221,\n                0xf5957129,\n                0xb1345431,\n                0x8d54b739,\n            },\n\n            {\n                0x0,\n                0x70ec3c02,\n                0xe1d87804,\n                0x91344406,\n                0x18c1f649,\n                0x682dca4b,\n                0xf9198e4d,\n                0x89f5b24f,\n                0x3183ec92,\n                0x416fd090,\n                0xd05b9496,\n                0xa0b7a894,\n                0x29421adb,\n                0x59ae26d9,\n                0xc89a62df,\n                0xb8765edd,\n            },\n\n            {\n                0x0,\n                0x6307d924,\n                0xc60fb248,\n                0xa5086b6c,\n                0x576e62d1,\n                0x3469bbf5,\n                0x9161d099,\n                0xf26609bd,\n                0xaedcc5a2,\n                0xcddb1c86,\n                0x68d377ea,\n                0xbd4aece,\n                0xf9b2a773,\n                0x9ab57e57,\n                0x3fbd153b,\n                0x5cbacc1f,\n            },\n\n            {\n                0x0,\n                0x86c88d05,\n                0xd6e01c4b,\n                0x5028914e,\n                0x76b13ed7,\n                0xf079b3d2,\n                0xa051229c,\n                0x2699af99,\n                0xed627dae,\n                0x6baaf0ab,\n                0x3b8261e5,\n                0xbd4aece0,\n                0x9bd34379,\n                0x1d1bce7c,\n                0x4d335f32,\n                0xcbfbd237,\n            },\n\n            {\n                0x0,\n                0x1b5fd1d,\n                0x36bfa3a,\n                0x2de0727,\n                0x6d7f474,\n                0x7620969,\n                0x5bc0e4e,\n                0x409f353,\n                0xdafe8e8,\n                0xc1a15f5,\n                0xec412d2,\n                0xf71efcf,\n                0xb781c9c,\n                0xacde181,\n                0x813e6a6,\n                0x9a61bbb,\n            },\n\n            {\n                0x0,\n                0x1b5fd1d0,\n                0x36bfa3a0,\n                0x2de07270,\n                0x6d7f4740,\n                0x76209690,\n                0x5bc0e4e0,\n                0x409f3530,\n                0xdafe8e80,\n                0xc1a15f50,\n                0xec412d20,\n                0xf71efcf0,\n                0xb781c9c0,\n                0xacde1810,\n                0x813e6a60,\n                0x9a61bbb0,\n            },\n\n            {\n                0x0,\n                0x6e8c1b41,\n                0xdd183682,\n                0xb3942dc3,\n                0x61416b45,\n                0xfcd7004,\n                0xbc595dc7,\n                0xd2d54686,\n                0xc282d68a,\n                0xac0ecdcb,\n                0x1f9ae008,\n                0x7116fb49,\n                0xa3c3bdcf,\n                0xcd4fa68e,\n                0x7edb8b4d,\n                0x1057900c,\n            },\n\n            {\n                0x0,\n                0x5e74ab55,\n                0xbce956aa,\n                0xe29dfdff,\n                0xa2a3ab15,\n                0xfcd70040,\n                0x1e4afdbf,\n                0x403e56ea,\n                0x9e36506b,\n                0xc042fb3e,\n                0x22df06c1,\n                0x7cabad94,\n                0x3c95fb7e,\n                0x62e1502b,\n                0x807cadd4,\n                0xde080681,\n            },\n\n            {\n                0x0,\n                0xe71da697,\n                0x154a4b6f,\n                0xf257edf8,\n                0x2a9496de,\n                0xcd893049,\n                0x3fdeddb1,\n                0xd8c37b26,\n                0x55292dbc,\n                0xb2348b2b,\n                0x406366d3,\n                0xa77ec044,\n                0x7fbdbb62,\n                0x98a01df5,\n                0x6af7f00d,\n                0x8dea569a,\n            },\n\n            {\n                0x0,\n                0xaa525b78,\n                0x8fd5b0b1,\n                0x2587ebc9,\n                0xc4da6723,\n                0x6e883c5b,\n                0x4b0fd792,\n                0xe15d8cea,\n                0x52c5c807,\n                0xf897937f,\n                0xdd1078b6,\n                0x774223ce,\n                0x961faf24,\n                0x3c4df45c,\n                0x19ca1f95,\n                0xb39844ed,\n            },\n\n            {\n                0x0,\n                0xa58b900e,\n                0x9066265d,\n                0x35edb653,\n                0xfbbd4afb,\n                0x5e36daf5,\n                0x6bdb6ca6,\n                0xce50fca8,\n                0x2c0b93b7,\n                0x898003b9,\n                0xbc6db5ea,\n                0x19e625e4,\n                0xd7b6d94c,\n                0x723d4942,\n                0x47d0ff11,\n                0xe25b6f1f,\n            },\n\n            {\n                0x0,\n                0x5817276e,\n                0xb02e4edc,\n                0xe83969b2,\n                0xbb2d9bf9,\n                0xe33abc97,\n                0xb03d525,\n                0x5314f24b,\n                0xad2a31b3,\n                0xf53d16dd,\n                0x1d047f6f,\n                0x45135801,\n                0x1607aa4a,\n                0x4e108d24,\n                0xa629e496,\n                0xfe3ec3f8,\n            },\n\n            {\n                0x0,\n                0x81256527,\n                0xd93bcc0f,\n                0x581ea928,\n                0x69069e5f,\n                0xe823fb78,\n                0xb03d5250,\n                0x31183777,\n                0xd20d3cbe,\n                0x53285999,\n                0xb36f0b1,\n                0x8a139596,\n                0xbb0ba2e1,\n                0x3a2ec7c6,\n                0x62306eee,\n                0xe3150bc9,\n            },\n\n            {\n                0x0,\n                0x7f6b7f3d,\n                0xfed6fe7a,\n                0x81bd8147,\n                0x26dcfab5,\n                0x59b78588,\n                0xd80a04cf,\n                0xa7617bf2,\n                0x4db9f56a,\n                0x32d28a57,\n                0xb36f0b10,\n                0xcc04742d,\n                0x6b650fdf,\n                0x140e70e2,\n                0x95b3f1a5,\n                0xead88e98,\n            },\n\n            {\n                0x0,\n                0x9b73ead4,\n                0xed96d3e9,\n                0x76e5393d,\n                0x5ca193,\n                0x9b2f4b47,\n                0xedca727a,\n                0x76b998ae,\n                0xb94326,\n                0x9bcaa9f2,\n                0xed2f90cf,\n                0x765c7a1b,\n                0xe5e2b5,\n                0x9b960861,\n                0xed73315c,\n                0x7600db88,\n            },\n\n            {\n                0x0,\n                0x172864c,\n                0x2e50c98,\n                0x3978ad4,\n                0x5ca1930,\n                0x4b89f7c,\n                0x72f15a8,\n                0x65d93e4,\n                0xb943260,\n                0xae6b42c,\n                0x9713ef8,\n                0x803b8b4,\n                0xe5e2b50,\n                0xf2cad1c,\n                0xcbb27c8,\n                0xdc9a184,\n            },\n\n            {\n                0x0,\n                0x172864c0,\n                0x2e50c980,\n                0x3978ad40,\n                0x5ca19300,\n                0x4b89f7c0,\n                0x72f15a80,\n                0x65d93e40,\n                0xb9432600,\n                0xae6b42c0,\n                0x9713ef80,\n                0x803b8b40,\n                0xe5e2b500,\n                0xf2cad1c0,\n                0xcbb27c80,\n                0xdc9a1840,\n            },\n\n            {\n                0x0,\n                0xa9f74a41,\n                0x889f92c3,\n                0x2168d882,\n                0xca4e23c7,\n                0x63b96986,\n                0x42d1b104,\n                0xeb26fb45,\n                0x4fed41cf,\n                0xe61a0b8e,\n                0xc772d30c,\n                0x6e85994d,\n                0x85a36208,\n                0x2c542849,\n                0xd3cf0cb,\n                0xa4cbba8a,\n            },\n\n            {\n                0x0,\n                0x9fda839e,\n                0xe4c4017d,\n                0x7b1e82e3,\n                0x12f904bb,\n                0x8d238725,\n                0xf63d05c6,\n                0x69e78658,\n                0x25f20976,\n                0xba288ae8,\n                0xc136080b,\n                0x5eec8b95,\n                0x370b0dcd,\n                0xa8d18e53,\n                0xd3cf0cb0,\n                0x4c158f2e,\n            },\n\n            {\n                0x0,\n                0x4be412ec,\n                0x97c825d8,\n                0xdc2c3734,\n                0xf4e14df1,\n                0xbf055f1d,\n                0x63296829,\n                0x28cd7ac5,\n                0x32b39da3,\n                0x79578f4f,\n                0xa57bb87b,\n                0xee9faa97,\n                0xc652d052,\n                0x8db6c2be,\n                0x519af58a,\n                0x1a7ee766,\n            },\n\n            {\n                0x0,\n                0x65673b46,\n                0xcace768c,\n                0xafa94dca,\n                0x4eedeb59,\n                0x2b8ad01f,\n                0x84239dd5,\n                0xe144a693,\n                0x9ddbd6b2,\n                0xf8bcedf4,\n                0x5715a03e,\n                0x32729b78,\n                0xd3363deb,\n                0xb65106ad,\n                0x19f84b67,\n                0x7c9f7021,\n            },\n\n            {\n                0x0,\n                0xe0c6ab25,\n                0x1afc500b,\n                0xfa3afb2e,\n                0x35f8a016,\n                0xd53e0b33,\n                0x2f04f01d,\n                0xcfc25b38,\n                0x6bf1402c,\n                0x8b37eb09,\n                0x710d1027,\n                0x91cbbb02,\n                0x5e09e03a,\n                0xbecf4b1f,\n                0x44f5b031,\n                0xa4331b14,\n            },\n\n            {\n                0x0,\n                0xd7e28058,\n                0x74b406f1,\n                0xa35686a9,\n                0xe9680de2,\n                0x3e8a8dba,\n                0x9ddc0b13,\n                0x4a3e8b4b,\n                0x9a11d85,\n                0xde439ddd,\n                0x7d151b74,\n                0xaaf79b2c,\n                0xe0c91067,\n                0x372b903f,\n                0x947d1696,\n                0x439f96ce,\n            },\n\n            {\n                0x0,\n                0x13423b0a,\n                0x26847614,\n                0x35c64d1e,\n                0x4d08ec28,\n                0x5e4ad722,\n                0x6b8c9a3c,\n                0x78cea136,\n                0x9a11d850,\n                0x8953e35a,\n                0xbc95ae44,\n                0xafd7954e,\n                0xd7193478,\n                0xc45b0f72,\n                0xf19d426c,\n                0xe2df7966,\n            },\n\n            {\n                0x0,\n                0xef52b6e1,\n                0x5d46b83,\n                0xea86dd62,\n                0xba8d706,\n                0xe4fa61e7,\n                0xe7cbc85,\n                0xe12e0a64,\n                0x1751ae0c,\n                0xf80318ed,\n                0x1285c58f,\n                0xfdd7736e,\n                0x1cf9790a,\n                0xf3abcfeb,\n                0x192d1289,\n                0xf67fa468,\n            },\n\n            {\n                0x0,\n                0x2ea35c18,\n                0x5d46b830,\n                0x73e5e428,\n                0xba8d7060,\n                0x942e2c78,\n                0xe7cbc850,\n                0xc9689448,\n                0xae6be681,\n                0x80c8ba99,\n                0xf32d5eb1,\n                0xdd8e02a9,\n                0x14e696e1,\n                0x3a45caf9,\n                0x49a02ed1,\n                0x670372c9,\n            },\n\n            {\n                0x0,\n                0x87a6cb43,\n                0xd43c90c7,\n                0x539a5b84,\n                0x730827cf,\n                0xf4aeec8c,\n                0xa734b708,\n                0x20927c4b,\n                0xe6104f9e,\n                0x61b684dd,\n                0x322cdf59,\n                0xb58a141a,\n                0x95186851,\n                0x12bea312,\n                0x4124f896,\n                0xc68233d5,\n            },\n\n            {\n                0x0,\n                0x1751997d,\n                0x2ea332fa,\n                0x39f2ab87,\n                0x5d4665f4,\n                0x4a17fc89,\n                0x73e5570e,\n                0x64b4ce73,\n                0xba8ccbe8,\n                0xaddd5295,\n                0x942ff912,\n                0x837e606f,\n                0xe7caae1c,\n                0xf09b3761,\n                0xc9699ce6,\n                0xde38059b,\n            },\n\n            {\n                0x0,\n                0xae689191,\n                0x87a02563,\n                0x29c8b4f2,\n                0xd4314c87,\n                0x7a59dd16,\n                0x539169e4,\n                0xfdf9f875,\n                0x73139f4f,\n                0xdd7b0ede,\n                0xf4b3ba2c,\n                0x5adb2bbd,\n                0xa722d3c8,\n                0x94a4259,\n                0x2082f6ab,\n                0x8eea673a,\n            },\n\n            {\n                0x0,\n                0xe6273e9e,\n                0x173f7b7d,\n                0xf11845e3,\n                0x2e7ef6fa,\n                0xc859c864,\n                0x39418d87,\n                0xdf66b319,\n                0x5cfdedf4,\n                0xbadad36a,\n                0x4bc29689,\n                0xade5a817,\n                0x72831b0e,\n                0x94a42590,\n                0x65bc6073,\n                0x839b5eed,\n            },\n\n            {\n                0x0,\n                0xb9fbdbe8,\n                0xa886b191,\n                0x117d6a79,\n                0x8a7c6563,\n                0x3387be8b,\n                0x22fad4f2,\n                0x9b010f1a,\n                0xcf89cc87,\n                0x7672176f,\n                0x670f7d16,\n                0xdef4a6fe,\n                0x45f5a9e4,\n                0xfc0e720c,\n                0xed731875,\n                0x5488c39d,\n            },\n\n            {\n                0x0,\n                0x44629f4f,\n                0x88c53e9e,\n                0xcca7a1d1,\n                0xcafb7b7d,\n                0x8e99e432,\n                0x423e45e3,\n                0x65cdaac,\n                0x4e87f0bb,\n                0xae56ff4,\n                0xc642ce25,\n                0x8220516a,\n                0x847c8bc6,\n                0xc01e1489,\n                0xcb9b558,\n                0x48db2a17,\n            },\n\n            {\n                0x0,\n                0x9d0fe176,\n                0xe16ec4ad,\n                0x7c6125db,\n                0x19ac8f1b,\n                0x84a36e6d,\n                0xf8c24bb6,\n                0x65cdaac0,\n                0x33591e36,\n                0xae56ff40,\n                0xd237da9b,\n                0x4f383bed,\n                0x2af5912d,\n                0xb7fa705b,\n                0xcb9b5580,\n                0x5694b4f6,\n            },\n\n            {\n                0x0,\n                0x66b23c6c,\n                0xcd6478d8,\n                0xabd644b4,\n                0x41b9f7f1,\n                0x270bcb9d,\n                0x8cdd8f29,\n                0xea6fb345,\n                0x8373efe2,\n                0xe5c1d38e,\n                0x4e17973a,\n                0x28a5ab56,\n                0xc2ca1813,\n                0xa478247f,\n                0xfae60cb,\n                0x691c5ca7,\n            },\n\n            {\n                0x0,\n                0xdd96d985,\n                0x605cb54b,\n                0xbdca6cce,\n                0xc0b96a96,\n                0x1d2fb313,\n                0xa0e5dfdd,\n                0x7d730658,\n                0x5a03d36d,\n                0x87950ae8,\n                0x3a5f6626,\n                0xe7c9bfa3,\n                0x9abab9fb,\n                0x472c607e,\n                0xfae60cb0,\n                0x2770d535,\n            },\n\n            {\n                0x0,\n                0xb407a6da,\n                0xb37e4bf5,\n                0x779ed2f,\n                0xbd8d91ab,\n                0x98a3771,\n                0xef3da5e,\n                0xbaf47c84,\n                0xa06a2517,\n                0x146d83cd,\n                0x13146ee2,\n                0xa713c838,\n                0x1de7b4bc,\n                0xa9e01266,\n                0xae99ff49,\n                0x1a9e5993,\n            },\n\n            {\n                0x0,\n                0x9ba54c6f,\n                0xec3b9e9f,\n                0x779ed2f0,\n                0x3063b7f,\n                0x98a37710,\n                0xef3da5e0,\n                0x7498e98f,\n                0x60c76fe,\n                0x9da93a91,\n                0xea37e861,\n                0x7192a40e,\n                0x50a4d81,\n                0x9eaf01ee,\n                0xe931d31e,\n                0x72949f71,\n            },\n\n            {\n                0x0,\n                0xc18edfc,\n                0x1831dbf8,\n                0x14293604,\n                0x3063b7f0,\n                0x3c7b5a0c,\n                0x28526c08,\n                0x244a81f4,\n                0x60c76fe0,\n                0x6cdf821c,\n                0x78f6b418,\n                0x74ee59e4,\n                0x50a4d810,\n                0x5cbc35ec,\n                0x489503e8,\n                0x448dee14,\n            },\n\n            {\n                0x0,\n                0xc18edfc0,\n                0x586cb9c1,\n                0x99e26601,\n                0xb0d97382,\n                0x7157ac42,\n                0xe8b5ca43,\n                0x293b1583,\n                0xbac3e145,\n                0x7b4d3e85,\n                0xe2af5884,\n                0x23218744,\n                0xa1a92c7,\n                0xcb944d07,\n                0x52762b06,\n                0x93f8f4c6,\n            },\n\n            {\n                0x0,\n                0xaef6c4cb,\n                0x869c8fd7,\n                0x286a4b1c,\n                0xd64819ef,\n                0x78bedd24,\n                0x50d49638,\n                0xfe2252f3,\n                0x77e1359f,\n                0xd917f154,\n                0xf17dba48,\n                0x5f8b7e83,\n                0xa1a92c70,\n                0xf5fe8bb,\n                0x2735a3a7,\n                0x89c3676c,\n            },\n\n            {\n                0x0,\n                0xefc26b3e,\n                0x4f5d03d,\n                0xeb37bb03,\n                0x9eba07a,\n                0xe629cb44,\n                0xd1e7047,\n                0xe2dc1b79,\n                0x13d740f4,\n                0xfc152bca,\n                0x172290c9,\n                0xf8e0fbf7,\n                0x1a3ce08e,\n                0xf5fe8bb0,\n                0x1ec930b3,\n                0xf10b5b8d,\n            },\n\n            {\n                0x0,\n                0x27ae81e8,\n                0x4f5d03d0,\n                0x68f38238,\n                0x9eba07a0,\n                0xb9148648,\n                0xd1e70470,\n                0xf6498598,\n                0xe6050901,\n                0xc1ab88e9,\n                0xa9580ad1,\n                0x8ef68b39,\n                0x78bf0ea1,\n                0x5f118f49,\n                0x37e20d71,\n                0x104c8c99,\n            },\n\n            {\n                0x0,\n                0x177b1443,\n                0x2ef62886,\n                0x398d3cc5,\n                0x5dec510c,\n                0x4a97454f,\n                0x731a798a,\n                0x64616dc9,\n                0xbbd8a218,\n                0xaca3b65b,\n                0x952e8a9e,\n                0x82559edd,\n                0xe634f314,\n                0xf14fe757,\n                0xc8c2db92,\n                0xdfb9cfd1,\n            },\n\n            {\n                0x0,\n                0xacc04271,\n                0x82f182a3,\n                0x2e31c0d2,\n                0xde920307,\n                0x72524176,\n                0x5c6381a4,\n                0xf0a3c3d5,\n                0x6655004f,\n                0xca95423e,\n                0xe4a482ec,\n                0x4864c09d,\n                0xb8c70348,\n                0x14074139,\n                0x3a3681eb,\n                0x96f6c39a,\n            },\n\n            {\n                0x0,\n                0xccaa009e,\n                0x4225077d,\n                0x8e8f07e3,\n                0x844a0efa,\n                0x48e00e64,\n                0xc66f0987,\n                0xac50919,\n                0xd3e51bb5,\n                0x1f4f1b2b,\n                0x91c01cc8,\n                0x5d6a1c56,\n                0x57af154f,\n                0x9b0515d1,\n                0x158a1232,\n                0xd92012ac,\n            },\n\n            {\n                0x0,\n                0x7cbb312b,\n                0xf9766256,\n                0x85cd537d,\n                0x299dc2ed,\n                0x5526f3c6,\n                0xd0eba0bb,\n                0xac509190,\n                0x533b85da,\n                0x2f80b4f1,\n                0xaa4de78c,\n                0xd6f6d6a7,\n                0x7aa64737,\n                0x61d761c,\n                0x83d02561,\n                0xff6b144a,\n            },\n\n            {\n                0x0,\n                0xa6770bb4,\n                0x979f1129,\n                0x31e81a9d,\n                0xf44f2413,\n                0x52382fa7,\n                0x63d0353a,\n                0xc5a73e8e,\n                0x33ef4e67,\n                0x959845d3,\n                0xa4705f4e,\n                0x20754fa,\n                0xc7a06a74,\n                0x61d761c0,\n                0x503f7b5d,\n                0xf64870e9,\n            },\n\n            {\n                0x0,\n                0x67de9cce,\n                0xcfbd399c,\n                0xa863a552,\n                0x440b7579,\n                0x23d5e9b7,\n                0x8bb64ce5,\n                0xec68d02b,\n                0x8816eaf2,\n                0xefc8763c,\n                0x47abd36e,\n                0x20754fa0,\n                0xcc1d9f8b,\n                0xabc30345,\n                0x3a0a617,\n                0x647e3ad9,\n            },\n\n            {\n                0x0,\n                0xcb5cd3a5,\n                0x4dc8a10b,\n                0x869472ae,\n                0x9b914216,\n                0x50cd91b3,\n                0xd659e31d,\n                0x1d0530b8,\n                0xec53826d,\n                0x270f51c8,\n                0xa19b2366,\n                0x6ac7f0c3,\n                0x77c2c07b,\n                0xbc9e13de,\n                0x3a0a6170,\n                0xf156b2d5,\n            },\n\n            {\n                0x0,\n                0x3d6029b,\n                0x7ac0536,\n                0x47a07ad,\n                0xf580a6c,\n                0xc8e08f7,\n                0x8f40f5a,\n                0xb220dc1,\n                0x1eb014d8,\n                0x1d661643,\n                0x191c11ee,\n                0x1aca1375,\n                0x11e81eb4,\n                0x123e1c2f,\n                0x16441b82,\n                0x15921919,\n            },\n\n            {\n                0x0,\n                0x3d6029b0,\n                0x7ac05360,\n                0x47a07ad0,\n                0xf580a6c0,\n                0xc8e08f70,\n                0x8f40f5a0,\n                0xb220dc10,\n                0x30704bc1,\n                0xd106271,\n                0x4ab018a1,\n                0x77d03111,\n                0xc5f0ed01,\n                0xf890c4b1,\n                0xbf30be61,\n                0x825097d1,\n            },\n\n            {\n                0x0,\n                0x60e09782,\n                0xc1c12f04,\n                0xa121b886,\n                0x58f35849,\n                0x3813cfcb,\n                0x9932774d,\n                0xf9d2e0cf,\n                0xb1e6b092,\n                0xd1062710,\n                0x70279f96,\n                0x10c70814,\n                0xe915e8db,\n                0x89f57f59,\n                0x28d4c7df,\n                0x4834505d,\n            },\n\n            {\n                0x0,\n                0xb8bc6765,\n                0xaa09c88b,\n                0x12b5afee,\n                0x8f629757,\n                0x37def032,\n                0x256b5fdc,\n                0x9dd738b9,\n                0xc5b428ef,\n                0x7d084f8a,\n                0x6fbde064,\n                0xd7018701,\n                0x4ad6bfb8,\n                0xf26ad8dd,\n                0xe0df7733,\n                0x58631056,\n            },\n\n            {\n                0x0,\n                0x5019579f,\n                0xa032af3e,\n                0xf02bf8a1,\n                0x9b14583d,\n                0xcb0d0fa2,\n                0x3b26f703,\n                0x6b3fa09c,\n                0xed59b63b,\n                0xbd40e1a4,\n                0x4d6b1905,\n                0x1d724e9a,\n                0x764dee06,\n                0x2654b999,\n                0xd67f4138,\n                0x866616a7,\n            },\n\n            {\n                0x0,\n                0x1c26a37,\n                0x384d46e,\n                0x246be59,\n                0x709a8dc,\n                0x6cbc2eb,\n                0x48d7cb2,\n                0x54f1685,\n                0xe1351b8,\n                0xfd13b8f,\n                0xd9785d6,\n                0xc55efe1,\n                0x91af964,\n                0x8d89353,\n                0xa9e2d0a,\n                0xb5c473d,\n            },\n\n            {\n                0x0,\n                0x1c26a370,\n                0x384d46e0,\n                0x246be590,\n                0x709a8dc0,\n                0x6cbc2eb0,\n                0x48d7cb20,\n                0x54f16850,\n                0xe1351b80,\n                0xfd13b8f0,\n                0xd9785d60,\n                0xc55efe10,\n                0x91af9640,\n                0x8d893530,\n                0xa9e2d0a0,\n                0xb5c473d0,\n            },\n\n            {\n                0x0,\n                0x191b3141,\n                0x32366282,\n                0x2b2d53c3,\n                0x646cc504,\n                0x7d77f445,\n                0x565aa786,\n                0x4f4196c7,\n                0xc8d98a08,\n                0xd1c2bb49,\n                0xfaefe88a,\n                0xe3f4d9cb,\n                0xacb54f0c,\n                0xb5ae7e4d,\n                0x9e832d8e,\n                0x87981ccf,\n            },\n\n            {\n                0x0,\n                0x4ac21251,\n                0x958424a2,\n                0xdf4636f3,\n                0xf0794f05,\n                0xbabb5d54,\n                0x65fd6ba7,\n                0x2f3f79f6,\n                0x3b83984b,\n                0x71418a1a,\n                0xae07bce9,\n                0xe4c5aeb8,\n                0xcbfad74e,\n                0x8138c51f,\n                0x5e7ef3ec,\n                0x14bce1bd,\n            },\n\n            {\n                0x0,\n                0x77073096,\n                0xee0e612c,\n                0x990951ba,\n                0x76dc419,\n                0x706af48f,\n                0xe963a535,\n                0x9e6495a3,\n                0xedb8832,\n                0x79dcb8a4,\n                0xe0d5e91e,\n                0x97d2d988,\n                0x9b64c2b,\n                0x7eb17cbd,\n                0xe7b82d07,\n                0x90bf1d91,\n            },\n\n            {\n                0x0,\n                0x1db71064,\n                0x3b6e20c8,\n                0x26d930ac,\n                0x76dc4190,\n                0x6b6b51f4,\n                0x4db26158,\n                0x5005713c,\n                0xedb88320,\n                0xf00f9344,\n                0xd6d6a3e8,\n                0xcb61b38c,\n                0x9b64c2b0,\n                0x86d3d2d4,\n                0xa00ae278,\n                0xbdbdf21c,\n            },\n        };\n\n        const int num_nibbles_parallel = 64;\n\n        // this section of code should be on the hardware accelerator\n        const int num_sections =\n            accessor_isz /\n            (num_nibbles_parallel / 2);  // how many loop iterations\n\n        unsigned int result = ~0;\n\n        char_arr_32 input_data;\n\n        for (int i = 0; i < num_sections; i++) { // Iterate over 32 byte sections)\n          unsigned int result_update_odd = 0;\n          unsigned int result_update_even = 0;\n\n          // The input file data is read by the LZ kernel and transferred here\n          // via a pipe.\n          input_data = acc_lz_to_crc_channel_array::PipeAt<engineID>::read();\n\n          // which 4 bit chunk within the section -- this loop can be unrolled, the\n          // total update for the crc is the xor of the updates from the nibbles\n          #pragma unroll\n          for (int nib = 0; nib < num_nibbles_parallel; nib++) { // Iterate through the 32-bytes in this section\n\n            unsigned char this_input_nibble =\n                input_data.arr[nib / 2] >> (4 * (nib % 2));\n\n            unsigned char this_result_nibble =\n                (nib < 8) ? (result >> (4 * nib)) : 0;\n            unsigned char this_table_index =\n                this_input_nibble ^ this_result_nibble;\n            if (nib % 2) {\n              result_update_odd ^= table64[nib][this_table_index & 0xf];\n            } else {\n              result_update_even ^= table64[nib][this_table_index & 0xf];\n            }\n          }\n          result = result_update_odd ^ result_update_even;\n        }\n\n        // Read and discard final data\n        input_data = acc_lz_to_crc_channel_array::PipeAt<engineID>::read();\n\n        accresult_crc[iter] = ~result;\n      }\n    });\n  });\n\n  return e;\n}\n\ntemplate <int engineID>\nclass LZReduction;\ntemplate <int engineID, int BatchSize, typename... PtrTypes>\nevent SubmitLZReduction(queue &q, size_t block_size, bool last_block,\n                        std::vector<event> &depend_on,\n                        PtrTypes... ptrs) {\n  event e = q.submit([&](handler &h) {\n    auto accessor_isz = block_size;\n\n    // Temporarily remove event dependences to work around a bug in 2024.2\n    // This is safe on FPGA because invocations of the same kernel are \n    // serialized for non-pipelined kernels\n    // Note: this is not portable\n    //if (!depend_on.empty()) {\n    //  h.depends_on(depend_on[kLZReductionIndex]);\n    //}\n\n    h.single_task<LZReduction<engineID>>([=]() [[intel::kernel_args_restrict]] {\n      // Unpack the ptrs parameter pack and grab all of the pointers, annotating\n      // them as USM host pointers.\n      // To avoid calling the default constructors and having two stores to\n      // 'host_pibuf' (and therefore forcing it to a memory), we can create\n      // an initializer list by expanding our pack. It's the same logic as in\n      // SubmitGzipTasksHelper(); everything to the left of '...' is expanded\n      // for each value in ptrs.\n\n      sycl::ext::intel::host_ptr<char> host_pibuf[BatchSize];\n      Unroller<0, BatchSize>::step(\n          [&](auto i) { host_pibuf[i] = sycl::ext::intel::host_ptr<char>(get<i>(ptrs...)); });\n\n      // See comments at top of file, regarding batching\n      [[intel::disable_loop_pipelining]] for (int iter = 0;\n                                                  iter < BatchSize; iter++) {\n        const int iter_masked =\n            iter % BatchSize;  // Hint to the compiler that the access to\n                               // host_pibuf is bounded.\n        sycl::ext::intel::host_ptr<char> acc_pibuf =\n            host_pibuf[iter_masked];  // Grab new host pointer on each iteration\n                                      // of the batch loop\n\n        //-------------------------------------\n        //   Hash Table(s)\n        //-------------------------------------\n\n        [[intel::singlepump]] [[intel::numbanks(kVec)]] [\n            [intel::max_replicates(kVec)]] struct {\n          unsigned char s[kLen];\n        } dictionary[kDepth][kVec];\n\n        [[intel::singlepump]] [[intel::numbanks(kVec)]] [\n            [intel::max_replicates(\n                kVec)]] unsigned int dict_offset[kDepth][kVec];\n\n        // Initialize history to empty.\n        for (int i = 0; i < kDepth; i++) {\n          Unroller<0, kVec>::step([&](int k) { dict_offset[i][k] = 0; });\n        }\n\n        // This is the window of data on which we look for matches\n        // We fetch twice our data size because we have kVec offsets\n        unsigned char current_window[kVecX2];\n\n        // This is the window of data on which we look for matches\n        // We fetch twice our data size because we have kVec offsets\n        unsigned char compare_window[kLen][kVec][kVec];\n        // kVec bytes per dict----------|    |   |\n        // kVec dictionaries-----------------|   |\n        // one for each curr win offset----------|\n\n        // load offset into these arrays\n        unsigned int compare_offset[kVec][kVec];\n        // one per kVec bytes----------|     |\n        // one for each compwin--------------|\n\n        // Initialize input stream position\n        unsigned int inpos_minus_vec_div_16 = 0;\n\n        // this is ceiling of (insize-kVec)/16, original comparison was\n        // inpos < insize, now inpos is carried as (inpos-kVec)/16 so this is\n        // what we compare to\n        unsigned int insize_compare = (accessor_isz) / kVec;\n\n        int ctr = insize_compare - 1;\n\n        char first_valid_pos = 0;\n\n        struct DistLen dist_offs_data;\n\n        size_t inpos = 0;\n\n        char_arr_32 input_data; // Assumes kVec = 16 because CRC expects 2 x 16 bytes.\n        bool crc_ch_load_upper = true;  // A flag used to form double-wide words to send to the CRC kernel.\n\n        // load in new data\n        struct LzInput in;\n        Unroller<0, kVec>::step([&](int i) {\n          in.data[i] = acc_pibuf[inpos++];  // Reads 16 bytes, just one time.\n          input_data.arr[i] =\n              in.data[i];  // Send a copy of the data to the CRC kernel, through\n                           // a pipe. input_data is used to gang the data\n                           // together into a wider word.\n        });\n\n        Unroller<0, kVec>::step(\n            [&](int i) { current_window[i + kVec] = in.data[i]; });\n\n        do {\n          //-----------------------------\n          // Prepare current window\n          //-----------------------------\n\n          // shift current window\n          Unroller<0, kVec>::step(\n              [&](int i) { current_window[i] = current_window[i + kVec]; });\n\n          // load in new data\n          Unroller<0, kVec>::step([&](int i) {\n            in.data[i] = acc_pibuf[inpos++];\n            input_data.arr[16 * (int)crc_ch_load_upper + i] = in.data[i];\n          });\n\n          // CRC kernel expects a wider word.\n          if (crc_ch_load_upper) {  // After both halves are loaded, write the\n                                    // full struct to the channel\n            acc_lz_to_crc_channel_array::PipeAt<engineID>::write(input_data);\n          }\n\n          // The state of this signal indicates the next half to be loaded.\n          // i.e. if true, upper will be loaded next.\n          crc_ch_load_upper = !crc_ch_load_upper;\n\n          Unroller<0, kVec>::step(\n              [&](int i) { current_window[kVec + i] = in.data[i]; });\n\n          //-----------------------------\n          // Compute hash\n          //-----------------------------\n\n          unsigned short hash[kVec];\n\n          Unroller<0, kVec>::step([&](int i) {\n            hash[i] = (current_window[i] ^ (current_window[i + 1] << 6) ^\n                       (current_window[i + 2] << 2) ^ current_window[i + 3]) &\n                      kHashMask;\n          });\n\n          //-----------------------------\n          // Dictionary look-up\n          //-----------------------------\n\n          // loop over kVec compare windows, each has a different hash\n          Unroller<0, kVec>::step([&](int i) {\n            // loop over all kVec bytes\n            Unroller<0, kLen>::step([&](int j) {\n              Unroller<0, kVec>::step([&](int k) {\n                compare_window[k][j][i] = dictionary[hash[i]][j].s[k];\n              });\n            });\n          });\n\n          // loop over compare windows\n          Unroller<0, kVec>::step([&](int i) {\n            Unroller<0, kLen>::step([&](int j) {\n              // loop over frames in this compare window\n              // (they come from different dictionaries)\n              compare_offset[j][i] = dict_offset[hash[i]][j];\n            });\n          });\n\n          //-----------------------------\n          // Dictionary update\n          //-----------------------------\n\n          // loop over different dictionaries to store different frames\n          // store one frame per dictionary\n          // loop over kVec bytes to store\n          Unroller<0, kLen>::step([&](int i) {\n            Unroller<0, kVec>::step([&](int j) {\n              // store actual bytes\n              dictionary[hash[i]][i].s[j] = current_window[i + j];\n            });\n          });\n\n          Unroller<0, kVec>::step([&](int i) {\n            // loop over kVec different dictionaries and write one word to each\n            dict_offset[hash[i]][i] =\n                (inpos_minus_vec_div_16 << 4) |\n                i;  // inpos - kVec + 0, we know that inpos - kVec has 0 as the\n                    // 4 lower bits so really just concatenate\n          });\n\n          //-----------------------------\n          // Match search\n          //-----------------------------\n\n          // arrays to store length, best length etc..\n          unsigned char length[kVec];\n          bool done[kVec];\n          char best_length[kVec];\n          unsigned int best_offset[kVec];\n\n          // initialize best_length\n          Unroller<0, kVec>::step([&](int i) {\n            best_length[i] = 0;\n            best_offset[i] = 0;\n          });\n\n          // loop over each comparison window frame\n          // one comes from each dictionary\n          Unroller<0, kVec>::step([&](int i) {\n            // initialize length and done\n            Unroller<0, kVec>::step([&](int l) {\n              length[l] = 0;\n              done[l] = 0;\n            });\n\n            // loop over each current window\n            Unroller<0, kVec>::step([&](int j) {\n              // loop over each char in the current window\n              // and corresponding char in comparison window\n              Unroller<0, kLen>::step([&](int k) {\n                bool comp = current_window[k + j] == compare_window[k][i][j] &&\n                            !done[j];\n                length[j] += comp;\n                done[j] = !comp;\n              });\n            });\n\n            // Check if this the best length\n            Unroller<0, kVec>::step([&](int m) {\n              bool update_best =\n                  (length[m] > best_length[m]) && (compare_offset[i][m] != 0) &&\n                  (((inpos_minus_vec_div_16 << kVecPow) | (i & (kVec - 1))) -\n                       (compare_offset[i][m]) <\n                   kMaxDistance);\n\n              unsigned int new_offset =\n                  (((inpos_minus_vec_div_16 << kVecPow) | (m & (kVec - 1))) &\n                   0x7ffff) -\n                  ((compare_offset[i][m] & 0x7ffff));\n\n              // Reconsider if new_offset is bigger than current offset, might\n              // take more bytes to encode\n              update_best = update_best && (length[m] == best_length[m]) &&\n                                    (new_offset > best_offset[m])\n                                ? false\n                                : update_best;\n\n              best_offset[m] = (update_best ? new_offset : best_offset[m]) &\n                               0x7ffff;  // 19 bits is sufficient\n\n              best_length[m] = (update_best ? length[m] : best_length[m]) &\n                               0x1f;  // 5 bits is sufficient\n            });\n          });\n\n          //-----------------------------\n          // Filter matches step 1\n          //-----------------------------\n\n          // remove matches with offsets that are <= 0: this means they're\n          // self-matching or didn't match and keep only the matches that, when\n          // encoded, take fewer bytes than the actual match length\n          Unroller<0, kVec>::step([&](int i) {\n            best_length[i] = (((best_length[i] & 0x1f) >= 3) &&\n                                      ((best_offset[i]) < kMaxDistance)\n                                  ? best_length[i]\n                                  : 0) &\n                             0x1f;  // 5 bits is sufficient\n\n            // Second level filter - remove matches with len 3, greater than\n            // kTooFar\n            best_length[i] =\n                (((best_length[i] & 0x1f) == 3) && ((best_offset[i]) > kTooFar)\n                     ? 0\n                     : best_length[i]) &\n                0x1f;  // 5 bits is sufficient\n                       // don't emmit matches for last iteration as some of the\n                       // second part of the window might be undefined\n            if (ctr == 0) best_length[i] = 0;\n          });\n\n          //-----------------------------\n          // Assign first_valid_pos\n          //-----------------------------\n\n          // first_valid_pos is loop-carried, and tricky to compute.  So first\n          // compute it speculatively in parallel for every possible value of\n          // the previous first_valid_pos.\n          char first_valid_pos_speculative[kVec];\n\n          Unroller<0, kVec>::step([&](int guess) {\n            unsigned char next_match_search = guess;\n            Unroller<0, kVec>::step([&](int i) {\n              unsigned int len = best_length[i];\n\n              // Skip to the next match\n              next_match_search = i >= next_match_search && len > 0\n                                      ? i + len\n                                      : next_match_search;\n            });\n\n            first_valid_pos_speculative[guess] =\n                next_match_search - kVec > 0 ? next_match_search - kVec : 0;\n          });\n\n          // For kVec=16 (the largest currently supported), this should be a\n          // 16:1 mux, which is 2 6LUTs deep.  For larger kVec, it will be\n          // worse.\n          unsigned char current_valid_pos = first_valid_pos;\n          first_valid_pos =\n              first_valid_pos_speculative[first_valid_pos & (kVec - 1)] &\n              (kVec -\n               1);  // first_valid_pos only needs 4 bits, make this explicit\n\n          // greedy match selection\n          Unroller<0, (kVec)>::step([&](int i) {\n            unsigned int len = best_length[i];\n            best_length[i] = i < current_valid_pos ? -1 : best_length[i];\n            // Skip to the next match\n            current_valid_pos =\n                i >= current_valid_pos && len > 0 ? i + len : current_valid_pos;\n          });\n\n          //-----------------------------\n          // Setup LZ dist/len pairs to push to Huffman encode kernel\n          //-----------------------------\n\n          Unroller<0, kVec>::step([&](int i) {\n            dist_offs_data.data[i] = 0;\n            dist_offs_data.len[i] = -1;\n            dist_offs_data.dist[i] = -1;\n            if (best_length[i] >= 0) {\n              dist_offs_data.data[i] = current_window[i];\n              dist_offs_data.len[i] = best_length[i];\n              dist_offs_data.dist[i] = best_offset[i];\n            }\n          });\n\n          // acc_dist_channel::write(dist_offs_data);\n          acc_dist_channel_array::PipeAt<engineID>::write(dist_offs_data);\n\n          // increment input position\n          inpos_minus_vec_div_16++;\n          ctr--;\n\n        } while (ctr >= 0);\n\n        // If crc_ch_load_upper==true, then upper was to be loaded next, meaning\n        // lower has been loaded. So write out this partial struct.\n        if (crc_ch_load_upper) {\n          acc_lz_to_crc_channel_array::PipeAt<engineID>::write(input_data);\n        }\n\n        const char lasti = accessor_isz - (accessor_isz & ~(kVec - 1));\n        const char firstpos = first_valid_pos;\n        Unroller<0, kVec>::step([&](unsigned char i) {\n          dist_offs_data.data[i] = 0;\n          dist_offs_data.len[i] = -1;\n          dist_offs_data.dist[i] = -1;\n        });\n\n        Unroller<0, kVec>::step([&](unsigned char i) {\n          bool pred =\n              ((i - firstpos) < (lasti - firstpos)) && ((i - firstpos) >= 0);\n          dist_offs_data.data[i] = pred ? current_window[i + kVec] : 0;\n          dist_offs_data.len[i] = pred ? 0 : -1;\n        });\n\n        acc_dist_channel_last_array::PipeAt<engineID>::write(dist_offs_data);\n      }\n    });\n  });\n\n  return e;\n}\n\ntemplate <int engineID>\nclass StaticHuffman;\ntemplate <int engineID, int BatchSize, typename... PtrTypes>\nevent SubmitStaticHuffman(queue &q, size_t block_size,\n                          struct GzipOutInfo *gzip_out_buf, bool last_block,\n                          std::vector<event> &depend_on,\n                          PtrTypes... ptrs) {\n  event e = q.submit([&](handler &h) {\n    // Temporarily remove event dependences to work around a bug in 2024.2\n    // This is safe on FPGA because invocations of the same kernel are \n    // serialized for non-pipelined kernels\n    // Note: this is not portable\n    //if (!depend_on.empty()) {\n    //  h.depends_on(depend_on[kStaticHuffmanIndex]);\n    //}\n\n    h.single_task<StaticHuffman<engineID>>([=]() [[intel::kernel_args_restrict]] {\n\n      // See comments in SubmitLZReduction, where the same parameter unpacking\n      // is done.\n      sycl::ext::intel::host_ptr<char> host_pobuf[BatchSize];\n      Unroller<0, BatchSize>::step(\n          [&](auto i) { host_pobuf[i] = sycl::ext::intel::host_ptr<char>(get<i>(ptrs...)); });\n\n      auto accessor_isz = block_size;\n\n      sycl::ext::intel::host_ptr<GzipOutInfo> acc_gzip_out(gzip_out_buf);\n\n      auto acc_eof = last_block ? 1 : 0;\n\n      // See comments at top of file regarding batching.\n      [[intel::disable_loop_pipelining]]\n      for (int iter=0; iter < BatchSize; iter++) {\n        sycl::ext::intel::host_ptr<char> accessor_output = host_pobuf[iter % BatchSize];\n\n        unsigned int leftover[kVec] = {0};\n        Unroller<0, kVec>::step([&](int i) { leftover[i] = 0; });\n\n        unsigned short leftover_size = 0;\n\n        unsigned int outpos_huffman = 0;\n\n        int ctr = ((accessor_isz) / kVec) + 2;\n        int odx = 0;\n\n        // Add the gzip start block marker. Assumes static huffman trees.\n        leftover_size = 3;\n        leftover[0] = ((kStaticTrees << 1) + (acc_eof));\n\n        do {\n          struct DistLen in;\n          // init the input structure for the gzip end block marker.\n          // this is the very last data block to be encoded and written.\n          Unroller<0, kVec>::step([&](int i) {\n            in.len[i] = -1;\n            in.dist[i] = -1;\n            in.data[i] = 0;\n          });\n          in.len[0] = ctr == 1 ? -3 : -1;\n          in.data[0] = 0;\n\n          in =\n              ctr > 2\n                  ? acc_dist_channel_array::PipeAt<engineID>::read()\n                  : (ctr == 2\n                         ? acc_dist_channel_last_array::PipeAt<engineID>::read()\n                         : in);\n\n          struct HuffmanOutput outdata;\n          outdata.write = HufEnc(in.len, in.dist, in.data, outdata.data,\n                                 leftover, &leftover_size);\n\n          // prevent out of bounds write\n          if (((ctr == 0) || outdata.write) && (odx < accessor_isz)) {\n            Unroller<0, kVec * sizeof(unsigned int)>::step([&](int i) {\n              accessor_output[odx + i] =\n                  (ctr == 0) ? (unsigned char)(leftover[(i >> 2) & 0xf] >>\n                                               ((i & 3) << 3))\n                             : (unsigned char)(outdata.data[(i >> 2) & 0xf] >>\n                                               ((i & 3) << 3));\n            });\n          }\n\n          outpos_huffman = outdata.write ? outpos_huffman + 1 : outpos_huffman;\n          odx += outdata.write ? (sizeof(unsigned int) << kVecPow) : 0;\n\n        } while (ctr--);\n\n        // Store summary values from lz and huffman\n        acc_gzip_out[iter].compression_sz =\n            (outpos_huffman * sizeof(unsigned int) * kVec) +\n            (leftover_size + 7) / 8;\n      }\n    });\n  });\n\n  return e;\n}\n\n// Helper function to launch the individual kernels that comprise the gzip\n// engine. Templated on engineID to allow creation of multiple engines.\n// Templated on BatchSize to specify, at compile time, the batch size for which\n// hardware should be built.\n// And templated on a pack of PtrTypes (which we know will be char*).\ntemplate <int engineID, int BatchSize, std::size_t... Indices>\nstd::vector<event> SubmitGzipTasksHelper(queue &q, size_t block_size,\n                                         struct GzipOutInfo *gzip_out_buf,\n                                         uint32_t *result_crc, bool last_block,\n                                         std::vector<event> &depend_on,\n                                         std::array<char *, BatchSize> in_ptrs,\n                                         std::array<char *, BatchSize> out_ptrs,\n                                         std::index_sequence<Indices...>) {\n  // A parameter pack is used for passing a batch of pointers (i.e. pointers to\n  // the input/output buffers in host-memory).\n\n  // submit the LZReductionKernel\n  // The '...' operator essentially says this: Take the pattern connected\n  // to the '...' (in this case, 'in_ptrs[Indices]') and replicate it\n  // for each value of the pack (Indices).\n  // This means the call quite literally expands to:\n  //    SubmitLZReduction<BatchSize>(<other args>, in_ptrs[0], in_ptrs[1], ...);\n  event e_LZReduction = SubmitLZReduction<engineID,BatchSize>(q,\n                                                     block_size,\n                                                     last_block,\n                                                     depend_on,\n                                                     in_ptrs[Indices]...\n                                                     );\n\n  event e_CRC = SubmitCRC<engineID,BatchSize>(q,\n                                    block_size,\n                                    result_crc,\n                                    depend_on);\n\n  \n  event e_StaticHuffman = SubmitStaticHuffman<engineID,BatchSize>(q,\n                                                         block_size,\n                                                         gzip_out_buf,\n                                                         last_block,\n                                                         depend_on,\n                                                         out_ptrs[Indices]...\n                                                         );\n\n  return {e_CRC, e_LZReduction, e_StaticHuffman};\n}\n\n//template <int BatchSize>\nstd::vector<event> SubmitGzipTasks(queue &q, size_t block_size,\n                                   struct GzipOutInfo *gzip_out_buf,\n                                   uint32_t *result_crc, bool last_block,\n                                   std::vector<event> depend_on,\n                                   std::array<char *, BATCH_SIZE> in_ptrs,\n                                   std::array<char *, BATCH_SIZE> out_ptrs,\n                                   size_t engineID) {\n  // A parameter pack is used for passing a batch of pointers (i.e. pointers to\n  // the input/output buffers in host-memory).\n\n  // This call to the SubmitGzipTasksHelper function creates the integer\n  // sequence that we will use to access the input and output pointers.\n  // This function expands to, quite literally, the following (assuming):\n  //    SubmitGzipTasksHelper<BatchSize>(<other_args>, in_ptrs, out_ptrs,\n  //        0, 1, 2, 3, 4, ..., BatchSize-1);\n\n  // Statically declare the engines so that the hardware is created for them.\n  // But at run time, the host can dynamically select which engine(s) to use via\n  // engineID.\n\n  if (engineID == 0) {\n    return SubmitGzipTasksHelper<0, BATCH_SIZE>(\n        q, block_size, gzip_out_buf, result_crc, last_block, depend_on, in_ptrs,\n        out_ptrs, std::make_index_sequence<BATCH_SIZE>{});\n  }\n#if NUM_ENGINES > 1\n  if (engineID == 1) {\n    return SubmitGzipTasksHelper<1, BATCH_SIZE>(\n        q, block_size, gzip_out_buf, result_crc, last_block, depend_on, in_ptrs,\n        out_ptrs, std::make_index_sequence<BATCH_SIZE>{});\n  }\n#endif\n\n  // Default\n  return SubmitGzipTasksHelper<0, BATCH_SIZE>(\n      q, block_size, gzip_out_buf, result_crc, last_block, depend_on, in_ptrs,\n      out_ptrs, std::make_index_sequence<BATCH_SIZE>{});\n}\n\n"
    },
    {
        "label": "gzipkernel_ll.hpp",
        "data": "#ifndef __GZIPKERNEL_H__\n#define __GZIPKERNEL_H__\n#pragma once\n\n#include <sycl/sycl.hpp>\n#include \"kernels.hpp\"\n\nusing namespace sycl;\n\n//extern \"C\" \nstd::vector<event> SubmitGzipTasks(queue &q, size_t block_size,\n                                   struct GzipOutInfo *gzip_out_buf,\n                                   uint32_t *result_crc, bool last_block,\n                                   std::vector<event> depend_on,\n                                   std::array<char *, BATCH_SIZE> in_ptrs,\n                                   std::array<char *, BATCH_SIZE> out_ptrs,\n                                   size_t engineID);\n\n#endif  //__GZIPKERNEL_H__\n"
    },
    {
        "label": "gzip_ll.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <chrono>\n#include <fstream>\n#include <string>\n\n#include \"CompareGzip.hpp\"\n#include \"WriteGzip.hpp\"\n#include \"crc32.hpp\"\n#include \"gzipkernel_ll.hpp\"\n#include \"kernels.hpp\"\n\n#include \"exception_handler.hpp\"\n\n\nusing namespace sycl;\n\n// The minimum file size of a file to be compressed.\n// Any filesize less than this results in an error.\nconstexpr int minimum_filesize = kVec + 1;\n\nconst int N_BUFFERING = 2;  // Number of sets of I/O buffers to\n                            // allocate, for the purpose of overlapping kernel\n                            // execution with buffer preparation.\n\n\nbool help = false;\n\nint CompressFile(queue &q, std::string &input_file,\n                 std::vector<std::string> outfilenames, int iterations,\n                 bool report);\n\nvoid Help(void) {\n  // Command line arguments.\n  // gzip [options] filetozip [options]\n  // -h,--help                    : help\n\n  // future options?\n  // -p,performance : output perf metrics\n  // -m,maxmapping=#  : maximum mapping size\n\n  std::cout << \"gzip filename [options]\\n\";\n  std::cout << \"  -h,--help                                : this help text\\n\";\n  std::cout\n      << \"  -o=<filename>,--output-file=<filename>   : specify output file\\n\";\n}\n\nbool FindGetArg(std::string &arg, const char *str, int defaultval, int *val) {\n  std::size_t found = arg.find(str, 0, strlen(str));\n  if (found != std::string::npos) {\n    int value = atoi(&arg.c_str()[strlen(str)]);\n    *val = value;\n    return true;\n  }\n  return false;\n}\n\nconstexpr int kMaxStringLen = 40;\n\nbool FindGetArgString(std::string &arg, const char *str, char *str_value,\n                      size_t maxchars) {\n  std::size_t found = arg.find(str, 0, strlen(str));\n  if (found != std::string::npos) {\n    const char *sptr = &arg.c_str()[strlen(str)];\n    for (int i = 0; i < maxchars - 1; i++) {\n      char ch = sptr[i];\n      switch (ch) {\n        case ' ':\n        case '\\t':\n        case '\\0':\n          str_value[i] = 0;\n          return true;\n          break;\n        default:\n          str_value[i] = ch;\n          break;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nsize_t SyclGetExecTimeNs(event e) {\n  size_t start_time =\n      e.get_profiling_info<info::event_profiling::command_start>();\n  size_t end_time = e.get_profiling_info<info::event_profiling::command_end>();\n  return (end_time - start_time);\n}\n\nint main(int argc, char *argv[]) {\n  std::string infilename = \"\";\n\n  std::vector<std::string> outfilenames(kNumEngines);\n\n  char str_buffer[kMaxStringLen] = {0};\n\n  // Check the number of arguments specified\n  if (argc != 3) {\n    std::cerr << \"Incorrect number of arguments. Correct usage: \" << argv[0]\n              << \" <input-file> -o=<output-file>\\n\";\n    return 1;\n  }\n\n  for (int i = 1; i < argc; i++) {\n    if (argv[i][0] == '-') {\n      std::string sarg(argv[i]);\n      if (std::string(argv[i]) == \"-h\") {\n        help = true;\n      }\n      if (std::string(argv[i]) == \"--help\") {\n        help = true;\n      }\n\n      FindGetArgString(sarg, \"-o=\", str_buffer, kMaxStringLen);\n      FindGetArgString(sarg, \"--output-file=\", str_buffer, kMaxStringLen);\n    } else {\n      infilename = std::string(argv[i]);\n    }\n  }\n\n  if (help) {\n    Help();\n    return 1;\n  }\n\n  try {\n\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    auto prop_list = property_list{property::queue::enable_profiling()};\n    queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<info::device::name>().c_str() \n              << std::endl;\n\n    if (infilename == \"\") {\n      std::cout << \"Must specify a filename to compress\\n\\n\";\n      Help();\n      return 1;\n    }\n\n    // next, check valid and acceptable parameter ranges.\n    // if output filename not set, use the default\n    // name, else use the name specified by the user\n    outfilenames[0] = std::string(infilename) + \".gz\";\n    if (strlen(str_buffer)) {\n      outfilenames[0] = std::string(str_buffer);\n    }\n    for (size_t i = 1; i < kNumEngines; i++) {\n      // Filenames will be of the form outfilename, outfilename2, outfilename3\n      // etc.\n      outfilenames[i] = outfilenames[0] + std::to_string(i + 1);\n    }\n\n    std::cout << \"Launching Low-Latency GZIP application with \" << kNumEngines\n              << \" engines\\n\";\n\n#ifdef FPGA_EMULATOR\n    CompressFile(q, infilename, outfilenames, 10, true);\n#elif FPGA_SIMULATOR\n    CompressFile(q, infilename, outfilenames, 2, true);\n#else\n    // warmup run - use this run to warmup accelerator. There are some steps in\n    // the runtime that are only executed on the first kernel invocation but not\n    // on subsequent invocations. So execute all that stuff here before we\n    // measure performance (in the next call to CompressFile().\n    CompressFile(q, infilename, outfilenames, 1, false);\n    // profile performance\n    CompressFile(q, infilename, outfilenames, 200, true);\n#endif\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n      std::cerr << \"If you are targeting the FPGA simulator, compile with \"\n                   \"-DFPGA_SIMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n  return 0;\n}\n\nstruct KernelInfo {\n  struct GzipOutInfo\n      *gzip_out_buf;      // Contains meta data about the compressed file\n  uint32_t *current_crc;  // Partial CRC of the input file\n\n  char **pobuf_ptr_array;  // Array of pointers to input files to be compressed\n  char **pibuf_ptr_array;  // Corresponding array of pointers to output from the\n                           // gzip engine (the compressed results)\n\n  char *pref_buffer;  // Original input copy of file to compress\n\n  size_t input_size;\n  size_t output_size;\n  bool last_block;\n\n  std::vector<event> kernel_event;  // Events for the execution of the kernels\n                                    // that comprise the GZIP engine\n};\n\n// returns 0 on success, otherwise a non-zero failure code.\nint CompressFile(queue &q, std::string &input_file,\n                 std::vector<std::string> outfilenames, int iterations,\n                 bool report) {\n  size_t isz;\n  char *pinbuf;\n\n  auto dev = q.get_device();\n  auto ctxt = q.get_context();\n  usm_allocator<GzipOutInfo, usm::alloc::host> alloc_GzipOutInfo(ctxt, dev);\n  usm_allocator<unsigned, usm::alloc::host> alloc_unsigned(ctxt, dev);\n  usm_allocator<char *, usm::alloc::host> alloc_char_ptr(ctxt, dev);\n  usm_allocator<char, usm::alloc::host> alloc_char(ctxt, dev);\n\n  // Read the input file\n  std::string device_string =\n      q.get_device().get_info<info::device::name>().c_str();\n\n  // If the device is supports USM allocations, we pre-pin some buffers to\n  // improve DMA performance, which is needed to\n  // achieve peak kernel throughput. Pre-pinning is\n  // only supported on the USM capable BSPs. It's not\n  // needed on non-USM capabale BSPs to achieve peak performance.\n  bool prepin = q.get_device().has(aspect::usm_host_allocations);\n\n  if (!prepin) {\n    std::cout << \"Warning: Host allocations are not supported on this \"\n                 \"platform, which means that pre-pinning is not supported. DMA \"\n                 \"transfers may be slower than expected which may reduce \"\n                 \"application throughput.\\n\\n\";\n  }\n\n  // padding for the input and output buffers to deal with granularity of\n  // kernel reads and writes\n  constexpr size_t kInOutPadding = 16 * kVec;  \n  \n  std::ifstream file(input_file,\n                     std::ios::in | std::ios::binary | std::ios::ate);\n  if (file.is_open()) {\n    isz = file.tellg();\n    if (prepin) {\n      pinbuf = (char *)malloc_host(\n          isz + kInOutPadding, q.get_context());  // Pre-pin the buffer, for faster DMA\n    } else {                      // throughput, using malloc_host().\n      pinbuf = new char[isz + kInOutPadding];\n    }\n    file.seekg(0, std::ios::beg);\n    file.read(pinbuf, isz);\n    file.close();\n  } else {\n    std::cout << \"Error: cannot read specified input file\\n\";\n    return 1;\n  }\n\n  if (isz < minimum_filesize) {\n    std::cout << \"Minimum filesize for compression is \" << minimum_filesize\n              << \"\\n\";\n    return 1;\n  }\n\n  int buffers_count = iterations;\n\n  // Array of kernel info structures...\n  struct KernelInfo *kinfo[kNumEngines];\n\n  for (size_t eng = 0; eng < kNumEngines; eng++) {\n    kinfo[eng] = new struct KernelInfo[buffers_count];\n    if (kinfo[eng] == NULL) {\n      std::cout << \"Cannot allocate kernel info buffer.\\n\";\n      return 1;\n    }\n  }\n\n  // This loop allocates host-side USM buffers, to be accessed by the kernel.\n  for (size_t eng = 0; eng < kNumEngines; eng++) {\n    for (int i = 0; i < buffers_count; i++) {\n      kinfo[eng][i].input_size = isz;\n      // Allocating slightly larger buffers (+ 16 * kVec) to account for\n      // granularity of kernel writes\n      kinfo[eng][i].output_size =\n          ((isz + kInOutPadding) < kMinBufferSize) ? kMinBufferSize\n                                                   : (isz + kInOutPadding);\n      const size_t input_alloc_size = isz + kInOutPadding;\n\n      kinfo[eng][i].last_block = true;\n      kinfo[eng][i].pref_buffer = pinbuf;\n\n      // Only allocate N_BUFFERING number of buffers and reuse them on\n      // subsequent iterations.\n      kinfo[eng][i].gzip_out_buf =\n          i >= N_BUFFERING ? kinfo[eng][i - N_BUFFERING].gzip_out_buf\n                           : alloc_GzipOutInfo.allocate(BATCH_SIZE *\n                                                        sizeof(GzipOutInfo));\n      kinfo[eng][i].current_crc =\n          i >= N_BUFFERING\n              ? kinfo[eng][i - N_BUFFERING].current_crc\n              : alloc_unsigned.allocate(BATCH_SIZE * sizeof(uint32_t));\n\n      for (int b = 0; b < BATCH_SIZE; b++) {\n        kinfo[eng][i].current_crc[b] = 0;\n        kinfo[eng][i].gzip_out_buf[b].compression_sz = 0;\n      }\n\n      // Allocate space for the array of pointers. The array contains\n      // BATCH_SIZE number of pointers.\n      kinfo[eng][i].pibuf_ptr_array =\n          i >= N_BUFFERING\n              ? kinfo[eng][i - N_BUFFERING].pibuf_ptr_array\n              : alloc_char_ptr.allocate(BATCH_SIZE * sizeof(char *));\n      kinfo[eng][i].pobuf_ptr_array =\n          i >= N_BUFFERING\n              ? kinfo[eng][i - N_BUFFERING].pobuf_ptr_array\n              : alloc_char_ptr.allocate(BATCH_SIZE * sizeof(char *));\n\n      // For each pointer, allocated space for the input/output buffers\n      if (i <\n          N_BUFFERING) {  // But only for the first N_BUFFERING kinfo structs\n                          // since the buffers get subsequently reused.\n        for (int b = 0; b < BATCH_SIZE; b++) {\n          kinfo[eng][i].pibuf_ptr_array[b] =\n              alloc_char.allocate(input_alloc_size * sizeof(char));\n          kinfo[eng][i].pobuf_ptr_array[b] =\n              alloc_char.allocate(kinfo[eng][i].output_size * sizeof(char));\n          memset(kinfo[eng][i].pobuf_ptr_array[b], 0,\n                 kinfo[eng][i].output_size);  // Initialize output buf to zero.\n        }\n      }\n    }\n  }\n\n  // Vectors to store the in/out pointers for each iteration (buffers_count),\n  // for each engine (kNumengines), for each batch (BATCH_SIZE).\n  std::vector<std::array<std::array<char *, BATCH_SIZE>, kNumEngines>> in_ptrs(\n      buffers_count);\n  std::vector<std::array<std::array<char *, BATCH_SIZE>, kNumEngines>> out_ptrs(\n      buffers_count);\n\n  // Grab the pointers and populate the vectors\n  for (size_t index = 0; index < buffers_count; index++) {\n    for (size_t eng = 0; eng < kNumEngines; eng++) {\n      for (size_t i = 0; i < BATCH_SIZE; i++) {\n        if (i < BATCH_SIZE) {\n          in_ptrs[index][eng][i] = kinfo[eng][index].pibuf_ptr_array[i];\n          out_ptrs[index][eng][i] = kinfo[eng][index].pobuf_ptr_array[i];\n        } else {  // Re-use first pointer to avoid invalid-arg runtime error\n          in_ptrs[index][eng][i] = kinfo[eng][index].pibuf_ptr_array[0];\n          out_ptrs[index][eng][i] = kinfo[eng][index].pobuf_ptr_array[0];\n        }\n      }\n    }\n  }\n\n  /*************************************************/\n  /* Main loop where the actual execution happens  */\n  /*************************************************/\n\n  // Initialize the input buffer with the file to be compressed.\n  // In this reference design, for simplicity, we use the same input file\n  // repeatedly. We also do not bother to copy the output (the compressed\n  // result) out of the output buffers since it's the same on every execution.\n  // Recall that the input and output buffers are reused, therefore in a real\n  // application you'll need to both copy new files into the input buffers and\n  // copy the compressed results out of the output buffers. System throughput\n  // may degrade if these host-side operations take longer than the kernel\n  // execution time because you won't be able to safely invoke a new kernel\n  // until the copies are complete, leading to deadtime between kernel\n  // executions. The host-side processing time can be hidden using \"N-way\n  // buffering\" -- see the corresponding tutorial (n_way_buffering) to learn how\n  // this is can be done.\n  int initial_index = std::min(N_BUFFERING, buffers_count);\n  for (int index = 0; index < initial_index; index++) {\n    for (size_t eng = 0; eng < kNumEngines; eng++) {\n      for (int b = 0; b < BATCH_SIZE; b++) {\n        memcpy(kinfo[eng][index].pibuf_ptr_array[b],\n               kinfo[eng][index].pref_buffer, kinfo[eng][index].input_size);\n      }\n    }\n  }\n\n#ifdef FPGA_EMULATOR\n#elif FPGA_SIMULATOR\n#else\n  auto start = std::chrono::steady_clock::now();\n#endif\n\n  // Launch initial set of kernels\n  for (int index = 0; index < initial_index; index++) {\n    for (size_t eng = 0; eng < kNumEngines; eng++) {\n      kinfo[eng][index].kernel_event = SubmitGzipTasks(q,\n                                                    kinfo[eng][index].input_size,\n                                                    kinfo[eng][index].gzip_out_buf,\n                                                    kinfo[eng][index].current_crc, \n                                                    kinfo[eng][index].last_block,\n                                                    {},\n                                                    in_ptrs[index][eng],\n                                                    out_ptrs[index][eng],\n                                                    eng\n                                                    );\n    }\n  }\n\n  // Main loop where the gzip engine is repeatedly invoked in a double-buffered\n  // fashion.\n  for (int index = initial_index; index < buffers_count; index++) {\n    for (size_t eng = 0; eng < kNumEngines; eng++) {\n      /************************************/\n      /************************************/\n      /*         LAUNCH GZIP ENGINE       */\n      /************************************/\n      /************************************/\n\n      kinfo[eng][index].kernel_event = SubmitGzipTasks(q,\n                                                  kinfo[eng][index].input_size, \n                                                  kinfo[eng][index].gzip_out_buf,\n                                                  kinfo[eng][index].current_crc,\n                                                  kinfo[eng][index].last_block,\n                                                  kinfo[eng][index - N_BUFFERING].kernel_event,\n                                                  in_ptrs[index][eng],\n                                                  out_ptrs[index][eng],                                                  \n                                                  eng\n                                                  );\n\n    }\n  }\n\n  // Wait for all kernels to complete.\n  for (int index = buffers_count - initial_index; index < buffers_count;\n       index++) {\n    for (size_t eng = 0; eng < kNumEngines; eng++) {\n      for (auto event : kinfo[eng][index].kernel_event) {\n        event.wait();\n      }\n    }\n  }\n\n// Stop the timer.\n#ifdef FPGA_EMULATOR\n#elif FPGA_SIMULATOR\n#else\n  auto end = std::chrono::steady_clock::now();\n  double diff_total = std::chrono::duration_cast<std::chrono::duration<double>>(end - start).count();\n  if (report) {\n    std::cout << \"Total execution time: \" << (double)diff_total * 1000000\n              << \"us \\n\";\n    std::cout << \"Average per batch_latency: \"\n              << (double)diff_total * 1000000 / iterations << \" us \\n\";\n  }\n  double gbps = BATCH_SIZE * iterations * isz / (double)diff_total /\n                1000000000.0;\n#endif\n\n  // Sanity check the compressed size of every result. Also sum the compressed\n  // sizes together to be later used to calculate the compression ratio.\n  size_t compressed_sz[kNumEngines];\n  for (int eng = 0; eng < kNumEngines; eng++) {\n    compressed_sz[eng] = 0;\n    for (int index = 0; index < buffers_count; index++) {\n      for (int b = 0; b < BATCH_SIZE; b++) {\n        if (kinfo[eng][index].gzip_out_buf[b].compression_sz >\n            kinfo[eng][index].input_size) {\n          std::cerr << \"Unsupported: compressed file larger than input file ( \"\n                    << kinfo[eng][index].gzip_out_buf[b].compression_sz\n                    << \" bytes)\\n\";\n          return 1;\n        }\n        compressed_sz[eng] += kinfo[eng][index].gzip_out_buf[b].compression_sz;\n      }\n    }\n  }\n\n  if (report) std::cout << \"Writing gzip archive to disk and verifying\\n\";\n  // Write the outputs from buffer set 0 and check for errors\n  for (int i = 0; i < 1;\n       i++) {  // Here you could iterate through all the buffer sets.\n    for (int eng = 0; eng < kNumEngines; eng++) {\n      for (int b = 0; b < BATCH_SIZE; b++) {\n        if (report &&\n            WriteBlockGzip(\n                input_file, outfilenames[eng], kinfo[eng][i].pobuf_ptr_array[b],\n                kinfo[eng][i].gzip_out_buf[b].compression_sz,\n                kinfo[eng][i].input_size,\n                Crc32(kinfo[eng][i].pref_buffer, kinfo[eng][i].input_size,\n                      kinfo[eng][i].current_crc[b])  // Compute the remaining\n                                                     // piece of the CRC.\n                )) {\n          std::cout << \"FAILED\\n\";\n          return 1;\n        }\n      }\n    }\n  }\n\n  // Decompress the output from engine-0 and compare against the input file.\n  // Only engine-0's output is verified since all engines are fed the same input\n  // data.\n  if (report && CompareGzipFiles(input_file, outfilenames[0])) {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n\n  // Generate throughput report\n  // First gather all the execution times.\n  size_t time_k_crc[kNumEngines];\n  size_t time_k_lz[kNumEngines];\n  size_t time_k_huff[kNumEngines];\n  \n  for (int eng = 0; eng < kNumEngines; eng++) {\n    time_k_crc[eng] = 0;\n    time_k_lz[eng] = 0;\n    time_k_huff[eng] = 0;\n    for (int i = 0; i < buffers_count;\n         i++) {  // Execution times (total sums) of the individual gzip kernels\n      time_k_crc[eng] +=\n          SyclGetExecTimeNs(kinfo[eng][i].kernel_event[kCRCIndex]);\n      time_k_lz[eng] +=\n          SyclGetExecTimeNs(kinfo[eng][i].kernel_event[kLZReductionIndex]);\n      time_k_huff[eng] +=\n          SyclGetExecTimeNs(kinfo[eng][i].kernel_event[kStaticHuffmanIndex]);\n    }\n  }\n\n  if (report) {\n    double compression_ratio = (double)((double)compressed_sz[0] / (double)isz /\n                                        BATCH_SIZE / iterations);\n#ifdef FPGA_EMULATOR\n#elif FPGA_SIMULATOR\n#else\n    std::cout << \"Throughput: \" << kNumEngines * gbps << \" GB/s\\n\\n\";\n    for (int eng = 0; eng < kNumEngines; eng++) {\n      std::cout << \"TP breakdown for engine #\" << eng << \" (GB/s)\\n\";\n      std::cout << \"CRC = \" << BATCH_SIZE * iterations * isz / (double)time_k_crc[eng]\n                << \"\\n\";\n      std::cout << \"LZ77 = \" << BATCH_SIZE * iterations * isz / (double)time_k_lz[eng]\n                << \"\\n\";\n      std::cout << \"Huffman Encoding = \"\n                << BATCH_SIZE * iterations * isz / (double)time_k_huff[eng] << \"\\n\";\n    }\n#endif\n    std::cout << \"Compression Ratio \" << compression_ratio * 100 << \"%\\n\";\n  }\n\n  // Cleanup anything that was allocated by this routine.\n  // delete the file mapping now that all kernels are complete, and we've\n  // snapped the time delta\n\n  // delete the file mapping now that all kernels are complete, and we've\n  // snapped the time delta\n  if (prepin) {\n    free(pinbuf, q.get_context());\n  } else {\n    delete pinbuf;\n  }\n\n  for (int eng = 0; eng < kNumEngines; eng++) {\n    for (int i = 0; i < buffers_count; i++) {\n      if (i < N_BUFFERING) {\n        alloc_GzipOutInfo.deallocate(kinfo[eng][i].gzip_out_buf,\n                                     BATCH_SIZE * sizeof(GzipOutInfo));\n        alloc_unsigned.deallocate(kinfo[eng][i].current_crc,\n                                  BATCH_SIZE * sizeof(uint32_t));\n\n        // dealloc the input buffers\n        for (int b = 0; b < BATCH_SIZE; b++) {\n          alloc_char.deallocate(kinfo[eng][i].pibuf_ptr_array[b],\n                                kinfo[eng][i].input_size * sizeof(char));\n          alloc_char.deallocate(kinfo[eng][i].pobuf_ptr_array[b],\n                                kinfo[eng][i].output_size * sizeof(char));\n        }\n\n        // dealloc the array of input buffer pointers\n        alloc_char_ptr.deallocate(kinfo[eng][i].pibuf_ptr_array,\n                                  BATCH_SIZE * sizeof(char *));\n        alloc_char_ptr.deallocate(kinfo[eng][i].pobuf_ptr_array,\n                                  BATCH_SIZE * sizeof(char *));\n      }\n    }\n    delete[] kinfo[eng];\n  }\n\n  if (report) std::cout << \"PASSED\\n\";\n  return 0;\n}\n"
    },
    {
        "label": "CompareGzip.cpp",
        "data": "#include \"CompareGzip.hpp\"\n#include <sys/stat.h>\n\n// returns 0 on success, otherwise failure\nint CompareGzipFiles(\n    const std::string\n        &original_file,  // original input file to compare gzip uncompressed\n    const std::string &input_gzfile)  // gzip file to check\n{\n#ifdef _MSC_VER\n  std::cout\n      << \"Info: skipping output verification on Windows, no builtin gunzip\\n\";\n  return 0;\n#else\n  //------------------------------------------------------------------\n  // assume all good to start with.\n\n  int gzipstatus = 0;\n\n  //------------------------------------------------------------------\n  // Create temporary output filename for gunzip\n\n  char tmp_name[] = \"/tmp/gzip_fpga.XXXXXX\";\n  mode_t mask = umask(S_IXUSR);\n  mkstemp(tmp_name);\n  umask(mask);\n  std::string outputfile = tmp_name;\n\n  //------------------------------------------------------------------\n  // Check that the original file and gzipped file exist.\n\n  //------------------------------------------------------------------\n  // gunzip the file produced to stdout, capturing to the temp file.\n\n  std::string cmd = \"gunzip -c \";\n  cmd += input_gzfile;\n  cmd += \" > \" + outputfile;\n\n  int gzout = ::system(cmd.c_str());\n  if (gzout != 0) {\n    gzipstatus = 3;\n  }\n\n  //------------------------------------------------------------------\n  // diff the temp file and the original.\n\n  cmd = \"diff -q \" + outputfile + \" \" + original_file;\n  int diffout = ::system(cmd.c_str());\n  if (diffout != 0) {\n    gzipstatus = 4;\n  }\n\n  //------------------------------------------------------------------\n  // Cleanup, remove the temp file.\n\n  (void)::remove(outputfile.c_str());\n\n  return gzipstatus;\n#endif\n}\n"
    },
    {
        "label": "CompareGzip.hpp",
        "data": "#ifndef __COMPAREGZIP_H__\n#define __COMPAREGZIP_H__\n#pragma once\n\n#include <iostream>\n#include <string>\n\nint CompareGzipFiles(\n    const std::string\n        &original_file,  // original input file to compare gzip uncompressed\n    const std::string &input_gzfile);  // gzip file to check\n\n#endif  //__COMPAREGZIP_H__\n"
    },
    {
        "label": "WriteGzip.cpp",
        "data": "#define _CRT_SECURE_NO_WARNINGS\n#include \"WriteGzip.hpp\"\n\n#include <fcntl.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <sycl/sycl.hpp>\n#include <chrono>\n#include <string>\n\nconstexpr int kDeflated = 8;\n#define GZIP_MAGIC \"\\037\\213\"  // Magic header for gzip files, 1F 8B\n\n#define ORIG_NAME 0x08\n#define OS_CODE 0x03  // Unix OS_CODE\n\ntypedef struct GzipHeader {\n  unsigned char magic[2];         // 0x1f, 0x8b\n  unsigned char compress_method;  // 0-7 reserved, 8=deflate -- kDeflated\n  unsigned char flags;            // b0: file probably ascii\n                                  // b1: header crc-16 present\n                                  // b2: extra field present\n                                  // b3: original file name present\n                                  // b4: file comment present\n                                  // b5,6,7: reserved\n  unsigned long time;             // file modification time in Unix format.\n                                  // Set this to 0 for now.\n\n  unsigned char extra;  // depends on compression method\n  unsigned char os;     // operating system on which compression took place\n\n  // ...\n  //  ? bytes ... compressd data ...\n\n  unsigned long crc;\n  unsigned long uncompressed_sz;\n\n} gzip_header, *pgzip_header;\n\ninline static void PutUlong(uint8_t *pc, unsigned long l) {\n  pc[0] = l & 0xff;\n  pc[1] = (l >> 8) & 0xff;\n  pc[2] = (l >> 16) & 0xff;\n  pc[3] = (l >> 24) & 0xff;\n}\n\n// returns 0 on success, otherwise failure\nint WriteBlockGzip(\n    std::string &original_filename,  // Original file name being compressed\n    std::string &out_filename,       // gzip filename\n    char *obuf,                      // pointer to compressed data block\n    size_t blen,                     // length of compressed data block\n    size_t ilen,                     // original block length\n    uint32_t buffer_crc)             // the block's crc\n{\n  //------------------------------------------------------------------\n  // Setup the gzip output file header.\n  //  max filename size is arbitrarily set to 256 bytes long\n  //  Method is always DEFLATE\n  //  Original filename is always set in header\n  //  timestamp is set to 0 - ignored by gunzip\n  //  deflate flags set to 0\n  //  OS code is 0\n\n  int max_filename_sz = 256;\n\n  unsigned char *pgziphdr =\n      (unsigned char *)malloc(sizeof(gzip_header) + max_filename_sz);\n\n  if (!pgziphdr) {\n    std::cout << \"pgzip header cannot be allocated\\n\";\n    return 1;\n  }\n\n  pgziphdr[0] = GZIP_MAGIC[0];\n  pgziphdr[1] = GZIP_MAGIC[1];\n  pgziphdr[2] = kDeflated;\n  pgziphdr[3] = ORIG_NAME;\n\n  // Set time in header to 0, this is ignored by gunzip.\n  pgziphdr[4] = 0;\n  pgziphdr[5] = 0;\n  pgziphdr[6] = 0;\n  pgziphdr[7] = 0;\n\n  // Deflate flags\n  pgziphdr[8] = 0;\n\n  // OS code is Linux in this case.\n  pgziphdr[9] = OS_CODE;\n\n  int ondx = 10;\n\n  const char *p = original_filename.c_str();\n  do {\n    pgziphdr[ondx++] = (*p);\n  } while (*p++);\n\n  int header_bytes = ondx;\n\n  unsigned char prolog[8];\n\n  PutUlong(((unsigned char *)prolog), buffer_crc);\n  PutUlong(((unsigned char *)&prolog[4]), ilen);\n\n  FILE *fo = fopen(out_filename.c_str(), \"w+\");\n  if (ferror(fo)) {\n    std::cout << \"Cannot open file for output: \" << out_filename << \"\\n\";\n    free(pgziphdr);\n    return 1;\n  }\n\n  fwrite(pgziphdr, 1, header_bytes, fo);\n  fwrite(obuf, 1, blen, fo);\n  fwrite(prolog, 1, 8, fo);\n\n  if (ferror(fo)) {\n    std::cout << \"gzip output file write failure.\\n\";\n    free(pgziphdr);\n    return 1;\n  }\n\n  if (fclose(fo)) {\n    perror(\"close\");\n    free(pgziphdr);\n    return 1;\n  }\n  free(pgziphdr);\n  return 0;\n}\n"
    },
    {
        "label": "WriteGzip.hpp",
        "data": "#ifndef __WRITEGZIP_H__\n#define __WRITEGZIP_H__\n#pragma once\n\n#include <iostream>\n#include <string>\n#include <stdint.h>\n\n// returns 0 on success, otherwise failure\nint WriteBlockGzip(\n    std::string &original_filename,  // Original file name being compressed\n    std::string &out_filename,       // gzip filename\n    char *obuf,                      // pointer to compressed data block\n    size_t blen,                     // length of compressed data block\n    size_t ilen,                     // original block length\n    uint32_t buffer_crc);            // the block's crc\n\n#endif  //__WRITEGZIP_H__\n"
    },
    {
        "label": "qrd_demo.cpp",
        "data": "#include <cmath>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/ext/intel/ac_types/ac_complex.hpp>\n\n#include <list>\n\n#include \"exception_handler.hpp\"\n\n#include \"qrd.hpp\"\n\n#ifdef FPGA_SIMULATOR\n#define ROWS_COMPONENT_V 8\n#define COLS_COMPONENT_V 8\n#else\n#define ROWS_COMPONENT_V ROWS_COMPONENT\n#define COLS_COMPONENT_V COLS_COMPONENT\n#endif\n\n/*\n  COMPLEX, COLS_COMPONENT, ROWS_COMPONENT and FIXED_ITERATIONS are defined\n  by the build system.\n  Depending on the value of COMPLEX, the real or complex QRDecomposition is\n  defined\n\n  Function arguments:\n  - a_matrix:    The input matrix. Interpreted as a transposed matrix.\n  - q_matrix:    The Q matrix. The function will overwrite this matrix.\n  - r_matrix     The R matrix. The function will overwrite this matrix.\n                 The vector will only contain the upper triangular elements\n                 of the matrix, in a row by row fashion.\n  - q:           The device queue.\n  - matrix_count: Number of matrices to decompose.\n  - repetitions: The number of repetitions of the computation to execute.\n                 (for performance evaluation)\n*/\n#if COMPLEX == 0\n// Real single precision floating-point QR Decomposition\nvoid QRDecomposition(std::vector<float> &a_matrix, std::vector<float> &q_matrix,\n                     std::vector<float> &r_matrix, sycl::queue &q,\n                     int matrix_count,\n                     int repetitions) {\n  constexpr bool is_complex = false;\n  QRDecompositionImpl<COLS_COMPONENT_V, ROWS_COMPONENT_V, FIXED_ITERATIONS,\n                       is_complex, float>(a_matrix, q_matrix, r_matrix, q,\n                                          matrix_count, repetitions);\n}\n#else\n// Complex single precision floating-point QR Decomposition\nvoid QRDecomposition(std::vector<ac_complex<float> > &a_matrix,\n                     std::vector<ac_complex<float> > &q_matrix,\n                     std::vector<ac_complex<float> > &r_matrix, sycl::queue &q,\n                     int matrix_count,\n                     int repetitions) {\n  constexpr bool is_complex = true;\n  QRDecompositionImpl<COLS_COMPONENT_V, ROWS_COMPONENT_V, FIXED_ITERATIONS,\n                       is_complex, float>(a_matrix, q_matrix, r_matrix, q,\n                                          matrix_count, repetitions);\n}\n#endif\n\n/*\n  returns if both the real and complex parts of the given ac_complex\n  value are finite\n*/\nbool IsFinite(ac_complex<float> val) {\n  return std::isfinite(val.r()) && std::isfinite(val.i());\n}\n\n/*\n  returns if the given value is finite\n*/\nbool IsFinite(float val) { return std::isfinite(val); }\n\nint main(int argc, char *argv[]) {\n  constexpr size_t kRandomSeed = 1138;\n  constexpr size_t kRandomMin = 1;\n  constexpr size_t kRandomMax = 10;\n  constexpr size_t kRows = ROWS_COMPONENT_V;\n  constexpr size_t kColumns = COLS_COMPONENT_V;\n  constexpr size_t kAMatrixSize = kRows * kColumns;\n  constexpr size_t kQMatrixSize = kRows * kColumns;\n  constexpr size_t kRMatrixSize = kColumns * (kColumns + 1) / 2;\n  constexpr size_t kQRMatrixSize = kQMatrixSize + kRMatrixSize;\n  constexpr bool kComplex = COMPLEX != 0;\n\n#if defined(FPGA_SIMULATOR)\n  std::cout << \"Using 32x32 matrices for simulation to reduce runtime\" << std::endl;\n#endif\n\n  // Get the number of times we want to repeat the decomposition\n  // from the command line.\n#if defined(FPGA_EMULATOR)\n  int repetitions = argc > 1 ? atoi(argv[1]) : 16;\n#elif defined(FPGA_SIMULATOR)\n  int repetitions = argc > 1 ? atoi(argv[1]) : 1;\n#else\n  int repetitions = argc > 1 ? atoi(argv[1]) : 819200;\n#endif\n  if (repetitions < 1) {\n    std::cout << \"Number of repetitions given is lower that 1.\" << std::endl;\n    std::cout << \"The decomposition must occur at least 1 time.\" << std::endl;\n    std::cout << \"Increase the number of repetitions (e.g. 16).\" << std::endl;\n    return 1;\n  }\n\n#if defined(FPGA_SIMULATOR)\n  constexpr size_t kMatricesToDecompose = 1;\n#else\n  constexpr size_t kMatricesToDecompose = 8;\n#endif\n\n  try {\n\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // Enable the queue profiling to time the execution\n    sycl::property_list\n                    queue_properties{sycl::property::queue::enable_profiling()};\n    sycl::queue q = sycl::queue(selector,\n                                fpga_tools::exception_handler,\n                                queue_properties);\n\n    sycl::device device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Select a type for this compile depending on the value of COMPLEX\n    using T = std::conditional_t<kComplex, ac_complex<float>, float>;\n\n    // Create vectors to hold all the input and output matrices\n    std::vector<T> a_matrix;\n    std::vector<T> q_matrix;\n    std::vector<T> r_matrix;\n\n    a_matrix.resize(kAMatrixSize * kMatricesToDecompose);\n    q_matrix.resize(kQMatrixSize * kMatricesToDecompose);\n    r_matrix.resize(kRMatrixSize * kMatricesToDecompose);\n\n    std::cout << \"Generating \" << kMatricesToDecompose << \" random \";\n    if constexpr (kComplex) {\n      std::cout << \"complex \";\n    } else {\n      std::cout << \"real \";\n    }\n    std::cout << \"matri\" << (kMatricesToDecompose > 1 ? \"ces\" : \"x\")\n              << \" of size \"\n              << kRows << \"x\" << kColumns << \" \" << std::endl;\n\n    // Generate the random input matrices\n    srand(kRandomSeed);\n\n    for(int matrix_index = 0; matrix_index < kMatricesToDecompose;\n                                                                matrix_index++){\n      for (size_t row = 0; row < kRows; row++) {\n        for (size_t col = 0; col < kColumns; col++) {\n          float random_real = rand() % (kRandomMax - kRandomMin) + kRandomMin;\n  #if COMPLEX == 0\n          a_matrix[matrix_index * kAMatrixSize\n                 + col * kRows + row] = random_real;\n  #else\n          float random_imag = rand() % (kRandomMax - kRandomMin) + kRandomMin;\n          ac_complex<float> random_complex{random_real, random_imag};\n          a_matrix[matrix_index * kAMatrixSize\n                 + col * kRows + row] = random_complex;\n  #endif\n        }  // end of col\n      }    // end of row\n\n  #ifdef DEBUG\n      std::cout << \"A MATRIX \" << matrix_index << std::endl;\n      for (size_t row = 0; row < kRows; row++) {\n        for (size_t col = 0; col < kColumns; col++) {\n          std::cout << a_matrix[matrix_index * kAMatrixSize\n                              + col * kRows + row] << \" \";\n        }  // end of col\n        std::cout << std::endl;\n      }  // end of row\n  #endif\n\n    } // end of matrix_index\n\n    std::cout << \"Running QR decomposition of \" << kMatricesToDecompose\n              << \" matri\" << (kMatricesToDecompose > 1 ? \"ces \" : \"x \")\n              << repetitions << \" times\" << std::endl;\n\n    QRDecomposition(a_matrix, q_matrix, r_matrix, q, kMatricesToDecompose,\n                                                                  repetitions);\n\n    // For output post-processing (op)\n    T q_matrix_op[kRows][kColumns];\n    T r_matrix_op[kRows][kColumns];\n\n    // For rectangular matrices, Q is only going to have orthogonal columns\n    // so we won't check if the rows are orthogonal\n    bool square_matrices = kRows == kColumns;\n\n    // Floating-point error threshold value at which we decide that the design\n    // computed an incorrect value\n    constexpr float kErrorThreshold = 1e-4;\n    // The orthogonality check is more sensible to numerical error, the\n    // threshold is then set a bit higher\n    float q_ortho_error_threshold = pow(2.0, -9);\n\n    // Check Q and R matrices\n    std::cout << \"Verifying results...\";\n    for(int matrix_index = 0; matrix_index < kMatricesToDecompose;\n                                                                matrix_index++){\n\n      // keep track of Q and R element indexes\n      size_t r_idx = 0;\n      size_t q_idx = 0;\n\n      // Read the R matrix from the output vector to the RMatrixOP matrix\n      for (size_t i = 0; i < kRows; i++) {\n        for (size_t j = 0; j < kColumns; j++) {\n          if (j < i)\n            r_matrix_op[i][j] = 0;\n          else {\n            r_matrix_op[i][j] = r_matrix[matrix_index*kRMatrixSize\n                                       + r_idx];\n            r_idx++;\n          }\n        }\n      }\n\n      // Read the Q matrix from the output vector to the QMatrixOP matrix\n      for (size_t j = 0; j < kColumns; j++) {\n        for (size_t i = 0; i < kRows; i++) {\n          q_matrix_op[i][j] = q_matrix[matrix_index*kQMatrixSize\n                                     + q_idx];\n          q_idx++;\n        }\n      }\n\n  #ifdef DEBUG\n      std::cout << \"R MATRIX\" << std::endl;\n      for (size_t i = 0; i < kRows; i++) {\n        for (size_t j = 0; j < kColumns; j++) {\n          std::cout << r_matrix_op[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n\n      std::cout << \"Q MATRIX\" << std::endl;\n      for (size_t i = 0; i < kRows; i++) {\n        for (size_t j = 0; j < kColumns; j++) {\n          std::cout << q_matrix_op[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n  #endif\n\n      // Count the number of errors found for this matrix\n      size_t error_count = 0;\n      bool error = false;\n\n      for (size_t i = 0; i < kRows; i++) {\n        for (size_t j = 0; j < kColumns; j++) {\n          // Compute Q * R at index i,j\n          T q_r_ij{0};\n          for (size_t k = 0; k < kColumns; k++) {\n            q_r_ij += q_matrix_op[i][k] * r_matrix_op[k][j];\n          }\n\n          // Compute transpose(Q) * Q at index i,j\n          T qt_q_ij{0};\n          if (i < kColumns) {\n            for (size_t k = 0; k < kRows; k++) {\n  #if COMPLEX == 0\n              qt_q_ij += q_matrix_op[k][i] * q_matrix_op[k][j];\n  #else\n              qt_q_ij += q_matrix_op[k][i] * q_matrix_op[k][j].conj();\n  #endif\n            }\n          }\n\n          // Compute Q * transpose(Q) at index i,j\n          T q_qt_ij{0};\n          if (square_matrices) {\n            if (i < kColumns) {\n              for (size_t k = 0; k < kRows; k++) {\n  #if COMPLEX == 0\n                q_qt_ij += q_matrix_op[i][k] * q_matrix_op[j][k];\n  #else\n                q_qt_ij += q_matrix_op[i][k] * q_matrix_op[j][k].conj();\n  #endif\n              }\n            }\n          }\n\n          // Verify that all the results are OK:\n          // Q * R = A at index i,j\n          bool q_r_eq_a;\n          // transpose(Q) * Q = Id at index i,j\n          bool qt_q_eq_id;\n          // Q * transpose(Q) = Id at index i,j\n          bool q_qt_eq_id;\n          // R is upped triangular\n          bool r_is_upper_triang;\n          // R is finite at index i,j\n          bool r_is_finite;\n\n  #if COMPLEX == 0\n          q_r_eq_a = abs(a_matrix[matrix_index * kAMatrixSize\n                                + j * kRows + i]\n                       - q_r_ij) < kErrorThreshold;\n\n          qt_q_eq_id =\n                  ((i == j) && (abs(qt_q_ij - 1) < q_ortho_error_threshold)) ||\n                  ((i != j) && (abs(qt_q_ij) < q_ortho_error_threshold));\n\n          q_qt_eq_id = !square_matrices ||\n                  (((i == j) && (abs(q_qt_ij - 1) < q_ortho_error_threshold)) ||\n                  ((i != j) && (abs(q_qt_ij) < q_ortho_error_threshold)));\n\n          r_is_upper_triang =\n              (i >= kColumns) ||\n              ((i > j) && ((abs(r_matrix_op[i][j]) < kErrorThreshold))) ||\n              ((i <= j));\n\n  #else\n          q_r_eq_a = (abs(a_matrix[matrix_index * kAMatrixSize\n                                 + j * kRows + i].r() -\n                       q_r_ij.r()) < kErrorThreshold) &&\n                  (abs(a_matrix[matrix_index * kAMatrixSize\n                              + j * kRows + i].i() -\n                       q_r_ij.i()) < kErrorThreshold);\n\n          qt_q_eq_id =\n              (((i == j) && (abs(qt_q_ij.r() - 1) < q_ortho_error_threshold)) ||\n(((i != j) || (j >= kRows)) && (abs(qt_q_ij.r()) < q_ortho_error_threshold))) &&\n              (abs(qt_q_ij.i()) < q_ortho_error_threshold);\n\n          q_qt_eq_id =\n              !square_matrices ||\n            ((((i == j) && (abs(q_qt_ij.r() - 1) < q_ortho_error_threshold)) ||\n                (((i != j) || (j >= kRows)) &&\n                 (abs(q_qt_ij.r()) < q_ortho_error_threshold))) &&\n               (abs(q_qt_ij.i()) < q_ortho_error_threshold));\n\n          r_is_upper_triang =\n              (i >= kColumns) ||\n              ((i > j) && ((abs(r_matrix_op[i][j].r()) < kErrorThreshold) &&\n                           (abs(r_matrix_op[i][j].i()) < kErrorThreshold))) ||\n              (i <= j);\n\n  #endif\n\n          r_is_finite =\n            ((i < kColumns) && IsFinite(r_matrix_op[i][j])) || (i >= kColumns);\n\n          // If any of the checks failed\n          if (!q_r_eq_a || !qt_q_eq_id || !q_qt_eq_id || !r_is_upper_triang ||\n              !IsFinite(q_r_ij) || !IsFinite(qt_q_ij) || !IsFinite(q_qt_ij) ||\n              !r_is_finite) {\n            // Increase the error count for this matrix\n            error_count++;\n\n            // Continue counting the errors even if we now we are going to\n            // produce an error\n            if (error) {\n              continue;\n            }\n\n            if (!q_r_eq_a) {\n              std::cout << \"Error: A[\" << i << \"][\" << j << \"] = \"\n                        << a_matrix[matrix_index * kAMatrixSize\n                                  + j * kRows + i]\n                        << \" but QR[\" << i << \"][\" << j << \"] = \" << q_r_ij\n                        << std::endl;\n            }\n            if (!q_r_eq_a) {\n              std::cout << \"The difference is greater than tolerated (\"\n                        << kErrorThreshold << \")\" << std::endl;\n            }\n            if (!qt_q_eq_id || !q_qt_eq_id) {\n              std::cout << \"Q is not orthogonal at i \" << i << \" j \" << j << \":\"\n                        << std::endl\n                        << \" transpose(Q) * Q = \" << qt_q_ij << std::endl\n                        << \" Q * transpose(Q) =\" << q_qt_ij << std::endl;\n              std::cout << \"q_ortho_error_threshold = \"\n                        << q_ortho_error_threshold\n                        << std::endl;\n            }\n            if (!r_is_upper_triang) {\n              std::cout << \"R is not upper triangular at i \" << i << \" j \" << j\n                        << \":\" << std::endl\n                        << \" R = \" << r_matrix_op[i][j] << std::endl;\n            }\n            if (!IsFinite(q_r_ij)) {\n              std::cout << \"QR[\" << i << \"][\" << j << \"] = \" << q_r_ij\n                        << \" is not finite\" << std::endl;\n            }\n            if (!IsFinite(qt_q_ij)) {\n              std::cout << \"transpose(Q) * Q at i \" << i << \" j \" << j << \" = \"\n                        << qt_q_ij << \" is not finite\" << std::endl;\n            }\n            if (!IsFinite(q_qt_ij)) {\n              std::cout << \"Q * transpose(Q) at i \" << i << \" j \" << j << \" = \"\n                        << q_qt_ij << \" is not finite\" << std::endl;\n            }\n            if (!r_is_finite) {\n              std::cout << \"R[\" << i << \"][\" << j << \"] = \" << r_matrix_op[i][j]\n                        << \" is not finite\" << std::endl;\n            }\n            error = true;\n          }\n        }  // end of j\n      }    // end of i\n\n      if (error_count > 0) {\n        std::cout << std::endl << \"FAILED\" << std::endl;\n        std::cout << std::endl\n                  << \"!!!!!!!!!!!!!! \" << error_count << \" errors\" << std::endl;\n        return 1;\n      }\n    } // end of matrix_index\n\n\n    std::cout << std::endl << \"PASSED\" << std::endl;\n    return 0;\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::cerr << \"   If you are targeting an FPGA hardware, \"\n                 \"ensure that your system is plugged to an FPGA board that is \"\n                 \"set up correctly\"\n              << std::endl;\n    std::cerr << \"   If you are targeting the FPGA emulator, compile with \"\n                 \"-DFPGA_EMULATOR\"\n              << std::endl;\n\n    std::terminate();\n  } catch (std::bad_alloc const &e) {\n    std::cerr << \"Caught a memory allocation exception on the host: \"\n              << e.what() << std::endl;\n    std::cerr << \"   You can reduce the memory requirement by reducing the \"\n                 \"number of matrices generated. Specify a smaller number when \"\n                 \"running the executable.\"\n              << std::endl;\n    std::cerr << \"   In this run, more than \"\n              << ((kAMatrixSize + kQRMatrixSize) * 2 * kMatricesToDecompose\n                 * sizeof(float)) / pow(2, 30)\n              << \" GBs of memory was requested for the decomposition of a \"\n              << \"matrix of size \" << kRows << \" x \" << kColumns\n              << std::endl;\n    std::terminate();\n  }\n}  // end of main\n"
    },
    {
        "label": "svd_demo.cpp",
        "data": "#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n#include <vector>\n\n#include \"exception_handler.hpp\"\n#include \"svd.hpp\"\n#include \"svd_testcase.hpp\"\n\n\nint main(int argc, char *argv[]) {\n#if FPGA_HARDWARE\n  int repetitions = 16384;\n#else\n  int repetitions = 1;\n#endif\n  if (argc == 2) {\n    repetitions = std::stoi(argv[1]);\n  }\n\n  try {\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // Enable the queue profiling to time the execution\n    sycl::property_list queue_properties{\n        sycl::property::queue::enable_profiling()};\n    sycl::queue q =\n        sycl::queue(selector, fpga_tools::exception_handler, queue_properties);\n    std::cout << \"Running on device: \"\n              << q.get_device().get_info<sycl::info::device::name>() << \"\\n\";\n\n#if FPGA_SIMULATOR\n    SVDTestcase<float, 4, 4, 1> small_testcase;\n    auto test_error = small_testcase.RunTest(q, repetitions);\n    small_testcase.PrintResult();\n#else\n    SVDTestcase<float, 32, 32, 8> large_testcase;\n    // SVDTestcase<float, 96, 96, 8> large_testcase;\n    auto test_error = large_testcase.RunTest(q, repetitions);\n    large_testcase.PrintResult();\n#endif\n    bool passed = test_error < 0.1;\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::terminate();\n  }\n}"
    },
    {
        "label": "cholesky_demo.cpp",
        "data": "#include <cmath>\n\n#include <sycl/sycl.hpp>\n#include <list>\n#include <sycl/ext/intel/ac_types/ac_complex.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"cholesky.hpp\"\n#include \"exception_handler.hpp\"\n\n// Use \"#define DEBUG\" to print debugging information such as matrices content\n\n/*\n  COMPLEX, MATRIX_DIMENSION and FIXED_ITERATIONS are defined\n  by the build system.\n  Depending on the value of COMPLEX, the real or complex Cholesky decomposition\n  is defined (A = LL*)\n\n  Function arguments:\n  - a_matrix:    The input matrix.\n  - l_matrix     The L matrix. The function will overwrite this matrix.\n                 The vector will only contain the lower triangular elements\n                 of the matrix, in a row by row fashion.\n  - q:           The device queue.\n  - matrix_count: Number of matrices to decompose.\n  - repetitions: The number of repetitions of the computation to execute.\n                 (for performance evaluation)\n*/\ntemplate <typename T, bool is_complex>\nvoid CholeskyDecomposition(std::vector<T> &a_matrix, std::vector<T> &l_matrix,\n                           sycl::queue &q, int matrix_count, int repetitions) {\n  CholeskyDecompositionImpl<MATRIX_DIMENSION, FIXED_ITERATIONS, is_complex,\n                            float>(a_matrix, l_matrix, q, matrix_count,\n                                   repetitions);\n}\n\n/*\n  Returns true if both the real and complex parts of the given ac_complex\n  value are finite\n*/\nbool IsFinite(ac_complex<float> val) {\n  return std::isfinite(val.r()) && std::isfinite(val.i());\n}\n\n/*\n  Returns true if the given value is finite\n*/\nbool IsFinite(float val) { return std::isfinite(val); }\n\n/*\n  Returns a random floating-point value between min and max\n*/\nfloat RandomValueInInterval(float min, float max) {\n  return min + static_cast<float>(rand()) /\n                   (static_cast<float>(RAND_MAX) / (max - min));\n}\n\nint main(int argc, char *argv[]) {\n  constexpr size_t kRandomSeed = 1138;\n  constexpr size_t kRows = MATRIX_DIMENSION;\n  constexpr size_t kColumns = MATRIX_DIMENSION;\n  constexpr size_t kAMatrixSize = kRows * kColumns;\n  constexpr size_t kLMatrixSize = (kColumns * (kColumns + 1)) / 2;\n  constexpr bool kComplex = COMPLEX != 0;\n\n#if defined(FPGA_SIMULATOR)\n  constexpr size_t kMatricesToDecompose = 1;\n#else\n  constexpr size_t kMatricesToDecompose = 8;\n#endif\n\n  // Get the number of times we want to repeat the decomposition\n  // from the command line.\n#if defined(FPGA_EMULATOR)\n  int repetitions = argc > 1 ? atoi(argv[1]) : 16;\n#elif defined(FPGA_SIMULATOR)\n  int repetitions = argc > 1 ? atoi(argv[1]) : 1;\n#else\n  int repetitions = argc > 1 ? atoi(argv[1]) : 819200;\n#endif\n\n  if (repetitions < 1) {\n    std::cerr << \"Number of repetitions given is lower than 1.\" << std::endl;\n    std::cerr << \"The decomposition must occur at least 1 time.\" << std::endl;\n    std::cerr << \"Increase the number of repetitions (e.g. 16).\" << std::endl;\n    return 1;\n  }\n\n  try {\n\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // Enable the queue profiling to time the execution\n    sycl::queue q = sycl::queue(\n        selector, fpga_tools::exception_handler,\n        sycl::property_list{sycl::property::queue::enable_profiling()});\n    sycl::device device = q.get_device();\n\n    std::cout << \"Running on device: \"\n        << device.get_info<sycl::info::device::name>().c_str() \n        << std::endl;\n\n    // Select a type for this compile depending on the value of COMPLEX\n    using T = std::conditional_t<kComplex, ac_complex<float>, float>;\n\n    // Create vectors to hold all the input and output matrices\n    std::vector<T> a_matrix;\n    std::vector<T> l_matrix;\n\n    a_matrix.resize(kAMatrixSize * kMatricesToDecompose);\n    l_matrix.resize(kLMatrixSize * kMatricesToDecompose);\n\n    std::cout << \"Generating \" << kMatricesToDecompose << \" random \";\n    if constexpr (kComplex) {\n      std::cout << \"complex \";\n    } else {\n      std::cout << \"real \";\n    }\n    std::cout << \"matri\" << (kMatricesToDecompose > 1 ? \"ces\" : \"x\")\n              << \" of size \" << kRows << \"x\" << kColumns << \" \" << std::endl;\n\n    // Generate the random (hermitian and positive-definite) input matrices\n    srand(kRandomSeed);\n\n    for (int mat_idx = 0; mat_idx < kMatricesToDecompose; mat_idx++) {\n      // Construct a single random hermitian and positive-definite matrix\n      // To do so we, we generate a hermitian matrix A where each element\n      // is between 0 and 1.\n      // Since A(i,j) < 1 by construction and a symmetric diagonally dominant\n      // matrix is symmetric positive definite we can be sure to have a\n      // symmetric diagonally dominant matrix by adding nI to A\n      // A = A + n*eye(n);\n      // For complex matrices, the diagonal elements must be real.\n\n      // Random min and max values for the random floating-point value\n      // generation\n      constexpr float kRandomMin = 0;\n      constexpr float kRandomMax = 1;\n\n      int current_matrix = mat_idx * kAMatrixSize;\n\n      for (size_t row = 0; row < kRows; row++) {\n        for (size_t col = 0; col < kColumns; col++) {\n          float diag_scaling = (row == col) ? float{kRows} : 0;\n\n          int index = current_matrix + (col * kRows) + row;\n          int transpose_index = current_matrix + (row * kRows) + col;\n\n          if (col >= row) {\n            float random_real = RandomValueInInterval(kRandomMin, kRandomMax);\n#if COMPLEX == 0\n            a_matrix[index] = random_real + diag_scaling;\n#else\n            float random_imag =\n                row == col ? float{0}\n                           : RandomValueInInterval(kRandomMin, kRandomMax);\n            ac_complex<float> random_complex{random_real + diag_scaling,\n                                             random_imag};\n            a_matrix[index] = random_complex;\n#endif\n          } else {\n            // conjugate transpose\n#if COMPLEX == 0\n            a_matrix[index] = a_matrix[transpose_index];\n#else\n            a_matrix[index] = a_matrix[transpose_index].conj();\n#endif\n          }\n        }  // end of col\n      }    // end of row\n\n#ifdef DEBUG\n      std::cout << \"A MATRIX \" << mat_idx << std::endl;\n      for (size_t row = 0; row < kRows; row++) {\n        for (size_t col = 0; col < kColumns; col++) {\n          std::cout << a_matrix[current_matrix + (col * kRows) + row] << \" \";\n        }  // end of col\n        std::cout << std::endl;\n      }  // end of row\n#endif\n\n    }  // end of mat_idx\n\n    std::cout << \"Computing the Cholesky decomposition of \"\n              << kMatricesToDecompose << \" matri\"\n              << (kMatricesToDecompose > 1 ? \"ces \" : \"x \") << repetitions\n              << \" times\" << std::endl;\n\n    CholeskyDecomposition<T, kComplex>(a_matrix, l_matrix, q,\n                                          kMatricesToDecompose, repetitions);\n\n    // For output post-processing (op)\n    T l_matrix_op[kRows][kColumns];\n\n    // Floating-point error threshold value at which we decide that the design\n    // computed an incorrect value\n    constexpr float kErrorThreshold = 1e-4;\n\n    // Check L matrices\n    std::cout << \"Verifying results...\" << std::endl;\n    for (int mat_idx = 0; mat_idx < kMatricesToDecompose; mat_idx++) {\n      // Keep track of L element index\n      size_t l_idx = 0;\n\n      // Read the L matrix from the output vector to the l_matrix_op matrix\n      for (size_t i = 0; i < kRows; i++) {\n        for (size_t j = 0; j < kColumns; j++) {\n          if (j > i)\n            l_matrix_op[i][j] = 0;\n          else {\n            l_matrix_op[i][j] = l_matrix[(mat_idx * kLMatrixSize) + l_idx];\n            l_idx++;\n          }\n        }\n      }\n\n#ifdef DEBUG\n      std::cout << \"L MATRIX\" << std::endl;\n      for (size_t i = 0; i < kRows; i++) {\n        for (size_t j = 0; j < kColumns; j++) {\n          std::cout << l_matrix_op[i][j] << \" \";\n        }\n        std::cout << std::endl;\n      }\n#endif\n\n      // Count the number of errors found for this matrix\n      size_t error_count = 0;\n      bool error = false;\n\n      for (size_t i = 0; i < kRows; i++) {\n        for (size_t j = 0; j < kColumns; j++) {\n          // Compute LL* at index i,j\n          T l_l_star_ij{0};\n          for (size_t k = 0; k < kColumns; k++) {\n#if COMPLEX == 0\n            l_l_star_ij += (l_matrix_op[i][k] * l_matrix_op[j][k]);\n#else\n            l_l_star_ij += (l_matrix_op[i][k] * l_matrix_op[j][k].conj());\n#endif\n          }\n\n          // Verify that all the results are OK:\n          // LL* = A at index i,j\n          bool ll_star_eq_a;\n          // L is finite at index i,j\n          bool l_is_finite;\n\n          int current_matrix = mat_idx * kAMatrixSize;\n          int current_element = (j * kRows) + i;\n\n#if COMPLEX == 0\n          ll_star_eq_a = abs(a_matrix[current_matrix + current_element] -\n                             l_l_star_ij) < kErrorThreshold;\n\n#else\n          ll_star_eq_a = (abs(a_matrix[current_matrix + current_element].r() -\n                              l_l_star_ij.r()) < kErrorThreshold) &&\n                         (abs(a_matrix[current_matrix + current_element].i() -\n                              l_l_star_ij.i()) < kErrorThreshold);\n#endif\n\n          l_is_finite = ((i < kColumns) && IsFinite(l_matrix_op[i][j])) ||\n                        (i >= kColumns);\n\n          // If any of the checks failed\n          if (!ll_star_eq_a || !l_is_finite) {\n            // Increase the error count for this matrix\n            error_count++;\n\n            // Continue counting the errors even if we are going to\n            // produce an error\n            if (error) {\n              continue;\n            }\n\n            std::cerr << \"Error in matrix \" << mat_idx << std::endl;\n\n            if (!ll_star_eq_a) {\n              std::cerr\n                  << \"Error: A[\" << i << \"][\" << j << \"] = \"\n                  << a_matrix[(current_matrix * kAMatrixSize) + (j * kRows) + i]\n                  << \" but LL*[\" << i << \"][\" << j << \"] = \" << l_l_star_ij\n                  << std::endl;\n            }\n            if (!l_is_finite) {\n              std::cerr << \"L[\" << i << \"][\" << j << \"] = \" << l_matrix_op[i][j]\n                        << \" is not finite\" << std::endl;\n            }\n            error = true;\n          }\n        }  // end of j\n      }    // end of i\n\n      if (error_count > 0) {\n        std::cerr << std::endl << \"FAILED\" << std::endl;\n        std::cerr << std::endl\n                  << \"!!!!!!!!!!!!!! \" << error_count << \" errors\" << std::endl;\n        return 1;\n      }\n    }  // end of mat_idx\n\n    std::cout << std::endl << \"PASSED\" << std::endl;\n    return 0;\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::cerr << \"   If you are targeting FPGA hardware, \"\n                 \"ensure that your system is connected to an FPGA board that \"\n                 \"is set up correctly\"\n              << std::endl;\n    std::cerr << \"   If you are targeting the FPGA emulator, compile with \"\n                 \"-DFPGA_EMULATOR\"\n              << std::endl;\n\n    std::terminate();\n  } catch (std::bad_alloc const &e) {\n    std::cerr << \"Caught a memory allocation exception on the host: \"\n              << e.what() << std::endl;\n    std::cerr << \"   You can reduce the memory requirement by reducing the \"\n                 \"number of matrices generated. Specify a smaller number when \"\n                 \"running the executable.\"\n              << std::endl;\n    std::cerr << \"   In this run, more than \"\n              << ((kAMatrixSize + kLMatrixSize) * 2 * kMatricesToDecompose *\n                  sizeof(float)) /\n                     pow(2, 30)\n              << \" GBs of memory was requested for the decomposition of a \"\n              << \"matrix of size \" << kRows << \" x \" << kColumns << std::endl;\n    std::terminate();\n  }\n}  // end of main\n"
    },
    {
        "label": "board_test.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <iostream>\n\n#include \"exception_handler.hpp\"\n\n// Test related header files\n#include \"board_test.hpp\"\n\nint main(int argc, char* argv[]) {\n  // Always print small help at the beginning of board test\n  PrintHelp(0);\n\n  // Default is to run all tests\n  int test_to_run = 0;\n\n  // test_to_run value changed according to user selection if user has provided\n  // an input using \"-test=<test_number>\" option (see PrintHelp function for\n  // test details)\n  if (argc == 2) {\n    std::string tmp_test(argv[1]);\n    if ((tmp_test.compare(0, 6, \"-test=\")) == 0) {\n      test_to_run = std::stoi(tmp_test.substr(6));\n      if (test_to_run < 0 || test_to_run > 7) {\n        std::cerr\n            << \"Not a valid test number, please select the correct test from \"\n            << \"list above and re-run binary with updated value.\\n\\n\";\n        return 1;\n      }\n    } else if ((tmp_test.compare(0, 5, \"-help\")) == 0) {\n      PrintHelp(1);\n      return 0;\n    } else {\n      std::cerr << \"Incorrect argument passed to ./board_test.fpga! Cannot run \"\n                << \"test\\n, please refer to usage information above for \"\n                << \"correct command.\\nTerminating test!\\n\";\n      return 1;\n    }\n  }\n\n  if (test_to_run > 0)\n    std::cout << \"User has selected to run only test number \" << test_to_run\n              << \" from test list above\\n\";\n  else\n    std::cout << \"Running all tests \\n\";\n\n// Device Selection\n// Select either:\n//  - the FPGA emulator device (CPU emulation of the FPGA) using FPGA_EMULATOR\n//  macro\n//  - the FPGA device (a real FPGA)\n#if FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  // Variable ORed with result of each test\n  // Value of 0 at the end indicates all tests completed successfully\n  int ret = 0;\n\n  // Queue creation\n  try {\n    // queue properties to enable profiling\n    sycl::property_list q_prop_list{sycl::property::queue::enable_profiling()};\n\n    // Create a queue bound to the chosen device\n    // If the device is unavailable, a SYCL runtime exception is thrown\n    sycl::queue q(selector, fpga_tools::exception_handler, q_prop_list);\n\n    auto device = q.get_device();\n\n    // Print out the device information.\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>() \n              << std::endl;\n\n    // Create a oneAPI Shim object\n    ShimMetrics hldshim(q);\n\n    // Test 1 - Host speed and host read write test\n    if (test_to_run == 0 || test_to_run == 1) {\n      std::cout << \"\\n*****************************************************************\\n\"\n                << \"*********************** Host Speed Test *************************\\n\"\n                << \"*****************************************************************\\n\\n\";\n\n      ret |= hldshim.HostSpeed(q);\n\n      std::cout << \"\\n*****************************************************************\\n\"\n                << \"********************* Host Read Write Test **********************\\n\"\n                << \"*****************************************************************\\n\\n\";\n\n      // Tasks run in Host read write with dev_offset=0 (aligned dev addr):\n      // 1. write from unaligned host memory to aligned device memory address\n      // 2. read from aligned device memory to aligned host memory\n      size_t dev_offset = 0;\n      int ret_hostrw = hldshim.HostRWTest(q, dev_offset);\n      if (ret_hostrw != 0) {\n        std::cerr << \"Error: Host read write test failed with aligned dev \"\n                  << \"address (dev_offset = \" << dev_offset << \")\\n\"\n                  << \"\\nBOARD TEST FAILED\\n\";\n        return 1;\n      }\n// Do not run on SoC boards. ARM processor does not support unaligned memory\n// access\n#ifndef __arm__\n      // unaligned device addr\n      dev_offset = 3;\n      ret_hostrw = hldshim.HostRWTest(q, dev_offset);\n      if (ret_hostrw != 0) {\n        std::cerr << \"Error: Host read write test failed with unaligned dev \"\n                  << \"address (dev_offset = \" << dev_offset << \")\\n\"\n                  << \"\\nBOARD TEST FAILED\\n\";\n        return 1;\n      }\n#endif\n\n      if (!ret_hostrw) std::cout << \"\\nHOST READ-WRITE TEST PASSED!\\n\";\n\n      ret |= ret_hostrw;\n    }\n\n    // Test 2 - Kernel clock frequency (this is measured before all tests except\n    // 1)\n    if (test_to_run == 0 || test_to_run == 5 || test_to_run == 2 ||\n        test_to_run == 3 || test_to_run == 4 || test_to_run == 6 ||\n        test_to_run == 7) {\n      std::cout << \"\\n*****************************************************************\\n\"\n                << \"*******************  Kernel Clock Frequency Test  ***************\\n\"\n                << \"*****************************************************************\\n\\n\";\n\n#if defined(FPGA_EMULATOR)\n      std::cout << \"Kernel clock frequency test is not run in emulation, \"\n                << \"skipping this test \\n\";\n#else\n      // This test offers the option to skip reading compiled kernel frequency\n      // from reports using report_chk variable (either user does not have\n      // reports or purposely wants to skip when there is a bigger mismatch in\n      // measured vs compiled value) Ideally should be true as skipping this\n      // check can lead to erroneous behavior due to kernel clock frequency\n      // issues on hardware\n      bool report_chk = true;\n      int ret_kernel_clk = hldshim.KernelClkFreq(q, report_chk);\n      // If test failed and user has selected to check the Quartus compiled\n      // frequency, then terminate test\n      if (ret_kernel_clk && report_chk) {\n        std::cerr << \"\\nBOARD TEST FAILED\\n\";\n        return 1;\n      }\n\n      ret |= ret_kernel_clk;\n#endif\n    }\n\n    // Test 3 - Kernel Launch Test\n    if (test_to_run == 0 || test_to_run == 3) {\n      std::cout << \"\\n*****************************************************************\\n\"\n                << \"********************* Kernel Launch Test ************************\\n\"\n                << \"*****************************************************************\\n\\n\";\n\n      int ret_kernel_launch_test = hldshim.KernelLaunchTest(q);\n      if (ret_kernel_launch_test == 0) {\n        std::cout << \"\\nKERNEL_LAUNCH_TEST PASSED\\n\";\n      } else {\n        std::cerr << \"Error: Kernel Launch Test Failed\\n\"\n                  << \"\\nBOARD TEST FAILED\\n\";\n        return 1;\n      }\n\n      ret |= ret_kernel_launch_test;\n    }\n\n    // Test 4 - Kernel Latency Measurement\n    if (test_to_run == 0 || test_to_run == 4) {\n      std::cout << \"\\n*****************************************************************\\n\"\n                << \"********************  Kernel Latency  **************************\\n\"\n                << \"*****************************************************************\\n\\n\";\n\n      ret |= hldshim.KernelLatency(q);\n    }\n\n    // Test 5 - Kernel-to-Memory Read Write Test\n    if (test_to_run == 0 || test_to_run == 5) {\n      std::cout << \"\\n*****************************************************************\\n\"\n                << \"*************  Kernel-to-Memory Read Write Test  ***************\\n\"\n                << \"*****************************************************************\\n\\n\";\n\n      int ret_kernel_mem_rw = hldshim.KernelMemRW(q);\n      if (ret_kernel_mem_rw != 0) {\n        std::cerr << \"Error: kernel-memory read write test failed. \\n\"\n                  << \"\\nBOARD TEST FAILED\\n\";\n        return 1;\n      }\n\n      ret |= ret_kernel_mem_rw;\n    }\n\n    // Test 6 - Kernel-to-Memory Bandwidth Measurement\n    if (test_to_run == 0 || test_to_run == 6) {\n      std::cout << \"\\n*****************************************************************\\n\"\n                << \"*****************  Kernel-to-Memory Bandwidth  *****************\\n\"\n                << \"*****************************************************************\\n\\n\";\n\n      ret |= hldshim.KernelMemBW(q);\n    }\n\n    // Test 7 - USM\n    if (test_to_run == 0 || test_to_run == 7) {\n      std::cout << \"\\n*****************************************************************\\n\"\n                << \"***********************  USM Bandwidth  *************************\\n\"\n                << \"*****************************************************************\\n\\n\";\n#if defined(SUPPORTS_USM)\n      ret |= hldshim.USMBWTest(q);\n#else    \n      if (q.get_device().has(sycl::aspect::usm_host_allocations)) {\n        std::cout << \"USM support was detected but the SUPPORTS_USM macro was \"\n                  << \"not defined; USM-related tests will not run.\\nTo enable \"\n                  << \"these tests, please compile with the SUPPORTS_USM macro \"\n                  << \"defined.\\n\";\n      } else {\n        std::cout << \"Board does not support USM, skipping this test.\\n\";\n      }\n#endif\n    }\n  }  // End of try block\n\n  catch (sycl::exception const& e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                << \"system has a correctly configured FPGA board.\\n\"\n                << \"Run sys_check in the oneAPI root directory to verify.\\n\"\n                << \"If you are targeting the FPGA emulator, compile with \"\n                << \"-DFPGA_EMULATOR.\\n\";\n    }\n    // Caught exception, terminate program\n    std::terminate();\n  }  // End of catch block\n\n  // If value of returns from all tests is 0 (i.e. without\n  // errors) - Board test passed\n  if (ret == 0)\n    std::cout << \"\\nBOARD TEST PASSED\\n\";\n  else\n    std::cerr << \"\\nBOARD TEST FAILED\\n\";\n  return ret;\n\n}  // End of main\n"
    },
    {
        "label": "board_test.hpp",
        "data": "#include <sycl/sycl.hpp>\n#include <cmath>\n#include <vector>\n\n#include \"host_speed.hpp\"\n\n#if defined(SUPPORTS_USM)\n#include \"usm_speed.hpp\"\n#endif\n\n// Pre-declare kernel name to prevent name mangling\n// This is an FPGA best practice that makes it easier to identify the kernel in\n// the optimization reports.\nclass NopNDRange;\nclass NopSingleTask;\nclass KernelSender;\nclass KernelReceiver;\nclass MemReadWriteStream;\nclass MemReadWriteStreamNDRange;\nclass MemWriteStream;\nclass MemReadStream;\n\n// Pipe used between KernelSender and KernelReceiver -\n// ShimMetrics::KernelLaunchTest(queue &q) function\nusing SendertoReceiverPipe =\n    sycl::ext::intel::pipe<        // Defined in the SYCL headers\n        class SenderReceiverPipe,  // An identifier for the pipe\n        unsigned int,              // The type of data in the pipe\n        1>;                        // The capacity of the pipe\n\n/////////////////////////////////\n// **** class ShimMetrics **** //\n/////////////////////////////////\n\n// Object stores oneAPI shim metrics\n// Member Functions (details closer to function definition):\n// ShimMetrics - Constructor; initializes all metrics and obtains maximum device\n// allocation and maximum device global memory TestGlobalMem - Host to device\n// global memory interface check HostSpeed - Host to device global memory\n// bandwidth measurement HostRWTest - Unaligned read & writes from host to\n// device global memory KernelClkFreq - Kernel clock frequency measurement\n// KernelLatency - Kernel latency measurement\n// KernelLaunchTest - Host to kernel interface check\n// KernelMemRW - Kernel to device global memory interface check\n// KernelMemBW - Kernel to device global memory bandwidth measurement\n\nclass ShimMetrics {\n public:\n  ShimMetrics(sycl::queue &q)\n      : h2d_rd_bw_{0},\n        h2d_wr_bw_{0},\n        h2d_rd_wr_bw_{0},\n        h2d_rw_test_{false},\n        kernel_freq_{0},\n        kernel_latency_{0},\n        kernel_thruput_{0},\n        kernel_mem_bw_{0},\n        kernel_mem_rw_test_{false} {\n    max_buffer_size_ =\n        q.get_device().get_info<sycl::info::device::global_mem_size>();\n#if defined(FPGA_EMULATOR)\n    max_alloc_size_ =\n        512 * kMiB;  // Limiting size of all buffers used in test for emulation\n#else\n    max_alloc_size_ =\n        q.get_device().get_info<sycl::info::device::max_mem_alloc_size>();\n#endif\n    std::cout << \"\\nclGetDeviceInfo CL_DEVICE_GLOBAL_MEM_SIZE = \"\n              << max_buffer_size_ << \"\\n\";\n    std::cout << \"clGetDeviceInfo CL_DEVICE_MAX_MEM_ALLOC_SIZE = \"\n              << max_alloc_size_ << \"\\n\";\n    std::cout << \"Device buffer size available for allocation = \"\n              << max_alloc_size_ << \" bytes\\n\";\n    board_info_.fmax_info_ = false;\n    board_info_.quartus_fmax_ = 0.0;\n  }\n\n  ~ShimMetrics() {}\n\n  size_t TestGlobalMem(sycl::queue &q);\n  int HostSpeed(sycl::queue &q);\n  int HostRWTest(sycl::queue &q, size_t dev_offset = 0);\n  int KernelClkFreq(sycl::queue &q, bool report_chk = true);\n  int KernelLaunchTest(sycl::queue &q);\n  int KernelLatency(sycl::queue &q);\n  int KernelMemRW(sycl::queue &q);\n  int KernelMemBW(sycl::queue &q);\n#if defined(SUPPORTS_USM)\n  int USMBWTest(sycl::queue &q);\n#endif\n  void ReadBinary();\n\n private:\n  float h2d_rd_bw_;\n  float h2d_wr_bw_;\n  float h2d_rd_wr_bw_;\n  bool h2d_rw_test_;\n  float kernel_freq_;\n  float kernel_latency_;\n  float kernel_thruput_;\n  float kernel_mem_bw_;\n  bool kernel_mem_rw_test_;\n  cl_ulong max_buffer_size_;\n  cl_ulong max_alloc_size_;\n  struct BoardSpec {\n    bool fmax_info_;\n    float quartus_fmax_;\n  } board_info_;\n};\n\n//////////////////////////////////////\n// **** TestGlobalMem function **** //\n//////////////////////////////////////\n\n// Input:\n// queue &q - queue to submit operation\n// Returns:\n// Number of errors in transfer OR 1 if device memory allocation is 0 or test\n// fails (return 0 means test passed)\n\n// The function does the following tasks:\n// 1. Get maximum device global memory allocation size\n// 2. Allocate host memory to use to store data to be written to and read from\n// device\n// 3. Write to device global memory\n// 4. Read from device global memory\n// 5. Verify data read back matches value written\n// 6. Report read, write bandwidth\n// If this test passes (returns 0), the host to device global memory interface\n// is working fine\n\nsize_t ShimMetrics::TestGlobalMem(sycl::queue &q) {\n  // Data is transferred from host to device in kMaxHostChunk size transfers\n  // (size in bytes)\n  constexpr size_t kMaxHostChunk = 512 * kMiB;\n\n  // Test fails if max alloc size is 0\n  if (max_alloc_size_ == 0) {\n    std::cerr << \"Maximum global memory allocation supported by Sycl device is \"\n              << \"0! Cannot run host speed test\\n\\n\";\n    return 1;\n  }\n\n  // **** Create device buffer ****//\n  // Creating device buffer to span all usable global memory space on device\n  sycl::buffer<unsigned long, 1> dev_buf{\n      sycl::range<1>{(max_alloc_size_ / sizeof(unsigned long))}};\n  std::cout << \"Size of buffer created = \" << dev_buf.byte_size() << \" bytes\\n\";\n\n  // **** Host memory allocation **** //\n  /*<hostbuf> is used to store data\n  to be written to device buffer as well as data that is read back\n  While loop retries allocation for smaller chunk if kMaxHostChunk allocation\n  fails, minimum size is 512 bytes*/\n  // Size of allocated host memory (in bytes)\n  size_t host_size = kMaxHostChunk;\n  unsigned long *hostbuf = new (std::nothrow) unsigned long[host_size];\n\n  while ((host_size >= (kKiB / 2)) && hostbuf == NULL) {\n    host_size = host_size / 2;\n    hostbuf = new (std::nothrow) unsigned long[host_size];\n  }\n  if (hostbuf == NULL) {\n    std::cerr << \"Error: Allocation of host buffers for the test failed.\"\n              << \"Cannot run host speed test\\n\\n\";\n    return 1;\n  }\n\n  // **** Writing data from host memory to device global memory **** //\n\n  // Number of bytes remaining to transfer to device memory\n  unsigned long bytes_rem = max_alloc_size_;\n  // offset at which write should begin in device global memory\n  unsigned long offset = 0;\n  // Total time to write\n  double sum_time_ns = 0.0;\n\n  // Copying host memory to device buffer in chunks\n  std::cout << \"Writing \" << (max_alloc_size_ / kMiB)\n            << \" MiB to device global memory ... \";\n\n  // Device global memory larger (i.e. max_alloc_size_) than host memory size\n  // (i.e. host_size) Chunks of host memory size written to device memory in\n  // iterations\n  while (bytes_rem > 0) {\n    unsigned long chunk = bytes_rem;\n    if (chunk > host_size) chunk = host_size;\n\n    // Initializing host buffer\n    for (unsigned long i = 0; i < chunk / sizeof(unsigned long); ++i) {\n      hostbuf[i] = offset + i;\n    }\n\n    // Submit command to copy (explicit copy from host to device)\n    auto h2d_copy_e = q.submit([&](sycl::handler &h) {\n      // Range of buffer that needs to accessed\n      auto buf_range = chunk / sizeof(unsigned long);\n      // offset starts at 0 - incremented by chunk size each iteration\n      auto buf_offset = offset / sizeof(unsigned long);\n      // Access host_size range of buffer starting at buf_offset\n      sycl::accessor mem(dev_buf, h, buf_range, buf_offset);\n      // Writing from host memory to device buffer\n      h.copy(hostbuf, mem);\n    });\n\n    // Wait for explicit copy from host memory to device buffer to complete\n    h2d_copy_e.wait();\n\n    // Get time for copy operation using Sycl event information (return in\n    // nanoseconds)\n    sum_time_ns += SyclGetQStExecTimeNs(h2d_copy_e);\n\n    // Increment offset and decrement remaining bytes by size of transfer\n    offset += chunk;\n    bytes_rem -= chunk;\n\n  }  // End of write-to-device while loop\n\n  // Report write bandwidth\n  std::cout << (((float)max_alloc_size_ / kMB) / ((float)sum_time_ns * 1e-9))\n            << \" MB/s\\n\";\n\n  // **** Reading data from device global memory to host memory **** //\n\n  // Read back all of memory and verify\n  std::cout << \"Reading \" << (max_alloc_size_ / kMiB)\n            << \" MiB from device global memory ... \";\n\n  // Reset variables for read loop\n  bytes_rem = max_alloc_size_;\n  // Start reading at offset 0\n  offset = 0;\n  // Total time to read\n  sum_time_ns = 0.0;\n\n  // The same host memory is used to read back values, resetting it to 0\n  for (unsigned long i = 0; i < host_size / sizeof(unsigned long); ++i) {\n    hostbuf[i] = 0;\n  }\n\n  // Variables for error calculation (verify value read back matches written\n  // value)\n  unsigned long errors = 0;\n  unsigned long compare_count = 0;\n  unsigned long chunk_errors = 0;\n  unsigned long chunk_cnt_rd = 0;\n\n  // Device global memory larger (i.e. max_alloc_size_) than host memory size\n  // (i.e. host_size) Read back chunks of host memory size from device memory in\n  // iterations\n  while (bytes_rem > 0) {\n    unsigned long chunk = bytes_rem;\n    if (chunk > host_size) chunk = host_size;\n\n    // Submit copy operation (explicit copy from device to host)\n    auto d2h_copy_e = q.submit([&](sycl::handler &h) {\n      // Range of buffer that needs to accessed\n      auto buf_range = chunk / sizeof(unsigned long);\n      // offset starts at 0 - incremented by chunk size each iteration\n      auto buf_offset = offset / sizeof(unsigned long);\n      // Access host_size range of buffer starting at buf_offset\n      sycl::accessor mem(dev_buf, h, buf_range, buf_offset);\n      // Reading from device buffer into host memory\n      h.copy(mem, hostbuf);\n    });\n\n    // Wait for explicit copy from host memory to device buffer to complete\n    d2h_copy_e.wait();\n\n    // Get time for copy operation using Sycl event information (return in\n    // nanoseconds)\n    sum_time_ns += SyclGetQStExecTimeNs(d2h_copy_e);  // Nanoseconds\n\n    // **** Verification **** //\n\n    // Verify data read back matches data that was written, if not increment\n    // error count\n    for (unsigned long i = 0; i < chunk / sizeof(unsigned long); ++i) {\n      compare_count++;\n      if (hostbuf[i] != (i + offset)) {\n        ++errors;\n        if (errors <= 32) {  // only print 32 errors\n          std::cerr << \"Verification failure at element \" << i << \", expected \"\n                    << i << \" but read back \" << hostbuf[i] << \"\\n\";\n        }\n        chunk_errors++;\n        if (chunk_errors <= 32) {  // only print 32 errors\n          std::cerr << \"Verification failure at element \" << i << \"; chunk_cnt \"\n                    << chunk_cnt_rd << \";, expected 0x\" << std::hex << i\n                    << \" \\\\ \" << std::dec << i << \" but read back 0x\"\n                    << std::hex << hostbuf[i] << \" \\\\ \" << std::dec\n                    << hostbuf[i] << \"\\n\";\n        }\n      }\n    }  // End of for loop\n\n    if (chunk_errors > 0) {\n      std::cerr << \"chunk_errors for chunk \" << chunk_cnt_rd << \" was \"\n                << chunk_errors << \" \\\\ 0x\" << std::hex << chunk_errors\n                << std::dec\n                << \"\\n\";  // Restoring manipulator to decimal in the end of cout\n      chunk_errors = 0;   // reset for next chunk\n    }\n\n    // Increment offset and decrement remaining bytes by size of transfer\n    offset += chunk;\n    bytes_rem -= chunk;\n    chunk_cnt_rd++;\n\n  }  // End of read-from-device while loop\n\n  // Report read bandwidth\n  std::cout << (((float)max_alloc_size_ / kMB) / ((float)sum_time_ns * 1e-9))\n            << \" MB/s\\n\";\n\n  // **** Report results from global memory test **** //\n\n  std::cout << \"Verifying data ...\\n\";\n\n  if (errors == 0) {\n    std::cout << \"Successfully wrote and readback \" << (max_alloc_size_ / kMiB)\n              << \" MB buffer\\n\\n\";\n  } else {\n    std::cout << \"Wrote and readback \" << (max_alloc_size_ / kMiB)\n              << \" MB buffer\\n\";\n    std::cerr\n        << \"Failed write/readback test with \" << errors << \" errors out of \"\n        << compare_count << \" \\\\ 0x\" << std::hex << compare_count\n        << std::dec  // Restoring manipulator to decimal at the end of cout\n        << \" comparisons\\n\\n\";\n  }\n\n  // Free allocated host memory\n  delete[] hostbuf;\n  return errors;\n}\n\n//////////////////////////////////\n// **** HostSpeed function **** //\n//////////////////////////////////\n\n// Inputs:\n// queue &q - queue to submit operation\n// Returns:\n// 0 is test passes, 1 if test fails\n\n// The function does the following tasks:\n// 1. Test entire device global memory by writing and reading to it\n// 2. Write to device global memory in smaller chunks and measure transfer time\n// for each chunk\n// 3. Read back data from device global memory and measure transfer time for\n// each chunk\n// 4. Verify data read back from device matches data written to device\n// 5. Calculate write bandwidth, read bandwidth and read-write bandwidth from\n// results of above transfers\n\n// Following additional functions are used for the above tasks:\n// More details about these funtions can be found with the corresponsing\n// definitions\n// 1. size_t TestGlobalMem(queue &q)\n// 2. struct Speed WriteSpeed(queue &q, buffer<char,1> &device_buffer, char\n// *hostbuf_wr, size_t block_bytes, size_t total_bytes)\n// 3. struct Speed ReadSpeed(queue &q, buffer<char,1> &device_buffer, char\n// *hostbuf_rd, size_t block_bytes, size_t total_bytes)\n// 4. bool CheckResults\n// 4. unsigned long SyclGetQStExecTimeNs(event e)\n// 5. unsigned long SyclGetTotalTimeNs(event first_evt, event last_evt)\n\nint ShimMetrics::HostSpeed(sycl::queue &q) {\n  // Total bytes to transfer\n  constexpr size_t kMaxBytes = 8 * kMiB;  // 8 MB;\n  constexpr size_t kMaxChars = kMaxBytes / sizeof(char);\n\n  // Block size of each transfer in bytes\n  constexpr size_t kMinBytes = 32 * kKiB;  // 32 KB\n  size_t block_bytes = kMinBytes;\n\n  // Call function to verify write to and read from the entire device global\n  // memory\n  if (ShimMetrics::TestGlobalMem(q) != 0) {\n    std::cerr << \"Error: Global memory test failed\\n\";\n    return 1;\n  }\n\n  // **** Device buffer **** //\n\n  // Creating device buffer to span kMaxBytes size\n  // Buffer that WriteSpeed and ReadSpeed functions write to & read from\n  sycl::buffer<char, 1> device_buffer{sycl::range<1>{kMaxChars}};\n\n  // **** Host memory allocation and initialization **** //\n\n  // hostbuf_wr is used by WriteSpeed function to get input data to device\n  // buffer hostbuf_rd is used by ReadSpeed function to store data read from\n  // device buffer\n  char *hostbuf_rd = new char[kMaxBytes];\n  char *hostbuf_wr = new char[kMaxBytes];\n\n  // Initializing input on host to be written to device buffer\n  srand(kRandomSeed);\n  // Create sequence: 0 rand1 ~2 rand2 4 ...\n  for (size_t j = 0; j < kMaxChars; j++) {\n    if (j % 2 == 0)\n      hostbuf_wr[j] = (j & 2) ? ~j : j;\n    else\n      hostbuf_wr[j] = rand() * rand();\n  }\n\n  // *** Warm-up link before measuring bandwidth *** //\n\n  // Writing to device buffer from initialized host memory\n  WriteSpeed(q, device_buffer, hostbuf_wr, block_bytes, kMaxBytes);\n  // Reading from device buffer into allocated host memory\n  ReadSpeed(q, device_buffer, hostbuf_rd, block_bytes, kMaxBytes);\n\n  // **** Block transfers to measure bandwidth **** //\n\n  // Total number of iterations to write total bytes (i.e. kMaxBytes) in blocks\n  // of block_bytes size\n  size_t iterations = 1;\n  for (size_t i = kMaxBytes / block_bytes; i >> 1; i = i >> 1) iterations++;\n\n  // struct Speed in defined in hostspeed.hpp and is used to store transfer\n  // times Creating array of struct to store output from each iteration The\n  // values from each iteration are analyzed to report bandwidth\n  std::vector<struct Speed> rd_bw;\n  rd_bw.resize(iterations);\n\n  std::vector<struct Speed> wr_bw;\n  wr_bw.resize(iterations);\n\n  // std::cout is manipulated to format output\n  // Storing old state of std::cout to restore\n  std::ios old_state(nullptr);\n  old_state.copyfmt(std::cout);\n\n  // Variable accumulate store result of each iteration\n  bool result = true;\n\n  // Iterate till total bytes (i.e. kMaxBytes) have been transferred\n  // and accumulate results in rd_bw and wr_bw structs\n  for (size_t i = 0; i < iterations; i++, block_bytes *= 2) {\n    std::cout << \"Transferring \" << (kMaxBytes / kKiB) << \" KBs in \"\n              << (kMaxBytes / block_bytes) << \" \" << (block_bytes / kKiB)\n              << \" KB blocks ...\\n\";\n    wr_bw[i] = WriteSpeed(q, device_buffer, hostbuf_wr, block_bytes, kMaxBytes);\n    rd_bw[i] = ReadSpeed(q, device_buffer, hostbuf_rd, block_bytes, kMaxBytes);\n    // Verify value read back matches value that was written to device\n    result &= CheckResults(hostbuf_wr, hostbuf_rd, kMaxChars);\n    // Restoring old format after each CheckResults function call to print\n    // correct format in current loop\n    std::cout.copyfmt(old_state);\n  }\n\n  // **** Report results **** //\n  // The write and read have already completed in the for loop with calls to\n  // ReadSpeed, WriteSpeed functions The two for loops below simply format and\n  // print the output for these tests\n\n  // **** Report results from writes to device **** //\n\n  // Restoring value of block_bytes as it changed in for loop above\n  block_bytes = kMinBytes;\n\n  // Fastest transfer value used in read-write bandwidth calculation\n  float write_topspeed = 0;\n\n  std::cout << \"\\nWriting \" << (kMaxBytes / kKiB)\n            << \" KBs with block size (in bytes) below:\\n\";\n  std::cout << \"\\nBlock_Size Avg Max Min End-End (MB/s)\\n\";\n\n  for (size_t i = 0; i < iterations; i++, block_bytes *= 2) {\n    std::cout << std::setw(8) << block_bytes << \" \" << std::setprecision(2)\n              << std::fixed << wr_bw[i].average << \" \" << wr_bw[i].fastest\n              << \" \" << wr_bw[i].slowest << \" \" << wr_bw[i].total << \" \\n\";\n    if (wr_bw[i].fastest > write_topspeed) write_topspeed = wr_bw[i].fastest;\n    if (wr_bw[i].total > write_topspeed) write_topspeed = wr_bw[i].total;\n    // Restoring old format after each CheckResults function call to print\n    // correct format in current loop\n    std::cout.copyfmt(old_state);\n  }\n\n  // **** Report results from read from device **** //\n\n  // Restoring value of block_bytes as it changed in for loop above\n  block_bytes = kMinBytes;\n\n  // Fastest transfer value used in read-write bandwidth calculation\n  float read_topspeed = 0;\n\n  std::cout << \"\\nReading \" << (kMaxBytes / kKiB)\n            << \" KBs with block size (in bytes) below:\\n\";\n  std::cout << \"\\nBlock_Size Avg Max Min End-End (MB/s)\\n\";\n\n  for (size_t i = 0; i < iterations; i++, block_bytes *= 2) {\n    std::cout << std::setw(8) << block_bytes << \" \" << std::setprecision(2)\n              << std::fixed << rd_bw[i].average << \" \" << rd_bw[i].fastest\n              << \" \" << rd_bw[i].slowest << \" \" << rd_bw[i].total << \" \\n\";\n    if (rd_bw[i].fastest > read_topspeed) read_topspeed = rd_bw[i].fastest;\n    if (rd_bw[i].total > read_topspeed) read_topspeed = rd_bw[i].total;\n    // Restoring old format after each CheckResults function call to print\n    // correct format in current loop\n    std::cout.copyfmt(old_state);\n  }\n\n  h2d_rd_bw_ = read_topspeed;\n  h2d_wr_bw_ = write_topspeed;\n  h2d_rd_wr_bw_ = ((read_topspeed + write_topspeed) / 2);\n\n  std::cout << \"\\nHost write top speed = \" << std::setprecision(2) << std::fixed\n            << write_topspeed << \" MB/s\\n\";\n  std::cout << \"Host read top speed = \" << read_topspeed << \" MB/s\\n\\n\";\n  std::cout << \"\\nHOST-TO-MEMORY BANDWIDTH = \" << std::setprecision(0)\n            << ((read_topspeed + write_topspeed) / 2) << \" MB/s\\n\\n\";\n\n  // Restoring old format after each CheckResults function call to print correct\n  // format in current loop\n  std::cout.copyfmt(old_state);\n\n  // Fail if any iteration of the transfer failed\n  if (!result) std::cerr << \"\\nFAILURE!\\n\";\n\n  // Free allocated host memory\n  delete[] hostbuf_rd;\n  delete[] hostbuf_wr;\n\n  return (result) ? 0 : 1;\n}\n\n///////////////////////////////////\n// **** HostRWTest function **** //\n///////////////////////////////////\n\n// Inputs:\n// 1. queue &q - queue to submit operation\n// 2. size_t dev_offset - device buffer offset (for transfer from aligned memory\n// in device, the default value of this is 0) Returns: 0 is test passes,\n// terminates program if test fails\n\n// The function does the following tasks:\n// 1. Creates a device buffer sized an odd number of bytes\n// 2. Host memory allocation for both read and write with padding to prenent\n// overflow during unaligned transfer\n// 3. Increments pointer to host memory to make it an unaligned address\n// 4. Writes data from this unaligned address to device global memory\n// 5. Reads back data from device global memory to aligned host memory pointer\n// 6. Verifies data read back matches data written\n// Program terminates if verification fails\n\nint ShimMetrics::HostRWTest(sycl::queue &q, size_t dev_offset) {\n  // Bytes to transfer (1KB)\n  constexpr size_t kMaxBytes_rw = kKiB;\n\n  // **** Device and host memory offsets to make them unaligned **** //\n\n  // Device offset is passed from calling function\n\n  // Selected host memory (for input to device) offset for unaligned transfer =\n  // 5\n  constexpr signed int kHostInOffset = 5;\n  // Selected host memory (to read back from device) offset for read back = 8\n  constexpr signed int kHostRdOffset = 8;\n\n  std::cout << \"--- Running host read write test with device offset \"\n            << dev_offset << \"\\n\";\n\n  // **** Device buffer creation **** //\n\n  // Expanding device buffer size; odd number of bytes (i.e. +3) makes sure that\n  // DMA is not aligned\n  constexpr size_t kOddMaxBytes = kMaxBytes_rw + 3;\n  // Device buffer of kOddMaxbytes\n  sycl::buffer<char, 1> dev_buf(sycl::range<1>{kOddMaxBytes});\n\n  // **** Host memory allocation and initialization **** //\n\n  // Padding both host memory blocks with extra space to avoid overflow during\n  // unaligned transfers\n\n  // Allocating host memory for input to device buffer\n  char *host_in_buf =\n      new char[kMaxBytes_rw +\n               (2 * kHostInOffset)];  // Padding on both sides of memory, hence\n                                      // increment size by 2 * host_in_offset\n  // Save original memory address before offset\n  char *host_in_buf_ptr = host_in_buf;\n\n  // Initialize host memory with some invalid data\n  char invalid_host_input = -6;\n  for (size_t j = 0; j < ((kMaxBytes_rw + (2 * kHostInOffset)) / sizeof(char));\n       j++) {\n    host_in_buf[j] = invalid_host_input;\n  }\n  // Increment pointer to make input host memory pointer non-aligned to test\n  // un-aligned host ptr to un-aligned device ptr transfer\n  host_in_buf += kHostInOffset;\n\n  // Allocating host memory to read back into from device buffer\n  char *host_rd_buf =\n      new char[kMaxBytes_rw +\n               (2 * kHostRdOffset)];  // Padding on both sides of memory, hence\n                                      // increment size by 2 * host_rd_offset\n  // Save original memory address before offset\n  char *host_rd_buf_ptr = host_rd_buf;\n\n  // Initialize host memory with some invalid data\n  char invalid_read_back = -3;\n  for (size_t j = 0; j < ((kMaxBytes_rw + (2 * kHostRdOffset)) / sizeof(char));\n       j++) {\n    host_rd_buf[j] = invalid_read_back;\n  }\n  // Increment pointer to make read back memory pointer aligned to test reading\n  // from un-aligned device ptr to aligned host ptr\n  host_rd_buf += kHostRdOffset;\n\n#ifdef DEBUG\n  std::cout << \"host input buf = \" << host_in_buf << \" , \"\n            << \"host read back buf = \" << host_rd_buf << \"\\n\";\n#endif\n\n  srand(kRandomSeed);\n\n  // **** Write to and read from device global memory **** //\n\n  // Non-DMA read/writes of all sizes upto 1024\n  for (size_t i = 1; i <= kMaxBytes_rw; i++) {\n#ifdef DEBUG\n    std::cout << \"Read/write of \" << i << \" bytes\\n\";\n#endif\n\n    // host will have unique values for every write\n    for (size_t j = 0; j < i; j++) {\n      host_in_buf[j] = (char)rand();\n    }\n\n    // **** Write to device global memory **** //\n\n    // Submit copy operation (explicit copy from host to device)\n    q.submit([&](sycl::handler &h) {\n       // Range of buffer that needs to accessed = i bytes (chars)\n       // Device buffer is accessed at dev_offset\n       // Using +3 offset on aligned device pointer ensures that DMA is never\n       // used (because the host ptr is not aligned)\n       sycl::accessor mem(dev_buf, h, i, dev_offset);\n       // Writing from host memory to device buffer\n       h.copy(host_in_buf, mem);\n     }).wait();  // Wait for copy to complete\n\n    // **** Read from device global memory **** //\n\n    // Submit copy operation (explicit copy from device to host)\n    q.submit([&](sycl::handler &h) {\n       // Range of buffer that needs to accessed = i bytes (chars)\n       // Device buffer is accessed at dev_offset\n       sycl::accessor mem(dev_buf, h, i, dev_offset);\n       // Reading from device buffer into host memory\n       h.copy(mem, host_rd_buf);\n     }).wait();  // Wait for copy to complete\n\n// Verify values read back match the input\n#ifdef DEBUG\n    std::cout << host_rd_buf[0] << \" , \" << host_in_buf[0] << \"\\n\";\n#endif\n\n    if (memcmp(host_in_buf, host_rd_buf, i) != 0) {\n      std::cerr << i << \" bytes read/write FAILED!\\n\";\n      for (size_t m = 0; m < i; m++) {\n        if (host_in_buf[m] != host_rd_buf[m]) {\n          std::cerr << \"char #\" << m\n                    << \" , host input buffer = \" << host_in_buf[m]\n                    << \" , host read back buffer = \" << host_rd_buf[m] << \"\\n\";\n        }\n      }\n      assert(0);\n    }\n\n    // make sure bounds on both ends of buffer are ok\n    for (signed int k = (-1 * kHostRdOffset); k < kHostRdOffset; k++) {\n      if (k < 0)\n        assert(host_rd_buf[k] == invalid_read_back);\n      else\n        assert(host_rd_buf[i + k] == invalid_read_back);\n    }\n\n  }  // End of for loop for writing/reading all bytes\n\n  // Free allocated host memory\n  delete[] host_in_buf_ptr;\n  delete[] host_rd_buf_ptr;\n\n  // Unaligned transfers completed successfully, test passed\n  h2d_rw_test_ = true;\n  return 0;\n}\n\n//////////////////////////////////////\n// **** KernelClkFreq function **** //\n//////////////////////////////////////\n\n// Inputs:\n// queue &q - queue to submit operation\n// bool report_chk - control if Quartus compiled frequency should be read\n// Returns:\n// 0 is test passes, 1 if test fails\n\n// The function does the following tasks:\n// 1. Launches an no-operation NDRange kernel with global size 128 MB\n// 2. Measures time taken for the above NDRange kernel using Sycl event\n// profiling information\n// 3. Obtain kernel clock frequency based on time take for 128 Mglobal\n// operations (NDRange)\n// 4. If the <report_chk> is true, compare the above hardware frequency with\n// Quartus compiled frequency\n// 5. Return 0 (test pass) if measured frequency is within 2 of Quartus compiled\n// frequency, else report error and terminate test\n// NOTE: If <report_chk> is set to false, comparison with Quartus compiled\n// frequency is not done and remaining tests in board_test continue without\n// this frequency check of 2% error tolerance\n\nint ShimMetrics::KernelClkFreq(sycl::queue &q, bool report_chk) {\n  // **** Launching an empty kernel (no op) **** //\n\n  // ND Range of kernel to launch\n  constexpr size_t kTotalBytes =\n      128 * kMiB;  // 128 MB - this is the min amount known to be available on\n                  // device memory (minimum on device - e.g. Cyclone V)\n  constexpr size_t kGlobalSize = kTotalBytes / (sizeof(unsigned));\n\n  auto e = q.submit([&](sycl::handler &h) {\n    // Global range (1 dimension)\n    constexpr size_t kN = kGlobalSize;\n    // Work group Size (1 dimension)\n    constexpr size_t kReqdWgSize = 32 * kKiB;  // 32 KB\n    h.parallel_for<NopNDRange>(\n        sycl::nd_range<1>(sycl::range<1>(kN), sycl::range<1>(kReqdWgSize)), [=\n    ](auto id) [[sycl::reqd_work_group_size(kReqdWgSize)]]{});\n  });\n  // Wait for operation to complete\n  e.wait();\n\n  // **** Get time for kernel event **** //\n\n  float time = SyclGetQStExecTimeNs(e);\n  kernel_freq_ =\n      ((float)kGlobalSize) /\n      (time / 1000.0f);  // Time is returned in nanoseconds,\n                         // converting global size to Mega and ns to s\n\n  // **** Compare measured clock frequency with Quartus Prime compiled fmax **** //\n\n  // Check Quartus reports if user has selected this (true by default)\n  if (report_chk) {\n    ShimMetrics::ReadBinary();\n    if (!board_info_.fmax_info_) {\n      std::cerr\n          << \"Failed to read Quartus compiled fmax from \" << kBinaryName\n          << \"please ensure full kernel compile has run and \"\n          << \"hardware generation completed successfully.\\n\"\n          << \"Reporting measured frequency and terminating test, \"\n          << \"none of the other tests will run as hardware frequency \"\n          << \"may not be the expected value and may lead to functional \"\n          << \"errors.\\n\\n\"\n          << \"Measured Frequency = \" << kernel_freq_ << \"\\n\\n\"\n          << \"If you wish to override this failure, please set \"\n          << \"\\\"report_chk\\\" variable to \\\"false\\\" in <board_test.cpp> and \"\n          << \"recompile host code using \\\"-reuse-exe=board_test.fpga\\\" \"\n          << \"option in compile command.\\n\"\n          << \" *** NOTE ***: Please run complete board_test at least once and \"\n          << \"ensure the hardware frequency matches expected frequency, \"\n\t\t  << \"mismatch may lead to functional errors.\\n\\n\";\n      return 1;\n    } else {\n      // Quartus compiled frequency found, report it\n      std::cout << \"Measured Frequency    =   \" << kernel_freq_ << \" MHz \\n\";\n      std::cout << \"Quartus Compiled Frequency  =   \"\n                << board_info_.quartus_fmax_ << \" MHz \\n\\n\";\n      // Check that hardware frequency is within 2% of Quartus compiled\n      // frequency, terminate test if its not\n      float PercentError = (std::fabs(board_info_.quartus_fmax_ - kernel_freq_) /\n                            (board_info_.quartus_fmax_)) *\n                           100;\n      if (PercentError < 2)\n        std::cout << \"Measured Clock frequency is within 2 percent of \"\n                  << \"Quartus compiled frequency. \\n\";\n      else {\n        std::cerr\n            << \"\\nError: measured clock frequency not within 2 \"\n            << \"percent of Quartus compiled frequency. \\n\"\n            << \"Terminating test.\\n\"\n            << \"If you wish to override this failure, please set \"\n            << \"\\\"report_chk\\\" variable to \\\"false\\\" in <board_test.cpp> and \"\n            << \"recompile host code using \\\"-reuse-exe=board_test.fpga\\\" \"\n            << \"option in compile command.\\n\"\n            << \" *** NOTE ***: Please run complete board_test at least once \"\n            << \"and ensure the hardware frequency matches expected frequency, \"\n\t\t\t<< \"mismatch may lead to functional errors.\\n\\n\";\n        return 1;\n      }\n    }\n  } else {\n    // User has selected to not to compare measured frequency with Quartus\n    // compiled frequency, report and continue other tests\n    std::cout\n        << \"*** NOTE ***: User has selected to turn off the comparison of \"\n        << \"measured frequency with Quartus compiled frequency by setting the \"\n        << \"\\\"report_chk\\\" variable to \\\"false\\\" in <board_test.cpp>\\n\"\n        << \"The Quartus compiled frequency will not be reported and the \"\n        << \"remaining tests will run without this check\\n\\n\"\n        << \" *** NOTE ***: Please run complete board_test at least once and \"\n        << \"ensure the hardware frequency matches expected frequency, \"\n\t\t<< \"mismatch may lead to functional errors.\\n\\n\"\n        << \"Reporting measured frequency and continuing remaining tests.\\n\"\n        << \"Measured Frequency = \" << kernel_freq_ << \"\\n\";\n  }  // End of if - else to check for reports\n  return 0;\n}\n\n/////////////////////////////////////////\n// **** KernelLaunchTest function **** //\n/////////////////////////////////////////\n\n// Inputs:\n// queue &q - queue to submit operation\n// Returns:\n// 0 is test passes, 1 if test fails\n\n// The function does the following tasks:\n// 1. Create a pipe between 2 kernels (sender kernel and receiver kernel)\n// 2. Launch sender kernel\n// 3. Sender kernel writes a known value (kTestValue) to the pipe\n// 4. Launch receiver kernel\n// 5. Receiver kernel reads the value from pipe and writes to memory\n// 6. Host reads data back from memory and checks if the value read is equal to\n// the known value (kTestVakue) Test fails if there is a data mismatch\n\nint ShimMetrics::KernelLaunchTest(sycl::queue &q) {\n  // Value to be written to pipe from KernelSender\n  constexpr unsigned int kTestValue = 0xdead1234;\n\n  // Create device buffer to read back data\n  std::array<unsigned int, 1> init_val = {0};\n  sycl::buffer dev_buf(init_val);\n\n  // **** Launch sender kernel (writes to pipe) **** //\n\n  std::cout << \"Launching kernel KernelSender ...\\n\";\n  auto e_send = q.submit([&](sycl::handler &h) {\n    // Global range (1 dimension)\n    constexpr size_t kN = 1;\n    // Work group size (1 dimension)\n    constexpr size_t kReqdWgSize = 1;\n    h.parallel_for<KernelSender>(\n        sycl::nd_range<1>(sycl::range<1>(kN), sycl::range<1>(kReqdWgSize)),\n        [=](auto id) {\n          SendertoReceiverPipe::write(kTestValue);  // Blocking write\n        });\n  });\n\n  // **** Launch receiver kernel (reads from pipe) **** //\n\n  std::cout << \"Launching kernel KernelReceiver ...\\n\";\n  auto e_receive = q.submit([&](sycl::handler &h) {\n    // Global range (1 dimension)\n    constexpr size_t kN = 1;\n    // Work group size (1 dimension)\n    constexpr size_t kReqdWgSize = 1;\n    sycl::accessor mem(dev_buf, h);\n    h.parallel_for<KernelReceiver>(\n        sycl::nd_range<1>(sycl::range<1>(kN), sycl::range<1>(kReqdWgSize)),\n        [=](sycl::nd_item<1> it) {\n          // Initialize to 0\n          unsigned int pipe_value = 0;\n          // Blocking read from pipe\n          pipe_value = SendertoReceiverPipe::read();\n          auto gid = it.get_global_id(0);\n          mem[gid] = pipe_value;\n        });\n  });\n\n  // **** Wait for sender and receiver kernels to finish **** //\n\n  std::cout << \"  ... Waiting for sender\\n\";\n  e_send.wait();\n  std::cout << \"Sender sent the token to receiver\\n\";\n  std::cout << \"  ... Waiting for receiver\\n\";\n  e_receive.wait();\n\n  // Read back data written by pipe to device memory\n  sycl::host_accessor h_buf_access{dev_buf};\n  if (h_buf_access[0] != kTestValue) {\n    std::cerr << \"Kernel Launch Test failed, incorrect value read back from \"\n              << \"pipe between sender and receiver kernel:\\n\"\n              << \"Value written to pipe : \" << kTestValue\n              << \" Value read back : \" << h_buf_access[0] << \"\\n\";\n    return 1;\n  }\n\n  return 0;\n}\n\n//////////////////////////////////////\n// **** KernelLatency function **** //\n//////////////////////////////////////\n\n// Inputs:\n// queue &q - queue to submit operation\n// Returns:\n// 0 indicating successful completion (no error checks)\n\n// The function does the following tasks:\n// 1. Launch large number of no operation kernels\n// 2. Measure total time for the above kernels to launch and finish\n// 3. Calculate kernel latency and kernel throughput based on total time and\n// number of kernels\n// 4. Report the latency and throughput and return\n\nint ShimMetrics::KernelLatency(sycl::queue &q) {\n  // **** Launch no-op kernel multiple times **** //\n  auto start = std::chrono::system_clock::now();\n  constexpr size_t kNumKernels = 10000;\n  for (size_t l = 0; l < kNumKernels; l++) {\n    auto e = q.single_task<NopSingleTask>([=]() {});  // no operation kernel\n  }\n  // Wait for all queued tasks to finish\n  q.wait();\n  auto stop = std::chrono::system_clock::now();\n\n  // Time taken for kNumKernels to launch and finish\n  std::chrono::duration<float> time = (stop - start);  // in seconds\n\n  // **** Report kernel latency **** //\n\n  // Storing old state of std::cout to restore after output printed\n  std::ios old_state(nullptr);\n  old_state.copyfmt(std::cout);\n\n  // Calculating throughput in kernels/ms, averaged over kNumKernels launches\n  kernel_thruput_ = kNumKernels * 1 / (time.count() * 1000.0f);\n  kernel_latency_ = (time.count() * 1.0e6f / kNumKernels);\n  std::cout << \"Processed \" << kNumKernels << \" kernels in \"\n            << std::setprecision(4) << std::fixed << (time.count() * 1000.0f)\n            << \" ms\\n\";\n  std::cout << \"Single kernel round trip time = \" << kernel_latency_ << \" us\\n\";\n  std::cout << \"Throughput = \" << kernel_thruput_ << \" kernels/ms\\n\";\n\n  // Restoring old format after each check_results function call to print\n  // correct format in current loop\n  std::cout.copyfmt(old_state);\n  std::cout << \"Kernel execution is complete\\n\";\n\n  // Test complete\n  return 0;\n}\n\n////////////////////////////////////\n// **** KernelMemRW function **** //\n////////////////////////////////////\n\n// Inputs:\n// queue &q - queue to submit operation\n// Returns:\n// 0 is test passes, 1 if device memory allocation is 0 or if test fails\n\n// The function does the following tasks:\n// 1. Gets maximum allocation size for device global memory\n// 2. Calculates number of unsigned type elements that can be written to device\n// and allocates device buffer to span this size\n// 3. Allocates host memory for input & output to & from device global memory\n// 4. Write initial data to entire device global memory\n// 5. Launches kernel to modify the values written to device global memory\n// 6. Reads the modified data from device global memory into host memory\n// 7. Verifies data matches expected value\n\n// Following additional function is used in this test:\n// This is defined in this file and declared in corresponding header\n// (kernel_mem_rw.hpp) More details can be found with the corresponsing\n// definition\n// 1. void InitializeVector(unsigned *vector, size_t size, size_t offset)\n\nint ShimMetrics::KernelMemRW(sycl::queue &q) {\n  // Test fails if max alloc size is 0\n  if (max_alloc_size_ == 0) {\n    std::cerr << \"Maximum global memory allocation supported by Sycl device is \"\n              << \"0! Cannot run kernel-to-memory read wite test\\n\\n\";\n    return 1;\n  }\n\n  std::cout << \"Maximum device global memory allocation size is \"\n            << max_alloc_size_ << \" bytes \\n\";\n\n  // Number of integer type vectors supported on the device\n  size_t max_dev_vectors = max_alloc_size_ / sizeof(unsigned);\n\n  // **** Host memory Allocation **** //\n\n  // Allocate host vectors\n  // ND Range kernel uses max_dev_vectors to calculate the global range...\n  // ...SYCL ID queries are expected to fit within MAX_INT,...\n  // ...limit the range to prevent truncating data and errors\n  size_t num_host_vectors =\n      (max_dev_vectors > (std::numeric_limits<int>::max())) ? kGiB\n                                                            : max_dev_vectors;\n  size_t host_vector_size_bytes = num_host_vectors * sizeof(unsigned);\n\n  // Host memory used for storing input data to device\n  unsigned *host_data_in = new (std::nothrow) unsigned[host_vector_size_bytes];\n  // Host memory used to store data read back from device\n  unsigned *host_data_out = new (std::nothrow) unsigned[host_vector_size_bytes];\n\n  // The below while loop checks if host memory allocation failed and tries to\n  // allocate a smaller chunk if above allocation fails, minimum size of 512\n  // bytes\n  while ((host_vector_size_bytes >= (kKiB / 2)) &&\n         (host_data_in == NULL || host_data_out == NULL)) {\n    num_host_vectors = num_host_vectors / 2;\n    host_vector_size_bytes = num_host_vectors * sizeof(unsigned);\n    host_data_in = new (std::nothrow) unsigned[host_vector_size_bytes];\n    host_data_out = new (std::nothrow) unsigned[host_vector_size_bytes];\n  }\n  if (host_data_in == NULL || host_data_out == NULL) {\n    std::cerr << \"Error: Allocation of host buffers for the test failed.\"\n              << \"Cannot run kernel-to-memory read wite test\\n\\n\";\n    if (host_data_in) delete[] host_data_in;\n    if (host_data_out) delete[] host_data_out;\n    return 1;\n  }\n\n  std::cout << \"Finished host memory allocation for input and output data\\n\";\n\n  // **** Device buffer creation **** //\n\n  std::cout << \"Creating device buffer\\n\";\n\n  sycl::buffer<unsigned, 1> dev_buf(sycl::range<1>{max_dev_vectors});\n\n  // **** Writing to device global memory **** //\n\n  // If max_dev_vectors (i.e. device global memory allocation size) >\n  // MAX_INT,...\n  // ... multiple iterations/writes to device memory are needed to fill entire\n  // global memory with preset data ...\n  // ... To ensure full device global memory is written to (even if it is evenly\n  // distributable by kGiB) - ...\n  // ... Pad with (kGiB - 1) before dividing by kGiB.\n  size_t num_dev_writes =\n      (max_dev_vectors + kGiB - 1) /\n      kGiB;  // Calculating number of writes needed (adding kGiB - 1 to prevent\n            // missing out few bytes of global address space due to rounding\n\n  // Access device memory in chunks and initialize it\n  for (size_t vecID = 0; vecID < num_dev_writes; vecID++) {\n    // Each iteration writes kGiB size chunks, so offset increments by lGB\n    size_t global_offset = vecID * kGiB;\n    size_t current_write_size = kGiB;\n\n    // Remaining vectors for last set (calculated this way as the padding may\n    // make the last write bigger than actual global memory size on buffer)\n    if (vecID == (num_dev_writes - 1)) {\n      current_write_size = max_dev_vectors - global_offset;\n    }\n\n    // If host buffer - host_data_in is smaller than max_dev_vectors, transfer\n    // data in multiple writes\n    size_t offset_bytes = 0;\n    size_t bytes_rem = current_write_size * sizeof(unsigned);\n\n    while (bytes_rem > 0) {\n      size_t chunk = bytes_rem;\n      // chunk is greater than host buffer size, break into smaller chunks\n      if (chunk > host_vector_size_bytes) chunk = host_vector_size_bytes;\n      // Number of elements written in 1 transfer (copy operation)\n      num_host_vectors = chunk / sizeof(unsigned);\n      // Offset if max_dev_vectors chunk is broken into smaller portions\n      size_t offset = offset_bytes / sizeof(unsigned);\n      // Initialize input data on host with the total offset value\n      InitializeVector(host_data_in, num_host_vectors,\n                       (global_offset + offset));\n      // Submit copy operation (explicit copy from host to device)\n      q.submit([&](sycl::handler &h) {\n         // Range of buffer that needs to accessed is num_host_vectors\n         // offset starts at 0 - incremented by chunk size each iteration\n         auto buf_offset = global_offset + offset;\n         sycl::accessor mem(dev_buf, h, num_host_vectors, buf_offset);\n         // Writing from host memory to device buffer\n         h.copy(host_data_in, mem);\n       }).wait();  // Wait for copy operation to complete\n      // Increment offset and decrement remaining bytes by chunk size each\n      // interation\n      offset_bytes += chunk;\n      bytes_rem -= chunk;\n    }  // End of write while loop\n  }    // End of write for loop\n\n  std::cout << \"Finished writing to device buffers \\n\";\n\n  // **** Submitting kernel operation **** //\n\n  std::cout << \"Launching kernel MemReadWriteStream ... \\n\";\n\n  // Enqueue kernel to access all of global memory\n  // Multiple enqueues are needed to access the whole ...\n  // ... global memory address space from the kernel ...\n  // ... if max_dev_vectors > kGiB\n\n  for (size_t vecID = 0; vecID < num_dev_writes; vecID++) {\n    // Each iteration writes kGiB size chunks, so offset increments by kGiB\n    size_t global_offset = vecID * kGiB;\n    size_t current_write_size = kGiB;\n\n    // Remaining vectors for last set (calculated this way as the padding may\n    // make the last read bigger than actual global memory size on buffer)\n    if (vecID == (num_dev_writes - 1)) {\n      current_write_size = max_dev_vectors - global_offset;\n    }\n\n    std::cout << \"Launching kernel with global offset : \" << global_offset\n              << \"\\n\";\n\n    // launch kernel\n    auto e = q.submit([&](sycl::handler &h) {\n      // Global range (1 dimension)\n      size_t N = current_write_size;\n      sycl::accessor mem(dev_buf, h, N, global_offset);\n      h.parallel_for<MemReadWriteStream>(sycl::range<1>{N},\n                                         [=](sycl::item<1> it) {\n                                           // Add 2 to all data read from global\n                                           // memory (meaning adding 2 to all\n                                           // the offsets calculated in write\n                                           // loops above)\n                                           auto gid = it.get_id(0);\n                                           mem[gid] = mem[gid] + 2;\n                                         });\n    });\n  }  // End of kernel launch for loop\n\n  // Wait for operation to complete\n  q.wait();\n\n  std::cout << \"... kernel finished execution. \\n\";\n\n  // **** Read back data from device global memory & verify **** //\n\n  for (size_t vecID = 0; vecID < num_dev_writes; vecID++) {\n    // Each iteration writes kGiB size chunks, so offset increments by kGiB\n    size_t global_offset = vecID * kGiB;\n    size_t current_read_size = kGiB;\n\n    // Remaining vectors for last set (calculated this way as the padding may\n    // make the last read bigger than actual global memory size on buffer)\n    if (vecID == (num_dev_writes - 1)) {\n      current_read_size = max_dev_vectors - global_offset;\n    }\n\n    // If host buffer - host_data_out is smaller than max_dev_vectors, transfer\n    // data in multiple reads\n    size_t bytes_rem = current_read_size * sizeof(unsigned);\n    size_t offset_bytes = 0;\n\n    while (bytes_rem > 0) {\n      size_t chunk = bytes_rem;\n      // chunk is greater than host buffer size, break into smaller chunks\n      if (chunk > host_vector_size_bytes) chunk = host_vector_size_bytes;\n      // Number of elements read in 1 transfer (copy operation)\n      num_host_vectors = chunk / sizeof(unsigned);\n      // Offset if max_dev_vectors chunk is broken into smaller portions\n      size_t offset = offset_bytes / sizeof(unsigned);\n      // Submit copy operation (explicit copy from device to host)\n      q.submit([&](sycl::handler &h) {\n         // Range of buffer that needs to accessed is num_host_vectors\n         // offset starts at 0 - incremented by chunk size each iteration\n         auto buf_offset = global_offset + offset;\n         sycl::accessor mem(dev_buf, h, num_host_vectors, buf_offset);\n         // Reading from device buffer into host memory\n         h.copy(mem, host_data_out);\n       }).wait();  // Wait for copy operation to complete\n\n      // **** Verify output **** //\n\n      // Compare value read back is offset + 2\n      // initial value written was offset, incremented by 2 in kernel\n      for (size_t i = 0; i < num_host_vectors; i++) {\n        if (host_data_out[i] != (unsigned)(global_offset + offset + i + 2)) {\n          std::cerr << \"Verification failed \" << i << \" : \" << host_data_out[i]\n                    << \" != \" << ((unsigned)(global_offset + offset + i + 2))\n                    << \"\\n\";\n          // Free host memory and return if verification fails\n          if (host_data_in) delete[] host_data_in;\n          if (host_data_out) delete[] host_data_out;\n          return 1;\n        }\n      }\n      // Increment offset and decrement remaining bytes by chunk size each\n      // interation\n      offset_bytes += chunk;\n      bytes_rem -= chunk;\n    }\n  }  // End of read for loop\n\n  // All values verified successfully - test passed\n  std::cout << \"Finished Verification\\n\";\n\n  // Free allocated host memory\n  if (host_data_in) delete[] host_data_in;\n  if (host_data_out) delete[] host_data_out;\n\n  std::cout << \"KERNEL TO MEMORY READ WRITE TEST PASSED \\n\";\n  kernel_mem_rw_test_ = true;\n  return 0;\n}\n\n////////////////////////////////////\n// **** KernelMemBW function **** //\n////////////////////////////////////\n\n// Inputs:\n// queue &q - queue to submit operation\n// Returns:\n// 0 if test passes, 1 if device max allocation size is 0 or verification fails\n\n// The function does the following tasks:\n// 1. Get max allocation size for device global memory, limit device buffer size\n// to 4 GB if the max alloc is greater\n// 2. Read board_spec.xml to get number of\n// memory interfaces/banks\n// 3. Allocate host memory and initialize with random values\n// 4. Write the data from host memory to device global memory (initializing\n// device global memory with random values)\n// 4. Launch 3 kernels for each dimm/memory bank:\n//      a. MemWriteStream - Write to device global memory\n//      b. MemReadStream - Read from device global memory\n//      c. MemReadWriteStream - Read, modify and write to device global memory\n// Each of the kernel does this for each dimm (test assumes max of 8 dimms), if\n// number of dimms is less, the kernel read/write defaults to lowest memory bank\n// (1)\n// 5. Calculate bandwidth for read, write and read-write based on time taken for\n// each of the operation above\n// 6. Read the theoretical bandwidth from board_spec.xml, calculate utilization\n// and report results\n\nint ShimMetrics::KernelMemBW(sycl::queue &q) {\n  std::cout << \"Note: This test assumes that design was compiled with \"\n            << \"-Xsno-interleaving option\\n\\n\";\n\n  // Test fails if max alloc size is 0\n  if (max_alloc_size_ == 0) {\n    std::cerr << \"Maximum global memory allocation supported by Sycl device is \"\n              << \"0! Cannot run kernel-to-memory bandwidth test\\n\\n\";\n    return 1;\n  }\n\n  // Default number of memory banks/DIMMs in the oneAPI shim (assumed to\n  // prevent test from failing if board_spec.xml data cannot be read)\n  constexpr size_t kDefaultNumBanks = 8;\n  size_t num_banks = kDefaultNumBanks;\n  // If device global memory > 4 GB , limit the transfer size to 4 GB for this\n  // test\n  size_t total_bytes_used =\n      (max_alloc_size_ > (4 * kGiB)) ? (4 * kGiB) : max_alloc_size_;\n\n  // Transfer size in number of unsigned elements\n  size_t vector_size = total_bytes_used / sizeof(unsigned);\n\n  // **** Host memory allocation & initialization **** //\n\n  // Host memory used to store input data to device buffer\n  unsigned *host_data_in = new (std::nothrow) unsigned[vector_size];\n  // Host memory used to store data read back from device\n  unsigned *host_data_out = new (std::nothrow) unsigned[vector_size];\n\n  // The below while loop checks if hostbuf allocation failed and tries to\n  // allocate a smaller chunk if above allocation fails, minimum buffer size\n  // of 512 bytes\n  while ((total_bytes_used > (kKiB / 2)) &&\n         (host_data_in == NULL || host_data_out == NULL)) {\n    vector_size = vector_size / 2;\n    total_bytes_used = vector_size * sizeof(unsigned);\n    host_data_in = new (std::nothrow) unsigned[total_bytes_used];\n    host_data_out = new (std::nothrow) unsigned[total_bytes_used];\n  }\n  if (host_data_in == NULL || host_data_out == NULL) {\n    std::cerr << \"Error: Allocation of host buffer for the test failed.\"\n              << \"Cannot run kernel-to-memory bandwidth test\\n\\n\";\n    if (host_data_in) delete[] host_data_in;\n    if (host_data_out) delete[] host_data_out;\n    return 1;\n  }\n\n  // Initialize host memory\n  InitializeVector(host_data_in, vector_size);\n  InitializeVector(host_data_out, vector_size);\n\n  // **** Write data to device & launch kernels **** //\n\n  std::cout << \"\\nPerforming kernel transfers of \" << (total_bytes_used / kMiB)\n            << \" MiBs on the default global memory (address starting at 0)\\n\";\n\n  // The loop launches 3 different kernels to measure:\n  // kernel to memory write bandwidth using \"MemWriteStream\" kernel\n  // kernel to memory read bandwidth using \"MemReadStream\" kernel\n  // kernel to memory read-write bandwidth using \"MemReadWriteStream\" kernel\n  constexpr size_t kNumKernels = 3;\n  std::string kernel_name[kNumKernels] = {\"MemWriteStream\", \"MemReadStream\",\n                                          \"MemReadWriteStream\"};\n\n  // Array used to store the bandwidth measurement for each kernel for each\n  // memory bank\n  std::vector<std::vector<float> > bw_kern;\n\n  // k = 0 launches kernel_name[0] i.e. MemWriteStream kernel\n  // k = 1 launches kernel_name[1] i.e. MemReadStream kernel\n  // k = 2 launches kernel_name[2] i.e. MemReadWriteStream kernel\n\n  for (unsigned k = 0; k < kNumKernels; k++) {\n    std::cout << \"Launching kernel \" << kernel_name[k] << \" ... \\n\";\n\n    std::vector<float> bw_bank;\n\n    // Launch each kernel once for each memory bank\n    for (unsigned b = 0; b < num_banks; b++) {\n      // Assign a memory channel for each transfer (needed for multi-bank\n      // oneAPI shims/BSP) default memory channel is 1 (lowest)\n      sycl::property_list buf_prop_list{sycl::property::buffer::mem_channel{1}};\n\n      switch (b) {\n        // if the board_spec.xml has fewer banks than the dimms, mem_channel\n        // defaults to 1\n        case 0:\n          buf_prop_list = {sycl::property::buffer::mem_channel{1}};\n          break;\n        case 1:\n          buf_prop_list = {sycl::property::buffer::mem_channel{2}};\n          break;\n        case 2:\n          buf_prop_list = {sycl::property::buffer::mem_channel{3}};\n          break;\n        case 3:\n          buf_prop_list = {sycl::property::buffer::mem_channel{4}};\n          break;\n        case 4:\n          buf_prop_list = {sycl::property::buffer::mem_channel{5}};\n          break;\n        case 5:\n          buf_prop_list = {sycl::property::buffer::mem_channel{6}};\n          break;\n        case 6:\n          buf_prop_list = {sycl::property::buffer::mem_channel{7}};\n          break;\n        default:\n          buf_prop_list = {sycl::property::buffer::mem_channel{1}};\n          break;\n      }  // End of switch for setting buffer property\n\n      // **** Create device buffer **** //\n\n      // Create kernel input buffer on device (memory bank selected by\n      // mem_channel property)\n      sycl::buffer<unsigned, 1> dev_buf(sycl::range<1>{vector_size},\n                                        buf_prop_list);\n\n      // **** Write random values to device global memory **** ///\n\n      // Submit copy operation (explicit copy from host to device)\n      q.submit([&](sycl::handler &h) {\n         sycl::accessor mem(dev_buf, h);\n         // Writing from host memory to device buffer\n         h.copy(host_data_in, mem);\n       }).wait();  // Wait for copy operation to complete\n\n      // ****  Submit kernel tasks **** //\n\n      auto e = q.submit([&](sycl::handler &h) {\n        // sycl::ext::oneapi::no_offset - tells the compiler that no offset has \n        // been applied to the base pointer, and aligned accesses can be used \n        sycl::accessor mem(dev_buf, h, sycl::ext::oneapi::accessor_property_list{sycl::ext::oneapi::no_offset});\n        // Work group Size (1 dimension)\n        constexpr size_t kWGSize = 1024 * 32;\n        constexpr size_t kSimdItems = 16;\n        // Global range (1 dimension)\n        // Global range should be evenly distributable by work group size ...\n        // ... Pad with (kWGSize - 1) before dividing by kWGSize and rounding to\n        // closest multiple\n        size_t N = ((vector_size + kWGSize - 1) / kWGSize) * kWGSize;\n        // Dummy variable used in MemReadStream kernel to prevent memory access\n        // from being optimized away\n        unsigned dummy_var = 0;\n        // Kernel to launch selected based on outer for loop control variable k\n        switch (k) {\n          case 0:  // kernel MemWriteStream\n            h.parallel_for<MemWriteStream>(\n                sycl::nd_range<1>(sycl::range<1>(N), sycl::range<1>(kWGSize)),\n                [=](sycl::nd_item<1> it)\n                    [[intel::num_simd_work_items(kSimdItems),\n                      sycl::reqd_work_group_size(kWGSize)]] {\n                      // Write global ID to memory\n                      auto gid = it.get_global_id(0);\n                      mem[gid] = gid;\n                    });\n            break;\n          case 1:  // kernel MemReadStream\n            h.parallel_for<MemReadStream>(\n                sycl::nd_range<1>(sycl::range<1>(N), sycl::range<1>(kWGSize)),\n                [=](sycl::nd_item<1> it)\n                    [[intel::num_simd_work_items(kSimdItems),\n                      sycl::reqd_work_group_size(kWGSize)]] {\n                      // Read memory\n                      auto gid = it.get_global_id();\n                      unsigned val = mem[gid];\n                      // Use val to prevent compiler from optimizing away this\n                      // variable & read from memory\n                      if (!val && (dummy_var == 3))\n                        mem[gid] = 2;  // Randomly selected value\n                    });\n            break;\n          case 2:  // MemReadWriteStream (also the default)\n          default:\n            h.parallel_for<MemReadWriteStreamNDRange>(\n                sycl::nd_range<1>(sycl::range<1>(N), sycl::range<1>(kWGSize)),\n                [=](sycl::nd_item<1> it)\n                    [[intel::num_simd_work_items(kSimdItems),\n                      sycl::reqd_work_group_size(kWGSize)]] {\n                      // Read, modify and write to memory\n                      auto gid = it.get_global_id(0);\n                      mem[gid] = mem[gid] + 2;\n                    });\n            break;\n        }  // End of switch in q.submit\n      });\n\n      // Wait for kernel tasks to complete\n      e.wait();\n\n      // **** Calculate bandwidth for each memory bank for each kernel **** //\n\n      if (k == 0 ||\n          k == 1) {  // Unidirectional (MemReadStream or MemWriteStream kernel)\n        bw_bank.push_back(((total_bytes_used / kMB) /\n                           (SyclGetQStExecTimeNs(e) * 1.0e-9f)));\n      } else {  // bidirectional (MemReadWriteStream kernel)\n        bw_bank.push_back(((total_bytes_used * 2 / kMB) /\n                           (SyclGetQStExecTimeNs(e) * 1.0e-9f)));\n      }\n\n      // **** Read data back from device **** //\n\n      // Submit copy operation (copy from device to host)\n      q.submit([&](sycl::handler &h) {\n         sycl::accessor mem(dev_buf, h);\n         // Reading from device buffer into host memory\n         h.copy(mem, host_data_out);\n       }).wait();\n\n      // **** Verification **** //\n\n      // kernel MemReadWriteStream adds 2 to the globaloffset (where global\n      // range is vector_size)\n      if ((k == 0) || (k == 2)) {\n        unsigned val_to_add = (k == 2) ? 2 : 0;\n        bool result = true;\n        int prints = 0;\n        for (size_t j = 0; j < vector_size; j++) {\n          unsigned input_data = (k == 2) ? (host_data_in[j]) : j;\n          if (host_data_out[j] != (input_data + val_to_add)) {\n            if (prints++ < 512) {  // only print 512 errors\n              std::cerr << \"Error! Mismatch at element \" << j << \":\" << std::hex\n                        << std::showbase << host_data_out[j]\n                        << \" != \" << (input_data + val_to_add)\n                        << std::noshowbase << std::dec\n                        << \"\\n\";  // Restoring std::cout format\n            }\n            result = false;\n          }\n        }\n        if (!result) {\n          std::cerr << \"Verification failed, terminating test\\n\";\n          return 1;\n        }\n      }\n    }  // End of for loop controlled by num_banks\n\n    bw_kern.push_back(bw_bank);\n\n  }  // End of for loop controlled by kNumKernels\n\n  // **** Report bandwidth calculation results **** //\n\n  std::cout << \"\\nSummarizing bandwidth in MB/s/bank for banks 1 to \"\n            << num_banks << \"\\n\";\n  kernel_mem_bw_ = 0.0;\n  for (unsigned k = 0; k < kNumKernels; k++) {\n    for (unsigned b = 0; b < num_banks; b++) {\n      std::cout << \" \" << bw_kern[k][b] << \" \";\n      // Accumulate data from each kernel task to calculate average bandwidth\n      kernel_mem_bw_ += bw_kern[k][b];\n    }\n    std::cout << \" \" << kernel_name[k] << \"\\n\";\n  }\n  // Average bandwidth\n  kernel_mem_bw_ /= num_banks * kNumKernels;\n\n  // Report average kernel memory bandwidth\n  std::cout << \"\\nKERNEL-TO-MEMORY BANDWIDTH = \" << kernel_mem_bw_\n            << \" MB/s/bank\\n\";\n\n  delete[] host_data_in;\n  delete[] host_data_out;\n\n  return 0;\n}\n\n#if defined(SUPPORTS_USM)\n\n////////////////////////////////////\n// ****** USMMemBW function ***** //\n////////////////////////////////////\n\n// Inputs:\n// queue &q - queue to submit operation\n// Returns:\n// 0 if test passes, 1 if memory allocation or verification fails\n\n// The function does the following tasks, for each test (memcopy, read, write):\n// 1. Allocate host USM for input and output. Initialize input with random\n// values and initialize output with zero.\n// 2. Launch a kernel to perform one of the following tests:\n//      - Memcopy: copy data from input USM pointer to output USM pointer\n//      - Read: read data from input USM pointer\n//      - Write: write data to output USM pointer\n// 3. Host verifies the output data is correct\n// 4. Rerun the kernel from several more times to measure bandwidth (the first\n// iteration is slow due to one time tasks).\n// 5. Calculate and report bandwidth.\n\nint ShimMetrics::USMBWTest(sycl::queue &q) {\n  return run_test(q, MEMCOPY) | run_test(q, READ) | run_test(q, WRITE);\n}\n\n#endif\n\n///////////////////////////////////\n// **** ReadBinary function **** //\n///////////////////////////////////\n\n// Inputs: None\n// Returns: void\n\n// The function does the following task:\n// Reads Quartus report data from FPGA hardware binary,\n// extracts the Quartus compiled kernel clock frequency(actual)\n// The FPGA hardware binary has the \"acl_quartus_report.txt\" embedded in it\n\nvoid ShimMetrics::ReadBinary() {\n  std::string temp_cmd =\n      \"aocl binedit \" + kBinaryName + \" print .acl.quartus_report\";\n  const char *open_cmd_rep = temp_cmd.c_str();\n  FILE *bin_content_report = _popen(open_cmd_rep, \"r\");\n  if (bin_content_report != NULL) {\n    char *temp_word = new char[50 * sizeof(char)];\n    std::string lookup_tag = \"Actual clock freq: \";\n    while ((std::feof(bin_content_report) == 0) && !board_info_.fmax_info_) {\n      std::string rd_line(fgets(temp_word, 50, bin_content_report));\n      // Look for the fmax tag\n      if (rd_line.find(lookup_tag) != std::string::npos) {\n        board_info_.fmax_info_ = true;\n        // The look-up tag format is \"Actual clock freq: \"\n        size_t st_pos = rd_line.find(lookup_tag) + lookup_tag.size();\n        // Extract frequency starting at st_pos\n        board_info_.quartus_fmax_ = std::stof(rd_line.substr(st_pos));\n        // No need to iterate through rest of the file if fmax tag is\n        // found\n        break;\n      }  // End of if extracting fmax from rd_line\n    }    // End of while loop reading file\n    delete[] temp_word;\n  }\n}\n"
    },
    {
        "label": "main.cpp",
        "data": "//  Copyright (c) 2024 Intel Corporation\n//  SPDX-License-Identifier: MIT\n\n// main.cpp\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n#define NUM_FRAMES 5\n#include <stdlib.h>  // malloc, free\n\n#include <fstream>  // ofstream\n#include <iostream>\n#include <string>\n#include <sycl/sycl.hpp>\n\n#include \"bmp_tools.hpp\"\n#include \"convolution_kernel.hpp\"\n#include \"exception_handler.hpp\"\n#include \"vvp_stream_adapters.hpp\"\n\n#ifndef DEFAULT_EXTENSION\n#define DEFAULT_EXTENSION \".bmp\"\n#endif\n\n#ifndef DEFAULT_INPUT\n#define DEFAULT_INPUT \"../test_bitmaps/test\"\n#endif\n\n#ifndef DEFAULT_OUTPUT\n#define DEFAULT_OUTPUT \"./output\"\n#endif\n\n#ifndef DEFAULT_EXPECTED\n#define DEFAULT_EXPECTED \"../test_bitmaps/expected_sobel\"\n#endif\n\n#ifndef TEST_CONV2D_ISOLATED\n#define TEST_CONV2D_ISOLATED 0\n#endif\n\n#define M_DEFAULT_INPUT DEFAULT_INPUT\n#define M_DEFAULT_OUTPUT DEFAULT_OUTPUT\n#define M_DEFAULT_EXPECTED DEFAULT_EXPECTED\n\n#define ERR_MSG_BUF_SIZE 256\n\n/////////////////////\n// Test subroutines\n/////////////////////\n\n/// @brief Initialize a buffer meant to store an image. This helps with\n/// debugging, because you can see if an image was only partly written. The\n/// buffer is initialized with an incrementing pattern, ranging from `0` to\n/// `(1 << 24)`.\n/// @param[out] buf Buffer to initialize\n/// @param[in] size Number of pixels to initialize in the buffer\nvoid InitializeBuffer(conv2d::PixelRGB *buf, size_t size) {\n  uint16_t pixel = 0;\n  for (size_t i = 0; i < size; i++) {\n    pixel++;\n    buf[i] = conv2d::PixelRGB{pixel, pixel, pixel};\n  }\n}\n\n/// @brief Convert pixels read from a bmp image using the bmptools functions to\n/// pixels that can be parsed by our 2D convolution IP.\n/// @param[in] bmp_buf pixels read by bmptools\n/// @param[out] vvp_buf pixels to be consumed by 2D convolution IP\n/// @param[in] pixel_count (input) number of pixels in input image and output\n/// image\nvoid ConvertToVvpRgb(unsigned int *bmp_buf, conv2d::PixelRGB *vvp_buf,\n                     size_t pixel_count) {\n  std::cout << \"INFO: convert to vvp type.\" << std::endl;\n  for (size_t idx = 0; idx < pixel_count; idx++) {\n    uint32_t pixel_int = bmp_buf[idx];\n    bmp_tools::PixelRGB bmp_rgb(pixel_int);\n\n    // convert from 8-bit to whatever the VVP IP expects\n    conv2d::PixelRGB pixel_vvp{\n        (uint16_t)(bmp_rgb.b << (conv2d::kBitsPerChannel - 8)),   //\n        (uint16_t)(bmp_rgb.g << (conv2d::kBitsPerChannel - 8)),   //\n        (uint16_t)(bmp_rgb.r << (conv2d::kBitsPerChannel - 8))};  //\n\n    vvp_buf[idx] = pixel_vvp;\n  }\n}\n\n/// @brief Convert pixels read from the 2D convolution IP to a format that can\n/// be read by the bmptools functions.\n/// @param[in] vvp_buf pixels produced by 2D convolution IP\n/// @param[out] bmp_buf pixels to send to bmptools\n/// @param[in] pixel_count number of pixels in input image and output image\nvoid ConvertToBmpRgb(conv2d::PixelRGB *vvp_buf, unsigned int *bmp_buf,\n                     size_t pixel_count) {\n  std::cout << \"INFO: convert to bmp type.\" << std::endl;\n  for (size_t idx = 0; idx < pixel_count; idx++) {\n    conv2d::PixelRGB pixel_conv = vvp_buf[idx];\n\n    // convert the VVP IP back to 8-bit\n    bmp_tools::PixelRGB bmp_rgb(\n        (uint8_t)(pixel_conv.r >> (conv2d::kBitsPerChannel - 8)),   //\n        (uint8_t)(pixel_conv.g >> (conv2d::kBitsPerChannel - 8)),   //\n        (uint8_t)(pixel_conv.b >> (conv2d::kBitsPerChannel - 8)));  //\n\n    uint32_t pixel_int = bmp_rgb.GetImgPixel();\n    bmp_buf[idx] = pixel_int;\n  }\n}\n\n/// @brief Verify image dimensions from a just-read image and compare with\n/// previous image dimensions if appropriate.\n/// @param rows previous image rows (0 if no previous dimensions)\n/// @param cols previous image cols (0 if no previous dimensions)\n/// @param rows_new new image rows\n/// @param cols_new new image columns\n/// @return `true` if new dimensions are acceptable, and `rows` and `cols` have\n/// been successfully updated to `rows_new` and `cols_new` respectively.\nbool UpdateAndCheckImageDimensions(size_t &rows, size_t &cols, size_t rows_new,\n                                   size_t cols_new) {\n  // sanity check: all images should be the same size\n  if (rows == 0)\n    rows = rows_new;\n  else if (rows != rows_new) {\n    std::cerr << \"ERROR: dimensions of images must match. Expected \" << rows\n              << \" but saw \" << rows_new << \"!\" << std::endl;\n    return false;\n  }\n\n  if (cols == 0)\n    cols = cols_new;\n  else if (cols != cols_new) {\n    std::cerr << \"ERROR: dimensions of images must match. Expected \" << cols\n              << \" but saw \" << cols_new << \"!\" << std::endl;\n    return false;\n  }\n\n  // Max allowable value for rows * cols must be less than the max value of a\n  // signed 32-bit integer.\n  constexpr int kRowsColsMax = 1 << 29;\n\n  bool image_size_ok =\n      (rows_new > 0) && (cols_new > 0) && (rows_new * cols_new < kRowsColsMax);\n\n  // sanity check; this design assumes that the number of columns in the input\n  // image is a multiple of kParallelPixels.\n  if (cols % conv2d::kParallelPixels != 0) {\n    std::cerr << \"ERROR: image cols = \" << cols\n              << \" not compatible with kernel compiled for \"\n              << conv2d::kParallelPixels\n              << \" pixels in parallel. Please choose a different image, or \"\n                 \"recompile \"\n                 \"with a different value of the PARALLEL_PIXELS \"\n                 \"pre-processor macro.\"\n              << std::endl;\n    return false;\n  }\n\n  return image_size_ok;\n}\n\n#if TEST_CONV2D_ISOLATED\nconstexpr std::array<float, 9> identity_coeffs = {\n    0.0f, 0.0f, 0.0f,  //\n    0.0f, 1.0f, 0.0f,  //\n    0.0f, 0.0f, 0.0f   //\n};\n\n/// @brief Trivial test that exercises Convolution2d on its own, using an\n/// extremely simple image. This is useful for debugging that data is flowing\n/// through the line buffer properly.\n/// @param q The SYCL queue to assign work to\n/// @param print_debug_info Print additional debug information when reading from\n/// pipe\n/// @return `true` if successful, `false` otherwise\nbool TestTinyFrameOnStencil(sycl::queue q, bool print_debug_info) {\n  std::cout << \"\\n**********************************\\n\"\n            << \"Check Tiny frame... \"\n            << \"\\n**********************************\\n\"\n            << std::endl;\n  constexpr int rows_small = 3;\n  constexpr int cols_small = 8;\n\n  constexpr int pixels_count = rows_small * cols_small;\n\n  conv2d::PixelType grey_pixels_in[] = {\n      101, 201, 301, 401, 501, 601, 701, 801,  //\n      102, 202, 302, 402, 502, 602, 702, 802,  //\n      103, 203, 303, 403, 503, 603, 703, 803};\n\n  vvp_stream_adapters::WriteFrameToPipe<InputImageStreamGrey>(\n      q, rows_small, cols_small, grey_pixels_in);\n\n  // add extra pixels to flush out the FIFO after all image frames\n  // have been added\n  int dummy_pixels = cols_small * conv2d::kWindowSize;\n  vvp_stream_adapters::WriteDummyPixelsToPipe<InputImageStreamGrey>(\n      q, dummy_pixels, (uint16_t)15);\n\n  sycl::event e = q.single_task<ID_Convolution2d>(\n      Convolution2d<InputImageStreamGrey, OutputImageStreamGrey>{\n          (int)rows_small, (int)cols_small, identity_coeffs});\n\n  conv2d::PixelType grey_pixels_out[pixels_count];\n  bool sidebands_ok;\n  int parsed_frames;\n  vvp_stream_adapters::ReadFrameFromPipe<OutputImageStreamGrey>(\n      q, rows_small, cols_small, grey_pixels_out, sidebands_ok, parsed_frames,\n      print_debug_info);\n\n  bool pixels_match = true;\n  for (int i = 0; i < pixels_count; i++) {\n    constexpr float kOutputOffset = ((1 << conv2d::kBitsPerChannel) / 2);\n    constexpr float kNormalizationFactor = (1 << conv2d::kBitsPerChannel);\n    conv2d::PixelType grey_pixel_expected =\n        ((float)grey_pixels_in[i] / kNormalizationFactor) * kOutputOffset +\n        kOutputOffset;\n    pixels_match &= (grey_pixel_expected == grey_pixels_out[i]);\n  }\n\n  // Stop the kernel in case testbench wants to run again with different kernel\n  // arguments.\n  StopCSR::write(q, true);\n  e.wait();\n\n  return sidebands_ok & pixels_match;\n}\n\n/// @brief Test that the 'bypass' control works correctly.\n/// @param q The SYCL queue to assign work to\n/// @param[in] print_debug_info Print additional debug information when reading\n/// from pipe\n/// @return `true` if input image matches output image\nbool TestBypass(sycl::queue q, bool print_debug_info) {\n  std::cout << \"\\n**********************************\\n\"\n            << \"Check bypass... \"\n            << \"\\n**********************************\\n\"\n            << std::endl;\n\n  constexpr int rows_small = 3;\n  constexpr int cols_small = 8;\n\n  constexpr int pixels_count = rows_small * cols_small;\n\n  conv2d::PixelType grey_pixels_in[] = {\n      101, 201, 301, 401, 501, 601, 701, 801,  //\n      102, 202, 302, 402, 502, 602, 702, 802,  //\n      103, 203, 303, 403, 503, 603, 703, 803};\n\n  vvp_stream_adapters::WriteFrameToPipe<InputImageStreamGrey>(\n      q, rows_small, cols_small, grey_pixels_in);\n\n  // add extra pixels to flush out the FIFO after all image frames\n  // have been added\n  int dummy_pixels = cols_small * conv2d::kWindowSize;\n  vvp_stream_adapters::WriteDummyPixelsToPipe<InputImageStreamGrey>(\n      q, dummy_pixels, (uint16_t)15);\n\n  // Enable 'bypass' mode by writing to CSR.\n  BypassCSR::write(q, true);\n\n  sycl::event e = q.single_task<ID_Convolution2d>(\n      Convolution2d<InputImageStreamGrey, OutputImageStreamGrey>{\n          (int)rows_small, (int)cols_small, identity_coeffs});\n\n  conv2d::PixelType grey_pixels_out[pixels_count];\n  bool sidebands_ok;\n  int parsed_frames;\n  vvp_stream_adapters::ReadFrameFromPipe<OutputImageStreamGrey>(\n      q, rows_small, cols_small, grey_pixels_out, sidebands_ok, parsed_frames,\n      print_debug_info);\n\n  bool pixels_match = true;\n  for (int i = 0; i < pixels_count; i++) {\n    conv2d::PixelType grey_pixel_expected = grey_pixels_in[i];\n    pixels_match &= (grey_pixel_expected == grey_pixels_out[i]);\n  }\n\n  // Stop the kernel in case testbench wants to run again with different kernel\n  // arguments.\n  StopCSR::write(q, true);\n  e.wait();\n\n  return sidebands_ok & pixels_match;\n}\n\n#else\n\nconstexpr std::array<float, 9> sobel_coeffs = {\n    -1.0f / 6.0f, 0.0f, 1.0f / 6.0f,  //\n    -1.0f / 6.0f, 0.0f, 1.0f / 6.0f,  //\n    -1.0f / 6.0f, 0.0f, 1.0f / 6.0f   //\n};\n\n/// @brief 'Happy Path' test that repeatedly passes a known good frame through\n/// the IP.\n/// @param[in] q SYCL queue\n/// @param[in] num_frames Number of times to pass the image frame through the IP\n/// @param[in] input_bmp_filename_base base filename to use for reading input\n/// frames\n/// @param[in] output_bmp_filename_base base filename to use for writing output\n/// files\n/// @param[in] expected_bmp_filename_base 'known good' file to compare IP output\n/// against\n/// @param[in] print_debug_messages Pass to the `vvp_stream_adapters`\n/// functions to print debug information.\n/// @return `true` if all frames emitted by the IP match the `known good` file,\n/// `false` otherwise.\nbool TestGoodFramesSequence(sycl::queue q, size_t num_frames,\n                            std::string input_bmp_filename_base,\n                            std::string output_bmp_filename_base,\n                            std::string expected_bmp_filename_base,\n                            bool print_debug_messages) {\n  std::cout << \"\\n**********************************\\n\"\n            << \"Check a sequence of good frames... \"\n            << \"\\n**********************************\\n\"\n            << std::endl;\n\n  sycl::event e;\n  bool all_passed = true;\n\n  size_t rows = 0, cols = 0;\n\n  for (size_t itr = 0; itr < num_frames; itr++) {\n    // load image\n    unsigned int *in_img = 0;\n    int rows_new, cols_new;\n\n    std::string canonical_input_bmp_path =  //\n        input_bmp_filename_base + \"_\" + std::to_string(itr) + DEFAULT_EXTENSION;\n    std::string canonical_expected_bmp_path =  //\n        expected_bmp_filename_base + \"_\" + std::to_string(itr) +\n        DEFAULT_EXTENSION;\n\n    std::cout << \"INFO: Load image \" << canonical_input_bmp_path << std::endl;\n    if (!bmp_tools::ReadBmp(canonical_input_bmp_path, &in_img, rows_new,\n                            cols_new)) {\n      std::cerr << \"ERROR: Could not read image from \"\n                << canonical_input_bmp_path << std::endl;\n      return false;\n    }\n\n    bool image_ok =\n        UpdateAndCheckImageDimensions(rows, cols, rows_new, cols_new);\n\n    if (!image_ok) {\n      std::cerr << \"ERROR: invalid image size \" << rows << \" x \" << cols\n                << std::endl;\n      continue;\n    }\n\n    conv2d::PixelRGB *in_img_vvp = new conv2d::PixelRGB[rows * cols];\n\n    ConvertToVvpRgb(in_img, in_img_vvp, rows * cols);\n\n    // don't need in_img anymore\n    free(in_img);\n\n    vvp_stream_adapters::WriteFrameToPipe<InputImageStream>(q, rows, cols,\n                                                            in_img_vvp);\n\n    // don't need in_img_vvp anymore\n    delete[] in_img_vvp;\n  }\n\n  // extra pixels to flush out the FIFO\n  int dummy_pixels = cols * (conv2d::kWindowSize - 1);\n  constexpr auto kDummyVal = conv2d::PixelRGB{100, 100, 100};\n  vvp_stream_adapters::WriteDummyPixelsToPipe<InputImageStream,\n                                              conv2d::PixelRGB>(q, dummy_pixels,\n                                                                kDummyVal);\n\n  std::cout << \"\\n*********************\" << std::endl;\n  std::cout << \"Launch RGB2Grey kernel\" << std::endl;\n  q.single_task<ID_RGB2Grey>(\n      RGB2Grey<InputImageStream, InputImageStreamGrey>{});\n\n  std::cout << \"Launch Convolution2d kernel\" << std::endl;\n  e = q.single_task<ID_Convolution2d>(\n      Convolution2d<InputImageStreamGrey, OutputImageStreamGrey>{\n          (int)rows, (int)cols, sobel_coeffs});\n\n  std::cout << \"Launch Grey2RGB kernel\" << std::endl;\n  q.single_task<ID_Grey2RGB>(\n      Grey2RGB<OutputImageStreamGrey, OutputImageStream>{});\n\n  for (size_t itr = 0; itr < num_frames; itr++) {\n    std::cout << \"\\n*********************\\n\"  //\n              << \"Reading out frame \" << itr  //\n              << std::endl;\n\n    std::string absolute_output_bmp_path = output_bmp_filename_base + \"_\" +\n                                           std::to_string(itr) +\n                                           DEFAULT_EXTENSION;\n\n    conv2d::PixelRGB *out_img_vvp = new conv2d::PixelRGB[rows * cols];\n    unsigned int *out_img = new unsigned int[rows * cols];\n    InitializeBuffer(out_img_vvp, rows * cols);\n\n    int parsed_frames = 0;\n    bool sidebands_ok = false;\n    if (out_img_vvp) {\n      vvp_stream_adapters::ReadFrameFromPipe<OutputImageStream>(\n          q, rows, cols, out_img_vvp, sidebands_ok, parsed_frames,\n          print_debug_messages);\n    }\n\n    if (1 != parsed_frames) {\n      std::cerr << \"ERROR: saw \" << parsed_frames\n                << \" parsed frames (expected 1).\" << std::endl;\n    }\n\n    if (out_img) {\n      ConvertToBmpRgb(out_img_vvp, out_img, rows * cols);\n      delete[] out_img_vvp;\n\n      bmp_tools::WriteBmp(absolute_output_bmp_path, out_img, rows, cols);\n      std::cout << \"Wrote convolved image \" << absolute_output_bmp_path\n                << std::endl;\n    } else {\n      std::cerr << \"ERROR: could not write output image: out_img=null.\"\n                << std::endl;\n    }\n\n    std::string absolute_expected_bmp_path = expected_bmp_filename_base + \"_\" +\n                                             std::to_string(itr) +\n                                             DEFAULT_EXTENSION;\n\n    std::cout << \"Compare with \" << absolute_expected_bmp_path << \". \"\n              << std::endl;\n    bool passed = bmp_tools::CompareFrames(out_img, rows, cols,\n                                           absolute_expected_bmp_path);\n\n    delete[] out_img;\n    all_passed &= passed & sidebands_ok & (1 == parsed_frames);\n    printf(\"frame %zu %s\\n\", itr,\n           (passed && sidebands_ok) ? \"passed\" : \"failed\");\n  }\n\n  int detected_version = VersionCSR::read(q);\n  std::cout << \"\\nKernel version = \" << detected_version << \" (Expected \"\n            << kKernelVersion << \")\" << std::endl;\n\n  if (detected_version != kKernelVersion) {\n    std::cerr << \"ERROR: kernel version did not match!\" << std::endl;\n    all_passed = false;\n  }\n\n  // Stop the kernel in case testbench wants to run again with different kernel\n  // arguments.\n  StopCSR::write(q, true);\n  e.wait();\n\n  std::cout << \"\\nFinished checking a sequence of good frames.\\n\\n\"\n            << std::endl;\n\n  return all_passed;\n}\n\n/// @brief Test how the IP handles a defective frame by passing a defective\n/// frame (which should emit a partial image) followed by a complete frame\n/// which should match the 'known good' file.\n/// @param[in] q SYCL queue\n/// @param[in] input_bmp_filename Buffer containing the image frame to process\n/// @param[in] output_bmp_filename_base File to output the processed frame to\n/// @param[in] expected_bmp_filename 'known good' file to compare IP output\n/// against\n/// @param[in] print_debug_messages Pass to the `vvp_stream_adapters`\n/// functions to print debug information.\n/// @return `true` if the second frame emitted by the IP matches the `known\n/// good` file, `false` otherwise.\nbool TestDefectiveFrame(sycl::queue q, std::string input_bmp_filename,\n                        std::string output_bmp_filename_base,\n                        std::string expected_bmp_filename,\n                        bool print_debug_messages = false) {\n  std::cout << \"\\n******************************************************\\n\"\n            << \"Check a defective frame followed by a good frame... \"\n            << \"\\n******************************************************\\n\"\n            << std::endl;\n\n  // load image\n  unsigned int *in_img = nullptr;\n  int rows_new, cols_new;\n\n  std::string canonical_input_bmp_path =  //\n      input_bmp_filename + DEFAULT_EXTENSION;\n  std::string canonical_expected_bmp_path =  //\n      expected_bmp_filename + DEFAULT_EXTENSION;\n\n  std::cout << \"Reading input image \" << canonical_input_bmp_path << std::endl;\n  if (!bmp_tools::ReadBmp(canonical_input_bmp_path, &in_img, rows_new,\n                          cols_new)) {\n    std::cerr << \"ERROR: Could not read image from \" << canonical_input_bmp_path\n              << std::endl;\n    return false;\n  }\n\n  size_t rows = 0;\n  size_t cols = 0;\n  bool image_ok = UpdateAndCheckImageDimensions(rows, cols, rows_new, cols_new);\n\n  if (!image_ok) {\n    std::cerr << \"ERROR: invalid image size \" << rows << \" x \" << cols\n              << std::endl;\n  }\n\n  int end_pixel = rows * cols / 2;\n\n  // Enqueue a defective frame that ends after `end_pixel` pixels.\n  conv2d::PixelRGB *in_img_vvp = new conv2d::PixelRGB[rows * cols];\n  conv2d::PixelRGB *out_img_vvp = new conv2d::PixelRGB[rows * cols];\n  unsigned int *out_img = new unsigned int[rows * cols];\n\n  ConvertToVvpRgb(in_img, in_img_vvp, rows * cols);\n\n  vvp_stream_adapters::WriteFrameToPipe<InputImageStream>(\n      q, rows, cols, in_img_vvp, end_pixel);\n\n  // Now enqueue a good frame.\n  vvp_stream_adapters::WriteFrameToPipe<InputImageStream>(q, rows, cols,\n                                                          in_img_vvp);\n\n  int dummy_pixels = cols * conv2d::kWindowSize;\n  vvp_stream_adapters::WriteDummyPixelsToPipe<InputImageStream>(\n      q, dummy_pixels, conv2d::PixelRGB{32, 32, 32});\n\n  // Enqueue the kernel. Run it until we have read out the partial frame and\n  // good frame, then stop.\n  sycl::event e;\n\n  std::cout << \"\\n*********************\" << std::endl;\n  std::cout << \"Launch RGB2Grey kernel\" << std::endl;\n  q.single_task<ID_RGB2Grey>(\n      RGB2Grey<InputImageStream, InputImageStreamGrey>{});\n\n  std::cout << \"Launch Convolution2d kernel\" << std::endl;\n  e = q.single_task<ID_Convolution2d>(\n      Convolution2d<InputImageStreamGrey, OutputImageStreamGrey>{\n          (int)rows, (int)cols, sobel_coeffs});\n\n  std::cout << \"Launch Grey2RGB kernel\" << std::endl;\n  q.single_task<ID_Grey2RGB>(\n      Grey2RGB<OutputImageStreamGrey, OutputImageStream>{});\n\n  std::string defect_output_bmp_path =\n      output_bmp_filename_base + \"_defect\" + DEFAULT_EXTENSION;\n\n  InitializeBuffer(out_img_vvp, rows * cols);\n\n  std::cout << \"\\n****************************\\n\"  //\n            << \"Read out defective frame, and overwrite with good frame.\"\n            << std::endl;\n\n  bool sidebands_ok = false;\n  int parsed_frames = 0;\n  if (out_img_vvp) {\n    vvp_stream_adapters::ReadFrameFromPipe<OutputImageStream>(\n        q, rows, cols, out_img_vvp, sidebands_ok, parsed_frames,\n        print_debug_messages);\n  }\n  bool passed = true;\n\n  // expect the defective frame + the good frame\n  if (2 != parsed_frames) {\n    std::cerr << \"ERROR: saw \" << parsed_frames\n              << \" parsed frames (expected 2).\" << std::endl;\n    passed = false;\n  }\n\n  if (out_img) {\n    ConvertToBmpRgb(out_img_vvp, out_img, rows * cols);\n    bmp_tools::WriteBmp(defect_output_bmp_path, out_img, rows, cols);\n    std::cout << \"Wrote convolved image \" << defect_output_bmp_path\n              << std::endl;\n  } else {\n    std::cerr << \"ERROR: could not write output image: out_img=null.\"\n              << std::endl;\n  }\n\n  // This should succeed since the defective pixels were overwritten by the\n  // subsequent good frame.\n  passed &= bmp_tools::CompareFrames(out_img, rows, cols,\n                                     canonical_expected_bmp_path);\n\n  bool all_passed = passed & sidebands_ok;\n  printf(\"frame 'defect' %s\\n\", (passed && sidebands_ok) ? \"passed\" : \"failed\");\n\n  // Stop the kernel in case testbench wants to run again with different kernel\n  // arguments.\n  StopCSR::write(q, true);\n  e.wait();\n\n  delete[] out_img;\n  delete[] out_img_vvp;\n  delete[] in_img_vvp;\n\n  return all_passed;\n}\n\n#endif\n\nint main(int argc, char **argv) {\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    // make sure the device supports USM host allocations\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // image files\n    std::string input_bmp_filename = M_DEFAULT_INPUT;\n    std::string output_bmp_filename = M_DEFAULT_OUTPUT;\n    std::string expected_bmp_filename = M_DEFAULT_EXPECTED;\n\n    bool all_passed = true;\n\n#if TEST_CONV2D_ISOLATED\n    all_passed &= TestTinyFrameOnStencil(q, false);\n    all_passed &= TestBypass(q, false);\n#else\n    all_passed &= TestGoodFramesSequence(q, NUM_FRAMES, input_bmp_filename,\n                                         output_bmp_filename,\n                                         expected_bmp_filename, false);\n    all_passed &=\n        TestDefectiveFrame(q, input_bmp_filename + \"_0\", output_bmp_filename,\n                           expected_bmp_filename + \"_0\", false);\n#endif\n\n    std::cout << \"\\nOverall result:\\t\" << (all_passed ? \"PASSED\" : \"FAILED\")\n              << std::endl;\n    return EXIT_SUCCESS;\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}"
    },
    {
        "label": "db.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n\n#include <assert.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <memory.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <algorithm>\n#include <chrono>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <string_view>\n#include <vector>\n\n#include \"db_utils/Date.hpp\"\n#include \"db_utils/LikeRegex.hpp\"\n#include \"dbdata.hpp\"\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// include files depending on the query selected\n#if (QUERY == 1)\n#include \"query1/query1_kernel.hpp\"\nbool DoQuery1(queue& q, Database& dbinfo, std::string& db_root_dir,\n              std::string& args, bool test, bool print, double& kernel_latency,\n              double& total_latency);\n#elif (QUERY == 9)\n#include \"query9/query9_kernel.hpp\"\nbool DoQuery9(queue& q, Database& dbinfo, std::string& db_root_dir,\n              std::string& args, bool test, bool print, double& kernel_latency,\n              double& total_latency);\n#elif (QUERY == 11)\n#include \"query11/query11_kernel.hpp\"\nbool DoQuery11(queue& q, Database& dbinfo, std::string& db_root_dir,\n               std::string& args, bool test, bool print, double& kernel_latency,\n               double& total_latency);\n#elif (QUERY == 12)\n#include \"query12/query12_kernel.hpp\"\nbool DoQuery12(queue& q, Database& dbinfo, std::string& db_root_dir,\n               std::string& args, bool test, bool print, double& kernel_latency,\n               double& total_latency);\n#endif\n\n//\n// print help for the program\n//\nvoid Help() {\n  std::cout << \"USAGE:\\n\";\n  std::cout << \"\\t./db --dbroot=<database root directory> [...]\\n\";\n  std::cout << \"\\n\";\n\n  std::cout << \"Optional Arguments:\\n\";\n  std::cout << \"\\t--args=<comma separated arguments for query>\"\n               \"   see the examples below\\n\";\n  std::cout << \"\\t--test    enables testing of the query.\"\n               \" This overrides the arguments to the query (--args) \"\n               \"and uses default input from TPCH documents\\n\";\n  std::cout << \"\\t--print   print the query results to stdout\\n\";\n  std::cout << \"\\t--runs    how many iterations of the query to run\\n\";\n  std::cout << \"\\t--help    print this help message\\n\";\n  std::cout << \"\\n\";\n\n  std::cout << \"Examples:\\n\";\n  std::cout << \"./db --dbroot=/path/to/database/files \"\n            << \"[--test] [--args=<DATE,DELTA>]\\n\";\n  std::cout << \"\\t ./db --dbroot=/path/to/database/files --test\\n\";\n  std::cout << \"\\t ./db --dbroot=/path/to/database/files \"\n            << \"--args=1998-12-01,90\\n\";\n  std::cout << \"\\n\";\n\n  std::cout << \"./db --dbroot=/path/to/database/files \"\n            << \"[--test] [--args=<COLOUR>]\\n\";\n  std::cout << \"\\t ./db --dbroot=/path/to/database/files --test\\n\";\n  std::cout << \"\\t ./db --dbroot=/path/to/database/files --args=GREEN\\n\";\n  std::cout << \"\\n\";\n\n  std::cout << \"./db --dbroot=/path/to/database/files \"\n            << \"[--test] [--args=<NATION>]\\n\";\n  std::cout << \"\\t ./db --dbroot=/path/to/database/files --test\\n\";\n  std::cout << \"\\t ./db --dbroot=/path/to/database/files \"\n            << \"--args=GERMANY\\n\";\n  std::cout << \"\\n\";\n\n  std::cout << \"./db --dbroot=/path/to/database/files [--test] \"\n            << \"[--args=<SHIPMODE1,SHIPMODE2,DATE>]\\n\";\n  std::cout << \"\\t ./db --dbroot=/path/to/database/files --test\\n\";\n  std::cout << \"\\t ./db --dbroot=/path/to/database/files \"\n            << \"--args=MAIL,SHIP,1994-01-10\\n\";\n  std::cout << \"\\n\";\n}\n\n//\n// determine if a string starts with a prefix\n//\nbool StrStartsWith(std::string& str, std::string prefix) {\n  return str.find(prefix) == 0;\n}\n\n//\n// main\n//\nint main(int argc, char* argv[]) {\n  // argument defaults\n  Database dbinfo;\n  std::string db_root_dir = \".\";\n  std::string args = \"\";\n  unsigned int query = QUERY;\n  bool test_query = false;\n#if defined(FPGA_EMULATOR)\n  unsigned int runs = 1;\n#elif defined(FPGA_SIMULATOR)\n  unsigned int runs = 1;\n#else\n  unsigned int runs = 5;\n#endif\n  bool print_result = false;\n  bool need_help = false;\n\n  // parse the command line arguments\n  for (int i = 1; i < argc; i++) {\n    std::string arg(argv[i]);\n\n    if (arg == \"--help\" || arg == \"-h\") {\n      need_help = true;\n    } else {\n      std::string str_after_equals = arg.substr(arg.find(\"=\") + 1);\n\n      if (StrStartsWith(arg, \"--dbroot=\")) {\n        db_root_dir = str_after_equals;\n      } else if (StrStartsWith(arg, \"--query=\")) {\n        query = atoi(str_after_equals.c_str());\n      } else if (StrStartsWith(arg, \"--args=\")) {\n        args = str_after_equals;\n      } else if (StrStartsWith(arg, \"--test\")) {\n        test_query = true;\n      } else if (StrStartsWith(arg, \"--print\")) {\n        print_result = true;\n      } else if (StrStartsWith(arg, \"--runs\")) {\n#ifndef FPGA_EMULATOR\n        // for hardware, ensure at least two iterations to ensure we can run\n        // a 'warmup' iteration\n        runs = std::max(2, atoi(str_after_equals.c_str()) + 1);\n#else\n        // for emulation and simulation, allow a single iteration and \n        // don't add a 'warmup' run\n        runs = std::max(1, atoi(str_after_equals.c_str()));\n#endif\n      } else {\n        std::cout << \"WARNING: ignoring unknown argument '\" << arg << \"'\\n\";\n      }\n    }\n  }\n\n  // print help if needed or asked\n  if (need_help) {\n    Help();\n    return 0;\n  }\n\n  // make sure the query is supported\n  if (!(query == 1 || query == 9 || query == 11 || query == 12)) {\n    std::cerr << \"ERROR: unsupported query (\" << query << \"). \"\n              << \"Only queries 1, 9, 11 and 12 are supported\\n\";\n    return 1;\n  }\n\n  if (query != QUERY) {\n    std::cerr << \"ERROR: project not currently configured for query \" << query\n              << \"\\n\";\n    std::cerr << \"\\trerun CMake using the command: 'cmake .. -DQUERY=\" << query\n              << \"'\\n\";\n    return 1;\n  }\n\n  try {\n    // queue properties to enable profiling\n    auto props = property_list{property::queue::enable_profiling()};\n\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    queue q(selector, fpga_tools::exception_handler, props);\n\n    device device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<info::device::name>().c_str() \n              << std::endl;\n\n    // parse the database files located in the 'db_root_dir' directory\n    bool success = dbinfo.Parse(db_root_dir);\n    if (!success) {\n      std::cerr << \"ERROR: couldn't read the DB files\\n\";\n      return 1;\n    }\n\n    std::cout << \"Database SF = \" << kSF << \"\\n\";\n\n    // make sure the parsed database files match the set scale factor\n    if (!dbinfo.ValidateSF()) {\n      std::cerr << \"ERROR: could not validate the \"\n                << \"scale factor of the parsed database files\\n\";\n      return 1;\n    }\n\n    // track timing information for each run\n    std::vector<double> total_latency(runs);\n    std::vector<double> kernel_latency(runs);\n\n    // run 'runs' iterations of the query\n    for (unsigned int run = 0; run < runs && success; run++) {\n      // run the selected query\n      if (query == 1) {\n#if (QUERY == 1)\n        success = DoQuery1(q, dbinfo, db_root_dir, args,\n                           test_query, print_result,\n                           kernel_latency[run], total_latency[run]);\n#endif\n      } else if (query == 9) {\n        // query9\n#if (QUERY == 9)\n        success = DoQuery9(q, dbinfo, db_root_dir, args,\n                           test_query, print_result,\n                           kernel_latency[run], total_latency[run]);\n#endif\n      } else if (query == 11) {\n        // query11\n#if (QUERY == 11)\n        success = DoQuery11(q, dbinfo, db_root_dir, args,\n                            test_query, print_result,\n                            kernel_latency[run], total_latency[run]);\n#endif\n      } else if (query == 12) {\n        // query12\n#if (QUERY == 12)\n        success = DoQuery12(q, dbinfo, db_root_dir, args,\n                            test_query, print_result,\n                            kernel_latency[run], total_latency[run]);\n#endif\n      } else {\n        std::cerr << \"ERROR: unsupported query (\" << query << \")\\n\";\n        return 1;\n      }\n    }\n\n    if (success) {\n      // don't analyze the runtime in emulation\n#if !defined(FPGA_EMULATOR) && !defined(FPGA_SIMULATOR)\n      // compute the average total latency across all iterations,\n      // excluding the first 'warmup' iteration\n      double total_latency_avg =\n          std::accumulate(total_latency.begin() + 1, total_latency.end(), 0.0) /\n          (double)(runs - 1);\n\n      double kernel_latency_avg =\n        std::accumulate(kernel_latency.begin() + 1, kernel_latency.end(), 0.0) /\n        (double)(runs - 1);\n\n      // print the performance results\n      std::cout << \"Processing time: \" << total_latency_avg << \" ms\\n\";\n      std::cout << \"Kernel time: \" << kernel_latency_avg << \" ms\\n\";\n      std::cout << \"Throughput: \" << ((1 / kernel_latency_avg) * 1e3)\n                << \" queries/s\\n\";\n#endif\n\n      std::cout << \"PASSED\\n\";\n    } else {\n      std::cout << \"FAILED\\n\";\n      return 1;\n    }\n\n  } catch (exception const& e) {\n    // Catches exceptions in the host code\n    std::cout << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cout << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cout << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n      std::cout << \"If you are targeting the FPGA simulator, compile with \"\n                   \"-DFPGA_SIMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return 0;\n}\n\n#if (QUERY == 1)\nbool DoQuery1(queue& q, Database& dbinfo, std::string& db_root_dir,\n              std::string& args, bool test, bool print, double& kernel_latency,\n              double& total_latency) {\n  // NOTE: this is fixed based on the TPCH docs\n  Date date = Date(\"1998-12-01\");\n  unsigned int DELTA = 90;\n\n  // parse the query arguments\n  if (!test && !args.empty()) {\n    std::stringstream ss(args);\n    std::string tmp;\n    std::getline(ss, tmp, ',');\n    DELTA = atoi(tmp.c_str());\n  } else {\n    if (!args.empty()) {\n      std::cout << \"Testing query 1, therefore ignoring the '--args' flag\\n\";\n    }\n  }\n\n  // check query arguments\n  if (!(DELTA <= 120 && DELTA >= 60)) {\n    std::cerr << \"ERROR: DELTA must be in the range [60,120]\\n\";\n    return false;\n  }\n\n  // compute query interval\n  Date low_date = date.PreviousDate(DELTA);\n  unsigned int low_date_compact = low_date.ToCompact();\n\n  std::cout << \"Running Q1 within \" << DELTA << \" days of \" << date.year << \"-\"\n            << date.month << \"-\" << date.day << std::endl;\n\n  // the query output data\n  std::array<DBDecimal, kQuery1OutSize> sum_qty = {0}, sum_base_price = {0},\n                                       sum_disc_price = {0}, sum_charge = {0},\n                                       avg_qty = {0}, avg_price = {0},\n                                       avg_discount = {0}, count = {0};\n\n  // perform the query\n  bool success =\n      SubmitQuery1(q, dbinfo, low_date_compact, sum_qty, sum_base_price,\n                   sum_disc_price, sum_charge, avg_qty, avg_price, avg_discount,\n                   count, kernel_latency, total_latency);\n\n  if (success) {\n    // validate the results of the query, if requested\n    if (test) {\n      success = dbinfo.ValidateQ1(db_root_dir, sum_qty, sum_base_price,\n                                  sum_disc_price, sum_charge, avg_qty,\n                                  avg_price, avg_discount, count);\n    }\n\n    // print the results of the query, if requested\n    if (print) {\n      dbinfo.PrintQ1(sum_qty, sum_base_price, sum_disc_price, sum_charge,\n                     avg_qty, avg_price, avg_discount, count);\n    }\n  }\n\n  return success;\n}\n#endif\n\n#if (QUERY == 9)\nbool DoQuery9(queue& q, Database& dbinfo, std::string& db_root_dir,\n              std::string& args, bool test, bool print, double& kernel_latency,\n              double& total_latency) {\n  // the default colour regex based on the TPCH documents\n  std::string colour = \"GREEN\";\n\n  // parse the query arguments\n  if (!test && !args.empty()) {\n    std::stringstream ss(args);\n    std::getline(ss, colour, ',');\n  } else {\n    if (!args.empty()) {\n      std::cout << \"Testing query 9, therefore ignoring the '--args' flag\\n\";\n    }\n  }\n\n  // convert the colour regex to uppercase characters (convention)\n  transform(colour.begin(), colour.end(), colour.begin(), ::toupper);\n\n  std::cout << \"Running Q9 with colour regex: \" << colour << std::endl;\n\n  // the output of the query\n  std::array<DBDecimal, 25 * 2020> sum_profit;\n\n  // perform the query\n  bool success = SubmitQuery9(q, dbinfo, colour, sum_profit, kernel_latency,\n                              total_latency);\n\n  if (success) {\n    // validate the results of the query, if requested\n    if (test) {\n      success = dbinfo.ValidateQ9(db_root_dir, sum_profit);\n    }\n\n    // print the results of the query, if requested\n    if (print) {\n      dbinfo.PrintQ9(sum_profit);\n    }\n  }\n\n  return success;\n}\n#endif\n\n#if (QUERY == 11)\nbool DoQuery11(queue& q, Database& dbinfo, std::string& db_root_dir,\n               std::string& args, bool test, bool print, double& kernel_latency,\n               double& total_latency) {\n  // the default nation, based on the TPCH documents\n  std::string nation = \"GERMANY\";\n\n  // parse the query arguments\n  if (!test && !args.empty()) {\n    std::stringstream ss(args);\n    std::getline(ss, nation, ',');\n  } else {\n    if (!args.empty()) {\n      std::cout << \"Testing query 11, therefore ignoring the '--args' flag\\n\";\n    }\n  }\n\n  // convert the nation name to uppercase characters (convention)\n  transform(nation.begin(), nation.end(), nation.begin(), ::toupper);\n\n  std::cout << \"Running Q11 for nation \" << nation.c_str()\n            << \" (key=\" << (int)(dbinfo.n.name_key_map[nation]) << \")\"\n            << std::endl;\n\n  // the query output\n  std::vector<DBIdentifier> partkeys(kPartTableSize);\n  std::vector<DBDecimal> partkey_values(kPartTableSize);\n\n  // perform the query\n  bool success = SubmitQuery11(q, dbinfo, nation, partkeys, partkey_values,\n                               kernel_latency, total_latency);\n\n  if (success) {\n    // validate the results of the query, if requested\n    if (test) {\n      success = dbinfo.ValidateQ11(db_root_dir, partkeys, partkey_values);\n    }\n\n    // print the results of the query, if requested\n    if (print) {\n      dbinfo.PrintQ11(partkeys, partkey_values);\n    }\n  }\n\n  return success;\n}\n#endif\n\n#if (QUERY == 12)\nbool DoQuery12(queue& q, Database& dbinfo, std::string& db_root_dir,\n               std::string& args, bool test, bool print, double& kernel_latency,\n               double& total_latency) {\n  // the default query date and shipmodes, based on the TPCH documents\n  Date date = Date(\"1994-01-01\");\n  std::string shipmode1 = \"MAIL\", shipmode2 = \"SHIP\";\n\n  // parse the query arguments\n  if (!test && !args.empty()) {\n    std::stringstream ss(args);\n    std::string tmp;\n\n    std::getline(ss, tmp, ',');\n    date = Date(tmp);\n\n    if (ss.good()) {\n      std::getline(ss, shipmode1, ',');\n    }\n\n    if (ss.good()) {\n      std::getline(ss, shipmode2, ',');\n    }\n  } else {\n    if (!args.empty()) {\n      std::cout << \"Testing query 12, therefore ignoring the '--args' flag\\n\";\n    }\n  }\n\n  // check the arguments, date must be January 1 of some year\n  if (date.month != 1 || date.day != 1) {\n    std::cerr << \"ERROR: Date must be first of January \"\n              << \"in the given year (e.g. 1994-01-01)\\n\";\n    return false;\n  }\n\n  // compute the interval for the query\n  Date low_date = date;\n  Date high_date = Date(low_date.year + 1, low_date.month, low_date.day);\n\n  std::cout << \"Running Q12 between years \" << low_date.year << \" and \"\n            << high_date.year << \" for SHIPMODES \" << shipmode1 << \" and \"\n            << shipmode2 << std::endl;;\n\n  // the output of the query\n  std::array<DBDecimal, 2> high_line_count, low_line_count;\n\n  // perform the query\n  bool success = SubmitQuery12(\n      q, dbinfo, low_date.ToCompact(), high_date.ToCompact(),\n      ShipmodeStrToInt(shipmode1), ShipmodeStrToInt(shipmode2), high_line_count,\n      low_line_count, kernel_latency, total_latency);\n\n  if (success) {\n    // validate the results of the query, if requested\n    if (test) {\n      success =\n          dbinfo.ValidateQ12(db_root_dir, high_line_count, low_line_count);\n    }\n\n    // print the results of the query, if requested\n    if (print) {\n      dbinfo.PrintQ12(shipmode1, shipmode2, high_line_count, low_line_count);\n    }\n  }\n\n  return success;\n}\n#endif\n"
    },
    {
        "label": "dbdata.cpp",
        "data": "#include <assert.h>\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <stdio.h>\n#include <vector>\n\n#include \"dbdata.hpp\"\n#include \"db_utils/Date.hpp\"\n\n// choose a file separator based on the platform (Windows or Linux)\n#if defined(WIN32) || defined(_WIN32) || defined(_MSC_VER)\nconstexpr char kSeparator = '\\\\';\n#else \nconstexpr char kSeparator = '/';\n#endif\n\n//\n// split a row in the database file on its separator ('|')\n//\nstd::vector<std::string> SplitRowStr(const std::string& row) {\n  std::stringstream ss(row);\n  std::string segment;\n  std::vector<std::string> columns;\n\n  while (std::getline(ss, segment, '|')) {\n    columns.push_back(segment);\n  }\n\n  return columns;\n}\n\n//\n// appends 'n' characters of a string to a vector\n//\nvoid AppendStringToCharVec(std::vector<char>& v, const std::string& str,\n                           const unsigned int n) {\n  // append the 'n' characters, padding with null terminators ('\\0')\n  const size_t str_n = str.size();\n  for (size_t i = 0; i < n; i++) {\n    v.push_back(i < str_n ? str[i] : '\\0');\n  }\n}\n\n//\n// convert a money string (i.e. '1209.12' dollars) to\n// the internal 'cents' representation (i.e. '120912' cents)\n//\nDBDecimal MoneyFloatToCents(const std::string& money_float_str) {\n  // parse money string\n  std::istringstream ss(money_float_str);\n  std::string dollars_str, cents_str;\n\n  std::getline(ss, dollars_str, '.');\n  std::getline(ss, cents_str, '.');\n  \n  DBDecimal dollars = atoi(dollars_str.c_str());\n  DBDecimal cents = atoi(cents_str.c_str());\n\n  // convert to fixed point format (i.e. in cents)\n  return dollars * 100 + cents;\n}\n\n//\n// convert a SHIPMODE string to the internal representation (integer)\n//\nint ShipmodeStrToInt(std::string& shipmode_str) {\n  if (shipmode_str == \"REG AIR\") {\n    return 0;\n  } else if (shipmode_str == \"AIR\") {\n    return 1;\n  } else if (shipmode_str == \"RAIL\") {\n    return 2;\n  } else if (shipmode_str == \"SHIP\") {\n    return 3;\n  } else if (shipmode_str == \"TRUCK\") {\n    return 4;\n  } else if (shipmode_str == \"MAIL\") {\n    return 5;\n  } else if (shipmode_str == \"FOB\") {\n    return 6;\n  } else {\n    std::cerr << \"WARNING: Found unknown SHIPMODE '\" << shipmode_str\n              << \" defaulting to REG AIR\\n\";\n    return 0;\n  }\n}\n\n//\n// check if two decimal values are within an epsilon of each other\n//\nbool AlmostEqual(double x, double y, double epsilon = 0.01f) {\n  return std::fabs(x - y) < epsilon;\n}\n\n//\n// trim the leading whitespace of a std::string\n//\nvoid ltrim(std::string& s) {\n  s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) { \n    return !std::isspace(ch);\n  }));\n}\n\n//\n// trim the trailing whitespace of a std::string\n//\nvoid rtrim(std::string& s) {\n  s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) { \n    return !std::isspace(ch);\n  }).base(), s.end());\n}\n\n//\n// trim leading and trailing whitespace of a string\n//\nvoid trim(std::string& s) {\n  ltrim(s);\n  rtrim(s);\n}\n\n//\n// the main parsing function\n// parses '*.tbl' files location in directory 'db_root_dir'\n//\nbool Database::Parse(std::string db_root_dir) {\n  std::cout << \"Parsing database files in: \" << db_root_dir << std::endl;\n\n  bool success = true;\n\n  // parse each table\n  success &= ParseLineItemTable(db_root_dir + kSeparator + \"lineitem.tbl\", l);\n  success &= ParseOrdersTable(db_root_dir + kSeparator +\"orders.tbl\", o);\n  success &= ParsePartsTable(db_root_dir + kSeparator + \"part.tbl\", p);\n  success &= ParseSupplierTable(db_root_dir + kSeparator + \"supplier.tbl\", s);\n  success &= ParsePartSupplierTable(db_root_dir + kSeparator + \"partsupp.tbl\", ps);\n  success &= ParseNationTable(db_root_dir + kSeparator + \"nation.tbl\", n);\n\n  return success;\n}\n\n//\n// parse the LINEITEM table\n//\nbool Database::ParseLineItemTable(std::string f, LineItemTable& tbl) {\n  std::cout << \"Parsing LINEITEM table from: \" << f << \"\\n\";\n\n  // populate data row by row (as presented in the file)\n  std::ifstream ifs(f);\n  std::string line;\n  tbl.rows = 0;\n\n  if (!ifs.is_open()) {\n    std::cout << \"Failed to parse LINEITEM table\\n\";\n    return false;\n  }\n\n  while (std::getline(ifs, line)) {\n    // split row into column strings by separator ('|')\n    std::vector<std::string> column_data = SplitRowStr(line);\n    assert(column_data.size() == 16);\n\n    tbl.orderkey.push_back(std::stoll(column_data[0]));\n    tbl.partkey.push_back(std::stoll(column_data[1]));\n    tbl.suppkey.push_back(std::stoll(column_data[2]));\n    tbl.linenumber.push_back(std::stoll(column_data[3]));\n    tbl.quantity.push_back(std::stoll(column_data[4]));\n\n    tbl.extendedprice.push_back(MoneyFloatToCents(column_data[5]));\n    tbl.discount.push_back(MoneyFloatToCents(column_data[6]));\n    tbl.tax.push_back(MoneyFloatToCents(column_data[7]));\n\n    tbl.returnflag.push_back(column_data[8].at(0));\n    tbl.linestatus.push_back(column_data[9].at(0));\n\n    tbl.shipdate.push_back(Date(column_data[10]).ToCompact());\n    tbl.commitdate.push_back(Date(column_data[11]).ToCompact());\n    tbl.receiptdate.push_back(Date(column_data[12]).ToCompact());\n\n    AppendStringToCharVec(tbl.shipinstruct, column_data[13], 25);\n    tbl.shipmode.push_back(ShipmodeStrToInt(column_data[14]));\n    AppendStringToCharVec(tbl.comment, column_data[15], 44);\n\n    tbl.rows++;\n  }\n\n  for (size_t i = 0; i < kPaddingRows; i++) {\n    tbl.orderkey.push_back(0);\n    tbl.partkey.push_back(0);\n    tbl.suppkey.push_back(0);\n    tbl.linenumber.push_back(0);\n    tbl.quantity.push_back(0);\n\n    tbl.extendedprice.push_back(0);\n    tbl.discount.push_back(0);\n    tbl.tax.push_back(0);\n\n    tbl.returnflag.push_back(0);\n    tbl.linestatus.push_back(0);\n\n    tbl.shipdate.push_back(0);\n    tbl.commitdate.push_back(0);\n    tbl.receiptdate.push_back(0);\n\n    tbl.shipmode.push_back(0);\n  }\n\n  std::cout << \"Finished parsing LINEITEM table with \" << tbl.rows << \" rows\\n\";\n\n  return true;\n}\n\n//\n// parse the ORDERS table\n//\nbool Database::ParseOrdersTable(std::string f, OrdersTable& tbl) {\n  std::cout << \"Parsing ORDERS table from: \" << f << \"\\n\";\n\n  // populate data row by row (as presented in the file)\n  std::ifstream ifs(f);\n  std::string line;\n  tbl.rows = 0;\n\n  if (!ifs.is_open()) {\n    std::cout << \"Failed to parse ORDERS table\\n\";\n    return false;\n  }\n\n  while (std::getline(ifs, line)) {\n    // split row into column strings by separator ('|')\n    std::vector<std::string> column_data = SplitRowStr(line);\n    assert(column_data.size() == 9);\n\n    // store date for this row\n    tbl.orderkey.push_back(std::stoll(column_data[0]));\n    tbl.custkey.push_back(std::stoll(column_data[1]));\n    tbl.orderstatus.push_back(column_data[2][0]);\n    tbl.totalprice.push_back(MoneyFloatToCents(column_data[3]));\n    tbl.orderdate.push_back(Date(column_data[4]).ToCompact());\n    tbl.orderpriority.push_back((int)(column_data[5][0] - '0'));\n    AppendStringToCharVec(tbl.clerk, column_data[6], 15);\n    tbl.shippriority.push_back(std::stoi(column_data[7]));\n    AppendStringToCharVec(tbl.comment, column_data[8], 80);\n\n    tbl.rows++;\n  }\n\n  for (size_t i = 0; i < kPaddingRows; i++) {\n    tbl.orderkey.push_back(0);\n    tbl.custkey.push_back(0);\n    tbl.orderstatus.push_back(0);\n    tbl.totalprice.push_back(0);\n    tbl.orderdate.push_back(0);\n    tbl.orderpriority.push_back(0);\n    tbl.shippriority.push_back(0);\n  }\n\n\n  std::cout << \"Finished parsing ORDERS table with \" << tbl.rows << \" rows\\n\";\n\n  return true;\n}\n\n//\n// parse the PARTS table\n//\nbool Database::ParsePartsTable(std::string f, PartsTable& tbl) {\n  std::cout << \"Parsing PARTS table from: \" << f << \"\\n\";\n\n  // populate data row by row (as presented in the file)\n  std::ifstream ifs(f);\n  std::string line;\n  tbl.rows = 0;\n\n  if (!ifs.is_open()) {\n    std::cout << \"Failed to parse PARTS table\\n\";\n    return false;\n  }\n\n  while (std::getline(ifs, line)) {\n    // split row into column strings by separator ('|')\n    std::vector<std::string> column_data = SplitRowStr(line);\n    assert(column_data.size() == 9);\n\n    tbl.partkey.push_back(std::stoll(column_data[0]));\n\n    // formatting part name: no spaces, all uppercase\n    transform(column_data[1].begin(), column_data[1].end(),\n              column_data[1].begin(), ::toupper);\n    AppendStringToCharVec(tbl.name, column_data[1], 55);\n\n    AppendStringToCharVec(tbl.mfgr, column_data[2], 25);\n    AppendStringToCharVec(tbl.brand, column_data[3], 10);\n    AppendStringToCharVec(tbl.type, column_data[4], 25);\n    tbl.size.push_back(std::stoi(column_data[5]));\n    AppendStringToCharVec(tbl.container, column_data[6], 10);\n    tbl.retailprice.push_back(MoneyFloatToCents(column_data[7]));\n    AppendStringToCharVec(tbl.comment, column_data[8], 23);\n\n    tbl.rows++;\n  }\n\n  for (size_t i = 0; i < kPaddingRows; i++) {\n    tbl.partkey.push_back(0);\n    AppendStringToCharVec(tbl.name, \"INVALID\", 55);\n  }\n\n  std::cout << \"Finished parsing PARTS table with \" << tbl.rows << \" rows\\n\";\n\n  return true;\n}\n\n//\n// parse the SUPPLIER table\n//\nbool Database::ParseSupplierTable(std::string f, SupplierTable& tbl) {\n  std::cout << \"Parsing SUPPLIER table from: \" << f << \"\\n\";\n\n  // populate data row by row (as presented in the file)\n  std::ifstream ifs(f);\n  std::string line;\n  tbl.rows = 0;\n\n  if (!ifs.is_open()) {\n    std::cout << \"Failed to parse SUPPLIER table\\n\";\n    return false;\n  }\n\n  while (std::getline(ifs, line)) {\n    // split row into column strings by separator ('|')\n    std::vector<std::string> column_data = SplitRowStr(line);\n    assert(column_data.size() == 7);\n\n    tbl.suppkey.push_back(std::stoll(column_data[0]));\n    AppendStringToCharVec(tbl.name, column_data[1], 25);\n    AppendStringToCharVec(tbl.address, column_data[2], 40);\n    tbl.nationkey.push_back((unsigned char)(std::stoul(column_data[3])));\n    AppendStringToCharVec(tbl.phone, column_data[4], 15);\n    tbl.acctbal.push_back(MoneyFloatToCents(column_data[5]));\n    AppendStringToCharVec(tbl.comment, column_data[6], 101);\n\n    tbl.rows++;\n  }\n\n  for (size_t i = 0; i < kPaddingRows; i++) {\n    tbl.suppkey.push_back(0);\n    AppendStringToCharVec(tbl.name, \"INVALID\", 25);\n    tbl.nationkey.push_back(0);\n    tbl.acctbal.push_back(0);\n  }\n\n  std::cout << \"Finished parsing SUPPLIER table with \" << tbl.rows << \" rows\\n\";\n\n  return true;\n}\n\n//\n// parse the PARTSUPPLIER table\n//\nbool Database::ParsePartSupplierTable(std::string f, PartSupplierTable& tbl) {\n  std::cout << \"Parsing PARTSUPPLIER table from: \" << f << \"\\n\";\n\n  // populate data row by row (as presented in the file)\n  std::ifstream ifs(f);\n  std::string line;\n  tbl.rows = 0;\n\n  if (!ifs.is_open()) {\n    std::cout << \"Failed to parse PARTSUPPLIER table\\n\";\n    return false;\n  }\n\n  while (std::getline(ifs, line)) {\n    // split row into column strings by separator ('|')\n    std::vector<std::string> column_data = SplitRowStr(line);\n    assert(column_data.size() == 5);\n\n    tbl.partkey.push_back(std::stoll(column_data[0]));\n    tbl.suppkey.push_back(std::stoll(column_data[1]));\n    tbl.availqty.push_back(std::stoi(column_data[2]));\n    tbl.supplycost.push_back(MoneyFloatToCents(column_data[3]));\n    AppendStringToCharVec(tbl.comment, column_data[4], 199);\n\n    tbl.rows++;\n  }\n\n  for (size_t i = 0; i < kPaddingRows; i++) {\n    tbl.partkey.push_back(0);\n    tbl.suppkey.push_back(0);\n    tbl.availqty.push_back(0);\n    tbl.supplycost.push_back(0);\n  }\n\n  std::cout << \"Finished parsing PARTSUPPLIER table with \" << tbl.rows\n            << \" rows\\n\";\n\n  return true;\n}\n\n//\n// parse the NATION table\n//\nbool Database::ParseNationTable(std::string f, NationTable& tbl) {\n  std::cout << \"Parsing NATION table from: \" << f << \"\\n\";\n\n  // populate data row by row (as presented in the file)\n  std::ifstream ifs(f);\n  std::string line;\n  tbl.rows = 0;\n\n  if (!ifs.is_open()) {\n    std::cout << \"Failed to parse NATION table\\n\";\n    return false;\n  }\n\n  while (std::getline(ifs, line)) {\n    // split row into column strings by separator ('|')\n    std::vector<std::string> column_data = SplitRowStr(line);\n    assert(column_data.size() == 4);\n\n    DBIdentifier nationkey = std::stoll(column_data[0]);\n    std::string nationname = column_data[1];\n\n    tbl.nationkey.push_back(nationkey);\n\n    // convention: all upper case\n    trim(nationname);\n    transform(nationname.begin(), nationname.end(), nationname.begin(),\n              ::toupper);\n    AppendStringToCharVec(tbl.name, nationname, 25);\n\n    tbl.regionkey.push_back(std::stoll(column_data[2]));\n    AppendStringToCharVec(tbl.comment, column_data[3], 152);\n\n    // add entry into map\n    tbl.name_key_map[nationname] = nationkey;\n    tbl.key_name_map[nationkey] = nationname;\n\n    tbl.rows++;\n  }\n\n  std::cout << \"Finished parsing NATION table with \" << tbl.rows << \" rows\\n\";\n\n  return true;\n}\n\n//\n// Checks the size of each parsed table against the expected size based\n// on the selected scale factor\n//\nbool Database::ValidateSF() {\n  bool ret = true;\n\n  if (l.rows != kLineItemTableSize) {\n    std::cerr << \"LineItem table size has \" << l.rows << \" rows\"\n              << \" when it should have \" << kLineItemTableSize << \"\\n\";\n    ret = false;\n  }\n\n  if (o.rows != kOrdersTableSize) {\n    std::cerr << \"Orders table size has \" << o.rows << \" rows\"\n              << \" when it should have \" << kOrdersTableSize << \"\\n\";\n    ret = false;\n  }\n\n  if (p.rows != kPartTableSize) {\n    std::cerr << \"Parts table size has \" << p.rows << \" rows\"\n              << \" when it should have \" << kPartTableSize << \"\\n\";\n    ret = false;\n  }\n\n  if (s.rows != kSupplierTableSize) {\n    std::cerr << \"Supplier table size has \" << s.rows << \" rows\"\n              << \" when it should have \" << kSupplierTableSize << \"\\n\";\n    ret = false;\n  }\n\n  if (ps.rows != kPartSupplierTableSize) {\n    std::cerr << \"PartSupplier table size has \" << ps.rows << \" rows\"\n              << \" when it should have \" << kPartSupplierTableSize << \"\\n\";\n    ret = false;\n  }\n\n  if (n.rows != kNationTableSize) {\n    std::cerr << \"Nation table size has \" << n.rows << \" rows\"\n              << \" when it should have \" << kNationTableSize << \"\\n\";\n    ret = false;\n  }\n\n  return ret;\n}\n\n//\n// validate the results of Query 1\n//\nbool Database::ValidateQ1(std::string db_root_dir,\n                          std::array<DBDecimal, 3 * 2>& sum_qty,\n                          std::array<DBDecimal, 3 * 2>& sum_base_price,\n                          std::array<DBDecimal, 3 * 2>& sum_disc_price,\n                          std::array<DBDecimal, 3 * 2>& sum_charge,\n                          std::array<DBDecimal, 3 * 2>& avg_qty,\n                          std::array<DBDecimal, 3 * 2>& avg_price,\n                          std::array<DBDecimal, 3 * 2>& avg_discount,\n                          std::array<DBDecimal, 3 * 2>& count) {\n  std::cout << \"Validating query 1 test results\" << std::endl;\n\n  // populate date row by row (as presented in the file)\n  std::string path(db_root_dir + kSeparator + \"answers\" + kSeparator + \"q1.out\");\n  std::ifstream ifs(path);\n\n  bool valid = true;\n\n  if (!ifs.is_open()) {\n    std::cout << \"Failed to open \" << path << \"\\n\";\n    return false;\n  }\n\n  // this will hold the line read from the input file\n  std::string line;\n\n  // do nothing with the first line, it is a header line\n  std::getline(ifs, line);\n\n  while (std::getline(ifs, line)) {\n    // split row into column strings by separator ('|')\n    std::vector<std::string> column_data = SplitRowStr(line);\n    assert(column_data.size() == 10);\n\n    char rf = column_data[0][0];\n    char ls = column_data[1][0];\n    double sum_qty_gold = std::stod(column_data[2]);\n    double sum_base_price_gold = std::stod(column_data[3]);\n    double sum_disc_price_gold = std::stod(column_data[4]);\n    double sum_charge_gold = std::stod(column_data[5]);\n    double avg_qty_gold = std::stod(column_data[6]);\n    double avg_price_gold = std::stod(column_data[7]);\n    double avg_disc_gold = std::stod(column_data[8]);\n    unsigned int count_order_gold = std::stoll(column_data[9]);\n\n    unsigned int rf_idx;\n    if (rf == 'R') {\n      rf_idx = 0;\n    } else if (rf == 'A') {\n      rf_idx = 1;\n    } else {  // == 'N'\n      rf_idx = 2;\n    }\n    unsigned int ls_idx;\n    if (ls == 'O') {\n      ls_idx = 0;\n    } else {  // == 'F'\n      ls_idx = 1;\n    }\n    unsigned int idx = ls_idx * 3 + rf_idx;\n    assert(idx < 6);\n\n    double sum_qty_res = (double)(sum_qty[idx]);\n    double sum_base_price_res = (double)(sum_base_price[idx]) / (100.00);\n    double sum_disc_price_res =\n        (double)(sum_disc_price[idx]) / (100.00 * 100.00);\n    double sum_charge_res =\n        (double)(sum_charge[idx]) / (100.00 * 100.00 * 100.00);\n    double avg_qty_res = (double)(avg_qty[idx]);\n    double avg_price_res = (double)(avg_price[idx]) / (100.00);\n    double avg_disc_res = (double)(avg_discount[idx]) / (100.00);\n    unsigned int count_order_res = count[idx];\n\n    if (!AlmostEqual(sum_qty_gold, sum_qty_res, 0.01f)) {\n      std::cerr << \"ERROR: sum_qty for returnflag=\" << rf\n                << \" and linestatus=\" << ls << \" (Expected=\" << sum_qty_gold\n                << \", Result=\" << sum_qty_res << \")\\n\";\n      valid = false;\n    }\n    if (!AlmostEqual(sum_base_price_gold, sum_base_price_res, 0.01f)) {\n      std::cerr << \"ERROR: sum_base_price for returnflag=\" << rf\n                << \" and linestatus=\" << ls\n                << \" (Expected=\" << sum_base_price_gold\n                << \", Result=\" << sum_base_price_res << \")\\n\";\n      valid = false;\n    }\n    if (!AlmostEqual(sum_disc_price_gold, sum_disc_price_res, 0.01f)) {\n      std::cerr << \"ERROR: sum_disc_price for returnflag=\" << rf\n                << \" and linestatus=\" << ls\n                << \" (Expected=\" << sum_disc_price_gold\n                << \", Result=\" << sum_disc_price_res << \")\\n\";\n      valid = false;\n    }\n    if (!AlmostEqual(sum_charge_gold, sum_charge_res, 0.01f)) {\n      std::cerr << \"ERROR: sum_charge for returnflag=\" << rf\n                << \" and linestatus=\" << ls << \" (Expected=\" << sum_charge_gold\n                << \", Result=\" << sum_charge_res << \")\\n\";\n      valid = false;\n    }\n    if (!AlmostEqual(avg_qty_gold, avg_qty_res, 1.0f)) {\n      std::cerr << \"ERROR: avg_qty for returnflag=\" << rf\n                << \" and linestatus=\" << ls << \" (Expected=\" << avg_qty_gold\n                << \", Result=\" << avg_qty_res << \")\\n\";\n      valid = false;\n    }\n    if (!AlmostEqual(avg_price_gold, avg_price_res, 1.0f)) {\n      std::cerr << \"ERROR: avg_price for returnflag=\" << rf\n                << \" and linestatus=\" << ls << \" (Expected=\" << avg_price_gold\n                << \", Result=\" << avg_price_res << \")\\n\";\n      valid = false;\n    }\n    if (!AlmostEqual(avg_disc_gold, avg_disc_res, 1.0f)) {\n      std::cerr << \"ERROR: avg_disc for returnflag=\" << rf\n                << \" and linestatus=\" << ls << \" (Expected=\" << avg_disc_gold\n                << \", Result=\" << avg_disc_res << \")\\n\";\n      valid = false;\n    }\n    if (count_order_gold != count_order_res) {\n      std::cerr << \"ERROR: count for returnflag=\" << rf\n                << \" and linestatus=\" << ls << \" (Expected=\" << count_order_gold\n                << \", Result=\" << count_order_res << \")\\n\";\n      valid = false;\n    }\n  }\n\n  return valid;\n}\n\n//\n// validate the results of Query 9\n//\nbool Database::ValidateQ9(std::string db_root_dir,\n                          std::array<DBDecimal, 25 * 2020>& sum_profit) {\n  std::cout << \"Validating query 9 test results\" << std::endl;\n\n  // populate date row by row (as presented in the file)\n  std::string path(db_root_dir + kSeparator + \"answers\" + kSeparator + \"q9.out\");\n  std::ifstream ifs(path);\n  std::string line;\n\n  bool valid = true;\n\n  if (!ifs.is_open()) {\n    std::cout << \"Failed to open \" << path << \"\\n\";\n    return false;\n  }\n\n  // do nothing with the first line, it is a header line\n  std::getline(ifs, line);\n\n  while (std::getline(ifs, line)) {\n    // split row into column strings by separator ('|')\n    std::vector<std::string> column_data = SplitRowStr(line);\n    assert(column_data.size() == 3);\n\n    std::string nationname_gold = column_data[0];\n    trim(nationname_gold);\n    transform(nationname_gold.begin(), nationname_gold.end(),\n              nationname_gold.begin(), ::toupper);\n\n    assert(n.name_key_map.find(nationname_gold) != n.name_key_map.end());\n\n    unsigned char nationkey_gold = n.name_key_map[nationname_gold];\n\n    unsigned int year_gold = std::stoi(column_data[1]);\n    double sum_profit_gold = std::stod(column_data[2]);\n\n    double sum_profit_res =\n        (double)(sum_profit[year_gold * 25 + nationkey_gold]) / (100.0 * 100.0);\n\n    if (!AlmostEqual(sum_profit_gold, sum_profit_res, 0.01f)) {\n      std::cerr << \"ERROR: sum_profit for \" << nationname_gold << \" in \"\n                << year_gold << \" did not match (Expected=\" << sum_profit_gold\n                << \", Result=\" << sum_profit_res << \")\\n\";\n      valid = false;\n    }\n  }\n\n  return valid;\n}\n\n//\n// validate the results of Query 11\n//\nbool Database::ValidateQ11(std::string db_root_dir,\n                           std::vector<DBIdentifier>& partkeys,\n                           std::vector<DBDecimal>& partkey_values) {\n  std::cout << \"Validating query 11 test results\" << std::endl;\n\n  // populate date row by row (as presented in the file)\n  std::string path(db_root_dir + kSeparator + \"answers\" + kSeparator + \"q11.out\");\n  std::ifstream ifs(path);\n  std::string line;\n  size_t i = 0;\n\n  if (!ifs.is_open()) {\n    std::cout << \"Failed to open \" << path << \"\\n\";\n    return false;\n  }\n\n  bool valid = true;\n\n  // do nothing with the first line, it is a header line\n  std::getline(ifs, line);\n\n  while (std::getline(ifs, line)) {\n    // split row into column strings by separator ('|')\n    std::vector<std::string> column_data = SplitRowStr(line);\n    assert(column_data.size() == 2);\n    assert(i < kPartTableSize);\n\n    DBIdentifier partkey_gold = std::stoll(column_data[0]);\n    double value_gold = std::stod(column_data[1]);\n\n    DBIdentifier partkey_res = partkeys[i];\n    double value_res = (double)(partkey_values[i]) / (100.00);\n\n    if (partkey_gold != partkey_res) {\n      std::cerr << \"ERROR: partkeys at index \" << i << \" do not match \"\n                << \"(Expected=\" << partkey_gold << \", Result=\" << partkey_res\n                << \")\\n\";\n      valid = false;\n    }\n\n    if (!AlmostEqual(value_gold, value_res, 0.01f)) {\n      std::cerr << \"ERROR: value at index \" << i << \" do not match \"\n                << \"(Expected=\" << value_gold << \", Result=\" << value_res\n                << \")\\n\";\n      valid = false;\n    }\n\n    i++;\n  }\n\n  assert(i > 0);\n\n  return valid;\n}\n\n//\n// validate the results of Query 12\n//\nbool Database::ValidateQ12(std::string db_root_dir,\n                           std::array<DBDecimal, 2> high_line_count,\n                           std::array<DBDecimal, 2> low_line_count) {\n  std::cout << \"Validating query 12 test results\" << std::endl;\n\n  // populate date row by row (as presented in the file)\n  std::string path(db_root_dir + kSeparator + \"answers\" + kSeparator + \"q12.out\");\n  std::ifstream ifs(path);\n  std::vector<std::string> column_data;\n  std::string line;\n\n  bool valid = true;\n\n  if (!ifs.is_open()) {\n    std::cout << \"Failed to open \" << path << \"\\n\";\n    return false;\n  }\n\n  // do nothing with the first line, it is a header line\n  std::getline(ifs, line);\n\n  // MAIL shipmode\n  std::getline(ifs, line);\n  column_data = SplitRowStr(line);\n  assert(column_data.size() == 3);\n\n  DBDecimal mail_high_count_gold = std::stoll(column_data[1]);\n  DBDecimal mail_low_count_gold = std::stoll(column_data[2]);\n\n  if (mail_high_count_gold != high_line_count[0]) {\n    std::cerr << \"ERROR: MAIL high_count (Expected=\" << mail_high_count_gold\n              << \", Result=\" << high_line_count[0] << \")\\n\";\n    valid = false;\n  }\n  if (mail_low_count_gold != low_line_count[0]) {\n    std::cerr << \"ERROR: MAIL low_count (Expected=\" << mail_low_count_gold\n              << \", Result=\" << low_line_count[0] << \")\\n\";\n    valid = false;\n  }\n\n  // SHIP shipmode\n  std::getline(ifs, line);\n  column_data = SplitRowStr(line);\n  assert(column_data.size() == 3);\n\n  DBDecimal ship_high_count_gold = std::stoll(column_data[1]);\n  DBDecimal ship_low_count_gold = std::stoll(column_data[2]);\n\n  if (ship_high_count_gold != high_line_count[1]) {\n    std::cerr << \"ERROR: SHIP high_count (Expected=\" << ship_high_count_gold\n              << \", Result=\" << high_line_count[1] << \")\\n\";\n    valid = false;\n  }\n  if (ship_low_count_gold != low_line_count[1]) {\n    std::cerr << \"ERROR: SHIP low_count (Expected=\" << ship_low_count_gold\n              << \", Result=\" << low_line_count[1] << \")\\n\";\n    valid = false;\n  }\n\n  return valid;\n}\n\n//\n// print the results of Query 1\n//\nvoid Database::PrintQ1(std::array<DBDecimal, 3 * 2>& sum_qty,\n                       std::array<DBDecimal, 3 * 2>& sum_base_price,\n                       std::array<DBDecimal, 3 * 2>& sum_disc_price,\n                       std::array<DBDecimal, 3 * 2>& sum_charge,\n                       std::array<DBDecimal, 3 * 2>& avg_qty,\n                       std::array<DBDecimal, 3 * 2>& avg_price,\n                       std::array<DBDecimal, 3 * 2>& avg_discount,\n                       std::array<DBDecimal, 3 * 2>& count) {\n  // line status (ls) and return flag (rf)\n  const std::array<char, 2> ls = {'O', 'F'};\n  const std::array<char, 3> rf = {'R', 'A', 'N'};\n\n  // print the header\n  std::cout << \"l|l|sum_qty|sum_base_price|sum_disc_price|\"\n               \"sum_charge|avg_qty|avg_price|avg_disc|count_order\\n\";\n\n  // Copy old state of cout\n  std::ios oldState(nullptr);\n  oldState.copyfmt(std::cout);\n\n  // Edit the output format of cout\n  std::cout << std::fixed << std::setprecision(2);\n\n  // print the results\n  for (int ls_idx = 0; ls_idx < 2; ls_idx++) {\n    for (int rf_idx = 0; rf_idx < 3; rf_idx++) {\n      int i = ls_idx * 3 + rf_idx;\n      std::cout << rf[rf_idx] << \"|\" << ls[ls_idx] << \"|\" << sum_qty[i] << \"|\"\n                << (double)(sum_base_price[i]) / 100.0 << \"|\"\n                << (double)(sum_disc_price[i]) / (100.00 * 100.00) << \"|\"\n                << (double)(sum_charge[i]) / (100.00 * 100.00 * 100.00) << \"|\"\n                << avg_qty[i] << \"|\" << (double)(avg_price[i]) / 100.0 << \"|\"\n                << (double)(avg_discount[i]) / 100.0 << \"|\" << count[i] << \"\\n\";\n    }\n  }\n\n  // Restore the output format of cout\n  std::cout.copyfmt(oldState);\n}\n\n//\n// print the results of Query 9\n//\nvoid Database::PrintQ9(std::array<DBDecimal, 25 * 2020>& sum_profit) {\n  // row of Q9 output for local sorting\n  struct Row {\n    Row(std::string& nation, int year, DBDecimal sum_profit)\n        : nation(nation), year(year), sum_profit(sum_profit) {}\n    std::string nation;\n    int year;\n    DBDecimal sum_profit;\n\n    void print() {\n      std::cout << nation << \"|\" << year << \"|\"\n                << (double)(sum_profit) / (100.0 * 100.0) << \"\\n\";\n    }\n  };\n\n  // create the rows\n  std::vector<Row> outrows;\n  for (unsigned char nat = 0; nat < kNationTableSize; nat++) {\n    std::string nation_name = n.key_name_map[nat];\n    for (int y = 1992; y <= 1998; y++) {\n      outrows.push_back(Row(nation_name, y, sum_profit[y * 25 + nat]));\n    }\n  }\n\n  // sort rows by year\n  std::sort(outrows.begin(), outrows.end(),\n    [](const Row& a, const Row& b) -> bool {\n      return a.year > b.year;\n  });\n\n  // sort rows by nation\n  // stable_sort() preserves the order of the previous sort\n  std::stable_sort(outrows.begin(), outrows.end(),\n    [](const Row& a, const Row& b) -> bool {\n      return a.nation < b.nation;\n  });\n\n  // print the header\n  std::cout << \"nation|o_year|sum_profit\\n\";\n\n  // Copy old state of cout\n  std::ios oldState(nullptr);\n  oldState.copyfmt(std::cout);\n\n  // Edit the output format of cout\n  std::cout << std::fixed << std::setprecision(2);\n\n  // print the results\n  for (int i = 0; i < outrows.size(); i++) {\n    outrows[i].print();\n  }\n\n  // Restore the output format of cout\n  std::cout.copyfmt(oldState);\n\n}\n\n//\n// print the results of Query 11\n//\nvoid Database::PrintQ11(std::vector<DBIdentifier>& partkeys,\n                        std::vector<DBDecimal>& partkey_values) {\n  // print the header\n  std::cout << \"ps_partkey|value\\n\";\n\n  // Copy old state of cout\n  std::ios oldState(nullptr);\n  oldState.copyfmt(std::cout);\n\n  // Edit the output format of cout\n  std::cout << std::fixed << std::setprecision(2);\n\n  // print the results\n  for (int i = 0; i < partkeys.size(); i++) {\n    std::cout << partkeys[i] << \"|\" << (double)(partkey_values[i]) / (100.00)\n              << \"\\n\";\n  }\n\n  // Restore the output format of cout\n  std::cout.copyfmt(oldState);\n\n}\n\n//\n// print the results of Query 12\n//\nvoid Database::PrintQ12(std::string& SM1, std::string& SM2,\n                        std::array<DBDecimal, 2> high_line_count,\n                        std::array<DBDecimal, 2> low_line_count) {\n  // print the header\n  std::cout << \"l_shipmode|high_line_count|low_line_count\\n\";\n\n  // Copy old state of cout\n  std::ios oldState(nullptr);\n  oldState.copyfmt(std::cout);\n\n  // Edit the output format of cout\n  std::cout << std::fixed;\n\n  // print the results\n  std::cout << SM1 << \"|\" << high_line_count[0] << \"|\" << low_line_count[0]\n            << \"\\n\";\n  std::cout << SM2 << \"|\" << high_line_count[1] << \"|\" << low_line_count[1]\n            << \"\\n\";\n\n  // Restore the output format of cout\n  std::cout.copyfmt(oldState);\n\n}"
    },
    {
        "label": "dbdata.hpp",
        "data": "#ifndef __DBDATA_HPP__\n#define __DBDATA_HPP__\n#pragma once\n\n#include <array>\n#include <string>\n#include <type_traits>\n#include <unordered_map>\n#include <vector>\n\n// database types\nusing DBIdentifier = unsigned int;\nusing DBUint = unsigned int;\nusing DBInt = unsigned int;\nusing DBDecimal = long long;\nusing DBDate = unsigned int;\n\n// Set the scale factor\n//\n// The default (and only option) scale factor for\n// emulation is 0.01; a scale factor of 1 for emulation\n// takes far too long.\n//\n// The default scale factor for hardware is 1. However,\n// the SF_SMALL flag allows the hardware design to be compiled\n// with a scale factor of 0.01\n#if defined(FPGA_EMULATOR) || defined(FPGA_SIMULATOR) || defined(SF_SMALL)\nconstexpr float kSF = 0.01f;\n#else\nconstexpr float kSF = 1.0f;\n#endif\n\n// add some padding rows to the end of each table.\n// this avoids having to predicate global memory when the access granularity\n// is not a multiple of the total number of rows.\n// 16 was chosen because it is the largest access granularity\nconstexpr size_t kPaddingRows = 16;\n\n// ensure the selected scale factor is supported\nstatic_assert((kSF == 0.01f || kSF == 1.0f), \"Unsupported Scale Factor (kSF)\");\n\n// table sizes based on the Scale Factor (kSF)\nconstexpr int kPartTableSize = kSF * 200000;\nconstexpr int kPartSupplierTableSize = kSF * 800000;\nconstexpr int kOrdersTableSize = kSF * 1500000;\nconstexpr int kSupplierTableSize = kSF * 10000;\nconstexpr int kCustomerTableSize = kSF * 150000;\n\n// LINEITEM table is not a strict multiple of kSF\nconstexpr int LineItemTableSizeFnc() {\n  if (kSF == 0.01f) {\n    return 60175;\n  } else if (kSF == 1.0f) {\n    return 6001215;\n  } else {\n    return 0;  // error, should be caught by kSF static_assert\n  }\n}\n\nconstexpr int kLineItemTableSize = LineItemTableSizeFnc();\nconstexpr int kNationTableSize = 25;\nconstexpr int kRegionTableSize = 5;\n\nconstexpr int kLineStatusSize = 2;\nconstexpr int kReturnFlagSize = 3;\nconstexpr int kQuery1OutSize = kReturnFlagSize * kLineStatusSize;\n\n// helpers\nDBDate DateFromString(std::string& date_str);\nint ShipmodeStrToInt(std::string& shipmode_str);\n\n// LINEITEM table\nstruct LineItemTable {\n  std::vector<DBIdentifier> orderkey;\n  std::vector<DBIdentifier> partkey;\n  std::vector<DBIdentifier> suppkey;\n  std::vector<DBInt> linenumber;\n  std::vector<DBDecimal> quantity;\n  std::vector<DBDecimal> extendedprice;\n  std::vector<DBDecimal> discount;\n  std::vector<DBDecimal> tax;\n  std::vector<char> returnflag;\n  std::vector<char> linestatus;\n  std::vector<DBDate> shipdate;\n  std::vector<DBDate> commitdate;\n  std::vector<DBDate> receiptdate;\n  std::vector<char> shipinstruct;\n  std::vector<int> shipmode;\n  std::vector<char> comment;\n\n  size_t rows;\n};\n\n// ORDERS table\nstruct OrdersTable {\n  std::vector<DBIdentifier> orderkey;\n  std::vector<DBIdentifier> custkey;\n  std::vector<char> orderstatus;\n  std::vector<DBDecimal> totalprice;\n  std::vector<DBDate> orderdate;\n  std::vector<int> orderpriority;\n  std::vector<char> clerk;\n  std::vector<int> shippriority;\n  std::vector<char> comment;\n\n  size_t rows;\n};\n\n// PARTS table\nstruct PartsTable {\n  std::vector<DBIdentifier> partkey;\n  std::vector<char> name;\n  std::vector<char> mfgr;\n  std::vector<char> brand;\n  std::vector<char> type;\n  std::vector<int> size;\n  std::vector<char> container;\n  std::vector<DBDecimal> retailprice;\n  std::vector<char> comment;\n\n  size_t rows;\n};\n\n// SUPPLIER table\nstruct SupplierTable {\n  std::vector<DBIdentifier> suppkey;\n  std::vector<char> name;\n  std::vector<char> address;\n  std::vector<unsigned char> nationkey;\n  std::vector<char> phone;\n  std::vector<DBDecimal> acctbal;\n  std::vector<char> comment;\n\n  size_t rows;\n};\n\n// PARTSUPP table\nstruct PartSupplierTable {\n  std::vector<DBIdentifier> partkey;\n  std::vector<DBIdentifier> suppkey;\n  std::vector<int> availqty;\n  std::vector<DBDecimal> supplycost;\n  std::vector<char> comment;\n\n  size_t rows;\n};\n\n// NATION table\nstruct NationTable {\n  std::vector<DBIdentifier> nationkey;\n  std::vector<char> name;\n  std::vector<DBIdentifier> regionkey;\n  std::vector<char> comment;\n\n  std::unordered_map<std::string, unsigned char> name_key_map;\n  std::array<std::string, kNationTableSize> key_name_map;\n  size_t rows;\n};\n\n// the database\nstruct Database {\n  LineItemTable l;\n  OrdersTable o;\n  PartsTable p;\n  SupplierTable s;\n  PartSupplierTable ps;\n  NationTable n;\n\n  bool Parse(std::string db_root_dir);\n\n  // validation functions\n  bool ValidateSF();\n\n  bool ValidateQ1(std::string db_root_dir,\n                  std::array<DBDecimal, 3 * 2>& sum_qty,\n                  std::array<DBDecimal, 3 * 2>& sum_base_price,\n                  std::array<DBDecimal, 3 * 2>& sum_disc_price,\n                  std::array<DBDecimal, 3 * 2>& sum_charge,\n                  std::array<DBDecimal, 3 * 2>& avg_qty,\n                  std::array<DBDecimal, 3 * 2>& avg_price,\n                  std::array<DBDecimal, 3 * 2>& avg_discount,\n                  std::array<DBDecimal, 3 * 2>& count);\n\n  bool ValidateQ9(std::string db_root_dir,\n                  std::array<DBDecimal, 25 * 2020>& sum_profit);\n\n  bool ValidateQ11(std::string db_root_dir, std::vector<DBIdentifier>& partkeys,\n                   std::vector<DBDecimal>& partkey_values);\n\n  bool ValidateQ12(std::string db_root_dir,\n                   std::array<DBDecimal, 2> high_line_count,\n                   std::array<DBDecimal, 2> low_line_count);\n\n  // print functions\n  void PrintQ1(std::array<DBDecimal, 3 * 2>& sum_qty,\n               std::array<DBDecimal, 3 * 2>& sum_base_price,\n               std::array<DBDecimal, 3 * 2>& sum_disc_price,\n               std::array<DBDecimal, 3 * 2>& sum_charge,\n               std::array<DBDecimal, 3 * 2>& avg_qty,\n               std::array<DBDecimal, 3 * 2>& avg_price,\n               std::array<DBDecimal, 3 * 2>& avg_discount,\n               std::array<DBDecimal, 3 * 2>& count);\n\n  void PrintQ9(std::array<DBDecimal, 25 * 2020>& sum_profit);\n\n  void PrintQ11(std::vector<DBIdentifier>& partkeys,\n                std::vector<DBDecimal>& partkey_values);\n\n  void PrintQ12(std::string& SM1, std::string& SM2,\n                std::array<DBDecimal, 2> high_line_count,\n                std::array<DBDecimal, 2> low_line_count);\n\n private:\n  bool ParseLineItemTable(std::string f, LineItemTable& tbl);\n  bool ParseOrdersTable(std::string f, OrdersTable& tbl);\n  bool ParsePartsTable(std::string f, PartsTable& tbl);\n  bool ParseSupplierTable(std::string f, SupplierTable& tbl);\n  bool ParsePartSupplierTable(std::string f, PartSupplierTable& tbl);\n  bool ParseNationTable(std::string f, NationTable& tbl);\n};\n\n#endif /* __DBDATA_HPP__ */\n"
    },
    {
        "label": "query11_kernel.cpp",
        "data": "#include <stdio.h>\n\n#include <type_traits>\n\n#include \"query11_kernel.hpp\"\n#include \"pipe_types.hpp\"\n#include \"../db_utils/CachedMemory.hpp\"\n#include \"../db_utils/MapJoin.hpp\"\n#include \"../db_utils/Misc.hpp\"\n#include \"../db_utils/Tuple.hpp\"\n#include \"../db_utils/Unroller.hpp\"\n#include \"../db_utils/fifo_sort.hpp\"\n\n#include \"onchip_memory_with_cache.hpp\" // DirectProgramming/C++SYCL_FPGA/include\n\nusing namespace std::chrono;\n\n// kernel class names\nclass ProducePartSupplier;\nclass JoinPartSupplierParts;\nclass Compute;\nclass FifoSort;\nclass ConsumeSort;\n\n///////////////////////////////////////////////////////////////////////////////\n// sort configuration\nusing SortType = OutputData;\nconstexpr int kNumSortStages = CeilLog2(kPartTableSize);\nconstexpr int kSortSize = Pow2(kNumSortStages);\n\nstatic_assert(kPartTableSize <= kSortSize,\n              \"Must be able to sort all part keys\");\n\n// comparator for the sorter to sort in descending order\nstruct GreaterThan {\n  inline bool operator()(const SortType& a, const SortType& b) {\n    return a.partvalue > b.partvalue;\n  }\n};\n\n// input and output pipes for the sorter\nusing SortInPipe = pipe<class SortInputPipe, SortType>;\nusing SortOutPipe = pipe<class SortOutputPipe, SortType>;\n///////////////////////////////////////////////////////////////////////////////\n\nbool SubmitQuery11(queue& q, Database& dbinfo, std::string& nation,\n                    std::vector<DBIdentifier>& partkeys,\n                    std::vector<DBDecimal>& values,\n                    double& kernel_latency, double& total_latency) {\n  // find the nationkey based on the nation name\n  assert(dbinfo.n.name_key_map.find(nation) != dbinfo.n.name_key_map.end());\n  unsigned char nationkey = dbinfo.n.name_key_map[nation];\n\n  // ensure correctly sized output buffers\n  partkeys.resize(kPartTableSize);\n  values.resize(kPartTableSize);\n\n  // create space for the input buffers\n  // SUPPLIER\n  buffer s_nationkey_buf(dbinfo.s.nationkey);\n  \n  // PARTSUPPLIER\n  buffer ps_partkey_buf(dbinfo.ps.partkey);\n  buffer ps_suppkey_buf(dbinfo.ps.suppkey);\n  buffer ps_availqty_buf(dbinfo.ps.availqty);\n  buffer ps_supplycost_buf(dbinfo.ps.supplycost);\n\n  // setup the output buffers\n  buffer partkeys_buf(partkeys);\n  buffer values_buf(values);\n\n  // number of producing iterations depends on the number of elements per cycle\n  const size_t ps_rows = dbinfo.ps.rows;\n  const size_t ps_iters = (ps_rows + kJoinWinSize - 1) / kJoinWinSize;\n\n  // start timer\n  high_resolution_clock::time_point host_start = high_resolution_clock::now();\n\n  ///////////////////////////////////////////////////////////////////////////\n  //// JoinPartSupplierParts Kernel\n  auto join_event = q.submit([&](handler& h) {\n    // SUPPLIER table accessors\n    size_t s_rows = dbinfo.s.rows;\n    accessor s_nationkey_accessor(s_nationkey_buf, h, read_only);\n\n    h.single_task<JoinPartSupplierParts>([=]() [[intel::kernel_args_restrict]] {\n      // initialize the array map\n      // +1 is to account for fact that SUPPKEY is [1,kSF*10000]\n      unsigned char nation_key_map_data[kSupplierTableSize + 1];\n      bool nation_key_map_valid[kSupplierTableSize + 1];\n      for (int i = 0; i < kSupplierTableSize + 1; i++) {\n        nation_key_map_valid[i] = false;\n      }\n\n      // populate MapJoiner map\n      // why a map? keys may not be sequential\n      [[intel::initiation_interval(1)]]\n      for (size_t i = 0; i < s_rows; i++) {\n        // NOTE: based on TPCH docs, SUPPKEY is guaranteed to be unique\n        // in the range [1:kSF*10000]\n        DBIdentifier s_suppkey = i + 1;\n        unsigned char s_nationkey = s_nationkey_accessor[i];\n        \n        nation_key_map_data[s_suppkey] = s_nationkey;\n        nation_key_map_valid[s_suppkey] = true;\n      }\n\n      // MAPJOIN PARTSUPPLIER and SUPPLIER tables by suppkey\n      MapJoin<unsigned char, ProducePartSupplierPipe, PartSupplierRow,\n              kJoinWinSize, PartSupplierPartsPipe,\n              SupplierPartSupplierJoined>(nation_key_map_data,\n                                          nation_key_map_valid);\n      \n      // tell downstream we are done\n      PartSupplierPartsPipe::write(\n          SupplierPartSupplierJoinedPipeData(true,false));\n    });\n  });\n  ///////////////////////////////////////////////////////////////////////////\n\n  ///////////////////////////////////////////////////////////////////////////\n  //// Compute Kernel\n  auto compute_event = q.single_task<Compute>([=] {\n    constexpr int kAccumCacheSize = 15;\n    fpga_tools::OnchipMemoryWithCache<DBDecimal, kPartTableSize, \n                                      kAccumCacheSize> partkey_values;\n\n    // initialize accumulator\n    partkey_values.init(0);\n\n    bool done = false;\n\n    [[intel::initiation_interval(1)]]\n    while (!done) {\n      bool valid_pipe_read;\n      SupplierPartSupplierJoinedPipeData pipe_data = \n          PartSupplierPartsPipe::read(valid_pipe_read);\n\n      done = pipe_data.done && valid_pipe_read;\n\n      if (valid_pipe_read && !done) {\n        UnrolledLoop<0, kJoinWinSize>([&](auto j) {\n          SupplierPartSupplierJoined data = pipe_data.data.template get<j>();\n\n          if (data.valid && data.nationkey == nationkey) {\n            // partkeys start at 1\n            DBIdentifier index = data.partkey - 1;\n            DBDecimal val = data.supplycost * (DBDecimal)(data.availqty);\n            auto curr_val = partkey_values.read(index);\n            partkey_values.write(index, curr_val + val);\n          }\n        });\n      }\n    }\n\n    // sort the {partkey, partvalue} pairs based on partvalue.\n    // we will send in kSortSize - kPartTableSize dummy values with a\n    // minimum value so that they are last (sorting from highest to lowest)\n    [[intel::initiation_interval(1)]]\n    for (size_t i = 0; i < kSortSize; i++) {\n      size_t key = (i < kPartTableSize) ? (i + 1) : 0;\n      auto val = (i < kPartTableSize) ? partkey_values.read(i)\n                                      : std::numeric_limits<DBDecimal>::min();\n      SortInPipe::write(OutputData(key, val));\n    }\n  });\n  ///////////////////////////////////////////////////////////////////////////\n\n  ///////////////////////////////////////////////////////////////////////////\n  //// ConsumeSort kernel\n  auto consume_sort_event = q.submit([&](handler& h) {\n    // output buffer accessors\n    accessor partkeys_accessor(partkeys_buf, h, write_only, no_init);\n    accessor values_accessor(values_buf, h, write_only, no_init);\n\n    h.single_task<ConsumeSort>([=]() [[intel::kernel_args_restrict]] {\n      int i = 0;\n      bool i_in_range = 0 < kSortSize;\n      bool i_next_in_range = 1 < kSortSize;\n      bool i_in_parttable_range = 0 < kPartTableSize;\n      bool i_next_in_parttable_range = 1 < kPartTableSize;\n\n      // grab all kSortSize elements from the sorter\n      [[intel::initiation_interval(1)]]\n      while (i_in_range) {\n        bool pipe_read_valid;\n        OutputData D = SortOutPipe::read(pipe_read_valid);\n\n        if (pipe_read_valid) {\n          if (i_in_parttable_range) {\n            partkeys_accessor[i] = D.partkey;\n            values_accessor[i] = D.partvalue;\n          }\n\n          i_in_range = i_next_in_range;\n          i_next_in_range = i < kSortSize - 2;\n          i_in_parttable_range = i_next_in_parttable_range;\n          i_next_in_parttable_range = i < kPartTableSize - 2;\n          i++;\n        }\n      }\n    });\n  });\n  ///////////////////////////////////////////////////////////////////////////\n\n  ///////////////////////////////////////////////////////////////////////////\n  //// FifoSort Kernel\n  auto sort_event = q.single_task<FifoSort>([=] {\n    ihc::sort<SortType, kSortSize, SortInPipe, SortOutPipe>(GreaterThan());\n  });\n  ///////////////////////////////////////////////////////////////////////////\n\n  // Must be last to ensure reliable timings\n  ///////////////////////////////////////////////////////////////////////////\n  //// ProducePartSupplier Kernel\n  auto produce_ps_event = q.submit([&](handler& h) {\n    // PARTSUPPLIER table accessors\n    accessor ps_partkey_accessor(ps_partkey_buf, h, read_only);\n    accessor ps_suppkey_accessor(ps_suppkey_buf, h, read_only);\n    accessor ps_availqty_accessor(ps_availqty_buf, h, read_only);\n    accessor ps_supplycost_accessor(ps_supplycost_buf, h, read_only);\n\n    // kernel to produce the PARTSUPPLIER table\n    h.single_task<ProducePartSupplier>([=]() [[intel::kernel_args_restrict]] {\n      [[intel::initiation_interval(1)]]\n      for (size_t i = 0; i < ps_iters; i++) {\n        // bulk read of data from global memory\n        NTuple<kJoinWinSize, PartSupplierRow> data;\n\n        UnrolledLoop<0, kJoinWinSize>([&](auto j) {\n          size_t idx = i * kJoinWinSize + j;\n          bool in_range = idx < ps_rows;\n\n          DBIdentifier partkey = ps_partkey_accessor[idx];\n          DBIdentifier suppkey = ps_suppkey_accessor[idx];\n          int availqty = ps_availqty_accessor[idx];\n          DBDecimal supplycost = ps_supplycost_accessor[idx];\n\n          data.get<j>() =\n              PartSupplierRow(in_range, partkey, suppkey, availqty, supplycost);\n        });\n\n        // write to pipe\n        ProducePartSupplierPipe::write(\n            PartSupplierRowPipeData(false, true, data));\n      }\n\n      // tell the downstream kernel we are done producing data\n      ProducePartSupplierPipe::write(PartSupplierRowPipeData(true, false));\n    });\n  });\n  ///////////////////////////////////////////////////////////////////////////\n\n  // wait for kernels to finish\n  produce_ps_event.wait();\n  join_event.wait();\n  compute_event.wait();\n  sort_event.wait();\n  consume_sort_event.wait();\n\n  high_resolution_clock::time_point host_end = high_resolution_clock::now();\n  duration<double, std::milli> diff = host_end - host_start;\n\n  // gather profiling info from start of pipeline to end\n  auto start_time =\n      produce_ps_event\n          .get_profiling_info<info::event_profiling::command_start>();\n  auto end_time = consume_sort_event\n          .get_profiling_info<info::event_profiling::command_end>();\n\n  // calculating the kernel execution time in ms\n  auto kernel_execution_time = (end_time - start_time) * 1e-6;\n\n  kernel_latency = kernel_execution_time;\n  total_latency = diff.count();\n\n  return true;\n}\n"
    },
    {
        "label": "query11_kernel.hpp",
        "data": "#ifndef __QUERY11_KERNEL_HPP__\n#define __QUERY11_KERNEL_HPP__\n#pragma once\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"../dbdata.hpp\"\n\nusing namespace sycl;\n\nbool SubmitQuery11(queue& q, Database& dbinfo,\n                   std::string& nation,\n                   std::vector<DBIdentifier>& partkeys,\n                   std::vector<DBDecimal>& values,\n                   double& kernel_latency, double& total_latency);\n\n#endif  //__QUERY11_KERNEL_HPP__\n"
    },
    {
        "label": "query1_kernel.cpp",
        "data": "#include <stdio.h>\n\n#include \"query1_kernel.hpp\"\n\n#include \"../db_utils/Accumulator.hpp\"\n#include \"../db_utils/Tuple.hpp\"\n#include \"../db_utils/Unroller.hpp\"\n\nusing namespace std::chrono;\n\n// how many elements to compute per cycle\n#if defined(FPGA_SIMULATOR)\nconstexpr int kElementsPerCycle = 2;\n#else\nconstexpr int kElementsPerCycle = 12;\n#endif\n\n// the kernel name\nclass Query1;\n\nbool SubmitQuery1(queue& q, Database& dbinfo, DBDate low_date,\n                  std::array<DBDecimal, kQuery1OutSize>& sum_qty,\n                  std::array<DBDecimal, kQuery1OutSize>& sum_base_price,\n                  std::array<DBDecimal, kQuery1OutSize>& sum_disc_price,\n                  std::array<DBDecimal, kQuery1OutSize>& sum_charge,\n                  std::array<DBDecimal, kQuery1OutSize>& avg_qty,\n                  std::array<DBDecimal, kQuery1OutSize>& avg_price,\n                  std::array<DBDecimal, kQuery1OutSize>& avg_discount,\n                  std::array<DBDecimal, kQuery1OutSize>& count,\n                  double& kernel_latency, double& total_latency) {\n  // create space for input buffers\n  buffer quantity_buf(dbinfo.l.quantity);\n  buffer extendedprice_buf(dbinfo.l.extendedprice);\n  buffer discount_buf(dbinfo.l.discount);\n  buffer tax_buf(dbinfo.l.tax);\n  buffer returnflag_buf(dbinfo.l.returnflag);\n  buffer linestatus_buf(dbinfo.l.linestatus);\n  buffer shipdate_buf(dbinfo.l.shipdate);\n\n  // setup the output buffers\n  buffer sum_qty_buf(sum_qty);\n  buffer sum_base_price_buf(sum_base_price);\n  buffer sum_disc_price_buf(sum_disc_price);\n  buffer sum_charge_buf(sum_charge);\n  buffer avg_qty_buf(avg_qty);\n  buffer avg_price_buf(avg_price);\n  buffer avg_discount_buf(avg_discount);\n  buffer count_buf(count);\n\n  const int rows = dbinfo.l.rows; \n  const size_t iters = (rows + kElementsPerCycle - 1) / kElementsPerCycle;\n\n  // start timer\n  high_resolution_clock::time_point host_start = high_resolution_clock::now();\n\n  /////////////////////////////////////////////////////////////////////////////\n  //// Query1 Kernel\n  auto event = q.submit([&](handler& h) {\n    // read accessors\n    accessor quantity_accessor(quantity_buf, h, read_only);\n    accessor extendedprice_accessor(extendedprice_buf, h, read_only);\n    accessor discount_accessor(discount_buf, h, read_only);\n    accessor tax_accessor(tax_buf, h, read_only);\n    accessor returnflag_accessor(returnflag_buf, h, read_only);\n    accessor linestatus_accessor(linestatus_buf, h, read_only);\n    accessor shipdate_accessor(shipdate_buf, h, read_only);\n\n    // write accessors\n    accessor sum_qty_accessor(sum_qty_buf, h, write_only, no_init);\n    accessor sum_base_price_accessor(sum_base_price_buf, h, write_only, no_init);\n    accessor sum_disc_price_accessor(sum_disc_price_buf, h, write_only, no_init);\n    accessor sum_charge_accessor(sum_charge_buf, h, write_only, no_init);\n    accessor avg_qty_accessor(avg_qty_buf, h, write_only, no_init);\n    accessor avg_price_accessor(avg_price_buf, h, write_only, no_init);\n    accessor avg_discount_accessor(avg_discount_buf, h, write_only, no_init);\n    accessor count_accessor(count_buf, h, write_only, no_init);\n\n    h.single_task<Query1>([=]() [[intel::kernel_args_restrict]] {\n      // local accumulation buffers\n      RegisterAccumulator<DBDecimal, 6, unsigned char> sum_qty_local;\n      RegisterAccumulator<DBDecimal, 6, unsigned char> sum_base_price_local;\n      RegisterAccumulator<DBDecimal, 6, unsigned char> sum_disc_price_local;\n      RegisterAccumulator<DBDecimal, 6, unsigned char> sum_charge_local;\n      RegisterAccumulator<DBDecimal, 6, unsigned char> avg_discount_local;\n      RegisterAccumulator<DBDecimal, 6, unsigned char> count_local;\n\n      // initialize the accumulators\n      sum_qty_local.Init();\n      sum_base_price_local.Init();\n      sum_disc_price_local.Init();\n      sum_charge_local.Init();\n      avg_discount_local.Init();\n      count_local.Init();\n\n      // stream each row in the DB (kElementsPerCycle rows at a time)\n      [[intel::initiation_interval(1)]]\n      for (size_t r = 0; r < iters; r++) {\n        // locals\n        DBDecimal qty[kElementsPerCycle];\n        DBDecimal extendedprice[kElementsPerCycle];\n        DBDecimal discount[kElementsPerCycle];\n        DBDecimal tax[kElementsPerCycle];\n        DBDecimal disc_price_tmp[kElementsPerCycle];\n        DBDecimal charge_tmp[kElementsPerCycle];\n        DBDecimal count_tmp[kElementsPerCycle];\n        unsigned char out_idx[kElementsPerCycle];\n        bool row_valid[kElementsPerCycle];\n\n        // multiple elements per cycle\n#pragma unroll\n        for (size_t p = 0; p < kElementsPerCycle; ++p) {\n          // is data in range of the table\n          // (data size may not be divisible by kElementsPerCycle)\n          size_t idx = r * kElementsPerCycle + p;\n          bool in_range = idx < rows;\n\n          // get this rows shipdate\n          DBDate shipdate = shipdate_accessor[idx];\n\n          // determine if the row is valid\n          row_valid[p] = in_range && (shipdate <= low_date);\n\n          // read or set values based on the validity of the data\n          qty[p] = quantity_accessor[idx];\n          extendedprice[p] = extendedprice_accessor[idx];\n          discount[p] = discount_accessor[idx];\n          tax[p] = tax_accessor[idx];\n          char rf = returnflag_accessor[idx];\n          char ls = linestatus_accessor[idx];\n          count_tmp[p] = 1;\n\n          // convert returnflag and linestatus into an index\n          unsigned char rf_idx;\n          if (rf == 'R') {\n            rf_idx = 0;\n          } else if (rf == 'A') {\n            rf_idx = 1;\n          } else {  // == 'N'\n            rf_idx = 2;\n          }\n          unsigned char ls_idx;\n          if (ls == 'O') {\n            ls_idx = 0;\n          } else {  // == 'F'\n            ls_idx = 1;\n          }\n          out_idx[p] = ls_idx * kReturnFlagSize + rf_idx;\n\n          // intermediate calculations\n          disc_price_tmp[p] = extendedprice[p] * (100 - discount[p]);\n          charge_tmp[p] =\n              extendedprice[p] * (100 - discount[p]) * (100 + tax[p]);\n        }\n\n        // reduction accumulation\n#pragma unroll\n        for (size_t p = 0; p < kElementsPerCycle; ++p) {\n          sum_qty_local.Accumulate(out_idx[p],\n                                   row_valid[p] ? qty[p] : 0);\n          sum_base_price_local.Accumulate(out_idx[p],\n                                          row_valid[p] ? extendedprice[p] : 0);\n          sum_disc_price_local.Accumulate(out_idx[p],\n                                          row_valid[p] ? disc_price_tmp[p] : 0);\n          sum_charge_local.Accumulate(out_idx[p],\n                                      row_valid[p] ? charge_tmp[p] : 0);\n          count_local.Accumulate(out_idx[p],\n                                 row_valid[p] ? count_tmp[p] : 0);\n          avg_discount_local.Accumulate(out_idx[p],\n                                        row_valid[p] ? discount[p] : 0);\n        }\n      }\n\n// perform averages and push back to global memory\n#pragma unroll\n      for (size_t i = 0; i < kQuery1OutSize; i++) {\n        DBDecimal count = count_local.Get(i);\n\n        sum_qty_accessor[i] = sum_qty_local.Get(i);\n        sum_base_price_accessor[i] = sum_base_price_local.Get(i);\n        sum_disc_price_accessor[i] = sum_disc_price_local.Get(i);\n        sum_charge_accessor[i] = sum_charge_local.Get(i);\n\n        avg_qty_accessor[i] = (count == 0) ? 0 : (sum_qty_local.Get(i) / count);\n        avg_price_accessor[i] =\n            (count == 0) ? 0 : (sum_base_price_local.Get(i) / count);\n        avg_discount_accessor[i] =\n            (count == 0) ? 0 : (avg_discount_local.Get(i) / count);\n\n        count_accessor[i] = count;\n      }\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n  // wait for kernel to finish\n  event.wait();\n\n  high_resolution_clock::time_point host_end = high_resolution_clock::now();\n  duration<double, std::milli> diff = host_end - host_start;\n\n  // gather profiling info\n  auto kernel_start_time =\n      event.get_profiling_info<info::event_profiling::command_start>();\n  auto kernel_end_time =\n      event.get_profiling_info<info::event_profiling::command_end>();\n\n  // calculating the kernel execution time in ms\n  auto kernel_execution_time = (kernel_end_time - kernel_start_time) * 1e-6;\n\n  kernel_latency = kernel_execution_time;\n  total_latency = diff.count();\n\n  return true;\n}\n"
    },
    {
        "label": "query1_kernel.hpp",
        "data": "#ifndef __QUERY1_KERNEL_HPP__\n#define __QUERY1_KERNEL_HPP__\n#pragma once\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"../dbdata.hpp\"\n\nusing namespace sycl;\n\nbool SubmitQuery1(queue& q, Database& dbinfo, DBDate low_date,\n                  std::array<DBDecimal, kQuery1OutSize>& sum_qty,\n                  std::array<DBDecimal, kQuery1OutSize>& sum_base_price,\n                  std::array<DBDecimal, kQuery1OutSize>& sum_disc_price,\n                  std::array<DBDecimal, kQuery1OutSize>& sum_charge,\n                  std::array<DBDecimal, kQuery1OutSize>& avg_qty,\n                  std::array<DBDecimal, kQuery1OutSize>& avg_price,\n                  std::array<DBDecimal, kQuery1OutSize>& avg_discount,\n                  std::array<DBDecimal, kQuery1OutSize>& count,\n                  double& kernel_latency, double& total_latency);\n\n#endif  //__QUERY1_KERNEL_HPP__\n"
    },
    {
        "label": "query9_kernel.cpp",
        "data": "#include <array>\n#include <stdio.h>\n#include <type_traits>\n#include <vector>\n\n#include \"query9_kernel.hpp\"\n#include \"pipe_types.hpp\"\n\n#include \"onchip_memory_with_cache.hpp\" // DirectProgramming/C++SYCL_FPGA/include\n\n#include \"../db_utils/Accumulator.hpp\"\n#include \"../db_utils/LikeRegex.hpp\"\n#include \"../db_utils/MapJoin.hpp\"\n#include \"../db_utils/MergeJoin.hpp\"\n#include \"../db_utils/Misc.hpp\"\n#include \"../db_utils/ShannonIterator.hpp\"\n#include \"../db_utils/Tuple.hpp\"\n#include \"../db_utils/Unroller.hpp\"\n#include \"../db_utils/fifo_sort.hpp\"\n\nusing namespace std::chrono;\n\n//\n// NOTE: See the README file for a diagram of how the different kernels are\n// connected\n//\n\n// kernel class names\nclass ProducerOrders;\nclass FilterParts;\nclass ProducePartSupplier;\nclass JoinPartSupplierSupplier;\nclass JoinLineItemOrders;\nclass FeedSort;\nclass FifoSort;\nclass ConsumeSort;\nclass JoinEverything;\nclass Compute;\n\n/////////////////////////////////////////////////////////////////////////////\n// sort configuration\nusing SortType = SortData;\n\n// need to sort at most 6% of the lineitem table\nconstexpr int kNumSortStages = CeilLog2(kLineItemTableSize * 0.06);\nconstexpr int kSortSize = Pow2(kNumSortStages);\n\nusing SortInPipe = pipe<class SortInputPipe, SortType>;\nusing SortOutPipe = pipe<class SortOutputPipe, SortType>;\n\nstatic_assert(kLineItemTableSize * 0.06 <= kSortSize,\n              \"Must be able to sort all part keys\");\n/////////////////////////////////////////////////////////////////////////////\n\n//\n// Helper function to shuffle the valid values in 'input' into 'output' using\n// the bits template\n// For example, consider this simple case:\n//  input = {7,8}\n//  if bits = 1 (2'b01), then output = {0,7}\n//  if bits = 2 (2'b01), then output = {0,8}\n//  if bits = 3 (2'b01), then output = {7,8}\n//\ntemplate <char bits, int tuple_size, typename TupleType>\nvoid Shuffle(NTuple<tuple_size, TupleType>& input,\n             NTuple<tuple_size, TupleType>& output) {\n  // get number of ones (number of valid entries) in the input\n  constexpr char kNumOnes = CountOnes<char>(bits);\n\n  // static asserts\n  static_assert(tuple_size > 0,\n      \"tuple_size must strictly positive\");\n  static_assert(kNumOnes <= tuple_size,\n      \"Number of valid bits in bits cannot exceed the size of the tuple\");\n\n  // full crossbar to reorder valid entries of 'input'\n  UnrolledLoop<0, kNumOnes>([&](auto i) {\n    constexpr char pos = PositionOfNthOne<char>(i + 1, bits) - 1;\n    output.template get<i>() = input.template get<pos>();\n  });\n}\n\nbool SubmitQuery9(queue& q, Database& dbinfo, std::string colour,\n                  std::array<DBDecimal, 25 * 2020>& sum_profit,\n                  double& kernel_latency, double& total_latency) {\n  // copy the regex string to character array, pad with NULL characters\n  std::array<char, 11> regex_word;\n  for (size_t i = 0; i < 11; i++) {\n    regex_word[i] = (i < colour.size()) ? colour[i] : '\\0';\n  }\n\n  // create space for the input buffers\n  // the REGEX\n  buffer regex_word_buf(regex_word);\n\n  // PARTS\n  buffer p_name_buf(dbinfo.p.name);\n\n  // SUPPLIER\n  buffer s_nationkey_buf(dbinfo.s.nationkey);\n\n  // PARTSUPPLIER\n  buffer ps_partkey_buf(dbinfo.ps.partkey);\n  buffer ps_suppkey_buf(dbinfo.ps.suppkey);\n  buffer ps_supplycost_buf(dbinfo.ps.supplycost);\n\n  // ORDERS\n  buffer o_orderkey_buf(dbinfo.o.orderkey);\n  buffer o_orderdate_buf(dbinfo.o.orderdate);\n\n  // LINEITEM\n  buffer l_orderkey_buf(dbinfo.l.orderkey);\n  buffer l_partkey_buf(dbinfo.l.partkey);\n  buffer l_suppkey_buf(dbinfo.l.suppkey);\n  buffer l_quantity_buf(dbinfo.l.quantity);\n  buffer l_extendedprice_buf(dbinfo.l.extendedprice);\n  buffer l_discount_buf(dbinfo.l.discount);\n\n  // setup the output buffer (the profit for each nation and year)\n  buffer sum_profit_buf(sum_profit);\n\n  // number of producing iterations depends on the number of elements per cycle\n  const size_t l_rows = dbinfo.l.rows;\n  const size_t l_iters =\n      (l_rows + kLineItemJoinWinSize - 1) / kLineItemJoinWinSize;\n  const size_t o_rows = dbinfo.o.rows;\n  const size_t o_iters =\n      (o_rows + kOrdersJoinWinSize - 1) / kOrdersJoinWinSize;\n  const size_t ps_rows = dbinfo.ps.rows;\n  const size_t ps_iters =\n      (ps_rows + kPartSupplierDuplicatePartkeys - 1)\n      / kPartSupplierDuplicatePartkeys;\n  const size_t p_rows = dbinfo.p.rows;\n  const size_t p_iters =\n      (p_rows + kRegexFilterElementsPerCycle - 1)\n      / kRegexFilterElementsPerCycle;\n\n  // start timer\n  high_resolution_clock::time_point host_start = high_resolution_clock::now();\n\n  /////////////////////////////////////////////////////////////////////////////\n  //// FilterParts Kernel:\n  ////    Filter the PARTS table and produce the filtered LINEITEM table\n  auto filter_parts_event = q.submit([&](handler& h) {\n    // REGEX word accessor\n    accessor regex_word_accessor(regex_word_buf, h, read_only);\n\n    // PARTS table accessors\n    accessor p_name_accessor(p_name_buf, h, read_only);\n\n    // LINEITEM table accessors\n    accessor l_orderkey_accessor(l_orderkey_buf, h, read_only);\n    accessor l_partkey_accessor(l_partkey_buf, h, read_only);\n    accessor l_suppkey_accessor(l_suppkey_buf, h, read_only);\n\n    // kernel to filter parts table based on REGEX\n    h.single_task<FilterParts>([=]() [[intel::kernel_args_restrict]] {\n      // a map where the key is the partkey and the value is whether\n      // that partkeys name matches the given regex\n      bool partkeys_matching_regex[kPartTableSize + 1];\n\n      ///////////////////////////////////////////////\n      //// Stage 1\n      // find valid parts with REGEX\n      LikeRegex<11, 55> regex[kRegexFilterElementsPerCycle];\n\n      // initialize regex word\n      for (size_t i = 0; i < 11; i++) {\n        const char c = regex_word_accessor[i];\n#pragma unroll\n        for (size_t re = 0; re < kRegexFilterElementsPerCycle; ++re) {\n          regex[re].word[i] = c;\n        }\n      }\n\n      // stream in rows of PARTS table and check partname against REGEX\n      [[intel::initiation_interval(1), intel::ivdep]]\n      for (size_t i = 0; i < p_iters; i++) {\n#pragma unroll\n        for (size_t re = 0; re < kRegexFilterElementsPerCycle; ++re) {\n          const size_t idx = i * kRegexFilterElementsPerCycle + re;\n          const bool idx_range = idx < p_rows;\n\n          // read in partkey\n          // valid partkeys in range [1,kPartTableSize]\n          const DBIdentifier partkey = idx_range ? idx + 1 : 0;\n\n          // read in regex string\n#pragma unroll\n          for (size_t k = 0; k < 55; ++k) {\n            regex[re].str[k] = p_name_accessor[idx * 55 + k];\n          }\n\n          // run regex matching\n          regex[re].Match();\n\n          // mark valid partkey\n          if (idx_range) {\n            partkeys_matching_regex[partkey] = regex[re].Contains();\n          }\n        }\n      }\n      ///////////////////////////////////////////////\n\n      ///////////////////////////////////////////////\n      //// Stage 2\n      // read in the LINEITEM table (kLineItemJoinWinSize rows at a time)\n      // row is valid if its PARTKEY matched the REGEX\n      [[intel::initiation_interval(1)]]\n      for (size_t i = 0; i < l_iters + 1; i++) {\n        bool done = (i == l_iters);\n        bool valid = (i != l_iters);\n\n        // bulk read of data from global memory\n        NTuple<kLineItemJoinWinSize, LineItemMinimalRow> data;\n\n        UnrolledLoop<0, kLineItemJoinWinSize>([&](auto j) {\n          size_t idx = i * kLineItemJoinWinSize + j;\n          bool in_range = idx < l_rows;\n\n          DBIdentifier orderkey = l_orderkey_accessor[idx];\n          DBIdentifier partkey = l_partkey_accessor[idx];\n          DBIdentifier suppkey = l_suppkey_accessor[idx];\n\n          bool matches_partkey_name_regex = partkeys_matching_regex[partkey];\n          bool data_is_valid = in_range && matches_partkey_name_regex;\n\n          data.get<j>() = LineItemMinimalRow(data_is_valid, idx, orderkey,\n                                             partkey, suppkey);\n        });\n\n        // write to pipe\n        LineItemPipe::write(LineItemMinimalRowPipeData(done, valid, data));\n      }\n      ///////////////////////////////////////////////\n    });\n  });\n  ///////////////////////////////////////////////////////////////////////////\n\n  ///////////////////////////////////////////////////////////////////////////\n  //// ProducerOrders Kernel: produce the ORDERS table\n  auto producer_orders_event = q.submit([&](handler& h) {\n    // ORDERS table accessors\n    accessor o_orderkey_accessor(o_orderkey_buf, h, read_only);\n    accessor o_orderdate_accessor(o_orderdate_buf, h, read_only);\n\n    // produce ORDERS table (kOrdersJoinWinSize rows at a time)\n    h.single_task<ProducerOrders>([=]() [[intel::kernel_args_restrict]] {\n      [[intel::initiation_interval(1)]]\n      for (size_t i = 0; i < o_iters + 1; i++) {\n        bool done = (i == o_iters);\n        bool valid = (i != o_iters);\n\n        // bulk read of data from global memory\n        NTuple<kOrdersJoinWinSize, OrdersRow> data;\n\n        UnrolledLoop<0, kOrdersJoinWinSize>([&](auto j) {\n          size_t idx = i * kOrdersJoinWinSize + j;\n          bool in_range = idx < l_rows;\n\n          DBIdentifier orderkey_tmp = o_orderkey_accessor[idx];\n          DBDate orderdate = o_orderdate_accessor[idx];\n\n          DBIdentifier orderkey =\n            in_range ? orderkey_tmp : std::numeric_limits<DBIdentifier>::max();\n\n          data.get<j>() = OrdersRow(in_range, orderkey, orderdate);\n        });\n\n        // write to pipe\n        OrdersPipe::write(OrdersRowPipeData(done, valid, data));\n      }\n    });\n  });\n  ///////////////////////////////////////////////////////////////////////////\n\n  ///////////////////////////////////////////////////////////////////////////\n  //// JoinLineItemOrders Kernel: join the LINEITEM and ORDERS table\n  auto join_lineitem_orders_event = q.submit([&](handler& h) {\n    // kernel to join LINEITEM and ORDERS table\n    h.single_task<JoinLineItemOrders>([=]() [[intel::kernel_args_restrict]] {\n      // JOIN LINEITEM and ORDERS table\n      MergeJoin<OrdersPipe, OrdersRow, kOrdersJoinWinSize,\n                LineItemPipe, LineItemMinimalRow, kLineItemJoinWinSize,\n                LineItemOrdersPipe, LineItemOrdersMinimalJoined>();\n\n      // join is done, tell downstream\n      LineItemOrdersPipe::write(\n          LineItemOrdersMinimalJoinedPipeData(true, false));\n    });\n  });\n  ///////////////////////////////////////////////////////////////////////////\n\n  ///////////////////////////////////////////////////////////////////////////\n  //// JoinPartSupplierSupplier Kernel: join the PARTSUPPLIER and SUPPLIER tables\n  auto join_partsupplier_supplier_event = q.submit([&](handler& h) {\n    // SUPPLIER table accessors\n    size_t s_rows = dbinfo.s.rows;\n    accessor s_nationkey_accessor(s_nationkey_buf, h, read_only);\n\n    // kernel to join partsupplier and supplier tables\n    h.single_task<JoinPartSupplierSupplier>(\n          [=]() [[intel::kernel_args_restrict]] {\n      // +1 is to account for fact that SUPPKEY is [1,kSF*10000]\n      unsigned char nation_key_map_data[kSupplierTableSize + 1];\n      bool nation_key_map_valid[kSupplierTableSize + 1];\n      for (int i = 0; i < kSupplierTableSize + 1; i++) {\n        nation_key_map_valid[i] = false;\n      }\n\n      ///////////////////////////////////////////////\n      //// Stage 1\n      // populate the array map\n      [[intel::initiation_interval(1)]]\n      for (size_t i = 0; i < s_rows; i++) {\n        // NOTE: based on TPCH docs, SUPPKEY is guaranteed\n        // to be unique in range [1:kSF*10000]\n        DBIdentifier s_suppkey = i + 1;\n        unsigned char s_nationkey = s_nationkey_accessor[i];\n        \n        nation_key_map_data[s_suppkey] = s_nationkey;\n        nation_key_map_valid[s_suppkey] = true;\n      }\n      ///////////////////////////////////////////////\n\n      ///////////////////////////////////////////////\n      //// Stage 2\n      // MAPJOIN PARTSUPPLIER and SUPPLIER tables by suppkey\n      MapJoin<unsigned char, PartSupplierPipe, PartSupplierRow,\n              kPartSupplierDuplicatePartkeys, PartSupplierPartsPipe,\n              SupplierPartSupplierJoined>(nation_key_map_data,\n                                          nation_key_map_valid);\n\n      // tell downstream we are done\n      PartSupplierPartsPipe::write(\n        SupplierPartSupplierJoinedPipeData(true, false));\n      ///////////////////////////////////////////////\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////////////\n  //// ProducePartSupplier Kernel: produce the PARTSUPPLIER table\n  auto produce_part_supplier_event = q.submit([&](handler& h) {\n    // PARTSUPPLIER table accessors\n    accessor ps_partkey_accessor(ps_partkey_buf, h, read_only);\n    accessor ps_suppkey_accessor(ps_suppkey_buf, h, read_only);\n    accessor ps_supplycost_accessor(ps_supplycost_buf, h, read_only);\n\n    // kernel to produce the PARTSUPPLIER table\n    h.single_task<ProducePartSupplier>([=]() [[intel::kernel_args_restrict]] {\n      [[intel::initiation_interval(1)]]\n      for (size_t i = 0; i < ps_iters + 1; i++) {\n        bool done = (i == ps_iters);\n        bool valid = (i != ps_iters);\n\n        // bulk read of data from global memory\n        NTuple<kPartSupplierDuplicatePartkeys, PartSupplierRow> data;\n\n        UnrolledLoop<0, kPartSupplierDuplicatePartkeys>([&](auto j) {\n          size_t idx = i * kPartSupplierDuplicatePartkeys + j;\n          bool in_range = idx < ps_rows;\n          DBIdentifier partkey = ps_partkey_accessor[idx];\n          DBIdentifier suppkey = ps_suppkey_accessor[idx];\n          DBDecimal supplycost = ps_supplycost_accessor[idx];\n\n          data.get<j>() = \n              PartSupplierRow(in_range, partkey, suppkey, supplycost);\n        });\n\n        // write to pipe\n        PartSupplierPipe::write(PartSupplierRowPipeData(done, valid, data));\n      }\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////////////\n  //// Compute Kernel: do the final computation on the data\n  auto computation_kernel_event = q.submit([&](handler& h) {\n    // LINEITEM table accessors\n    accessor l_quantity_accessor(l_quantity_buf, h, read_only);\n    accessor l_extendedprice_accessor(l_extendedprice_buf, h, read_only);\n    accessor l_discount_accessor(l_discount_buf, h, read_only);\n\n    // output accessors\n    accessor sum_profit_accessor(sum_profit_buf, h, write_only, no_init);\n\n    h.single_task<Compute>([=]() [[intel::kernel_args_restrict]] {\n      // the accumulators\n      constexpr int kAccumCacheSize = 8;\n      NTuple<kFinalDataMaxSize, fpga_tools::OnchipMemoryWithCache<\n                                    DBDecimal, (25 * 7), kAccumCacheSize>>\n          sum_profit_local;\n\n      // initialize the accumulators\n      UnrolledLoop<0, kFinalDataMaxSize>([&](auto j) {\n        sum_profit_local.template get<j>().init(0);\n      });\n\n      bool done = false;\n      [[intel::initiation_interval(1)]]\n      do {\n        FinalPipeData pipe_data = FinalPipe::read();\n        done = pipe_data.done;\n\n        const bool pipeDataValid = !pipe_data.done && pipe_data.valid;\n\n        UnrolledLoop<0, kFinalDataMaxSize>([&](auto j) {\n          FinalData D = pipe_data.data.get<j>();\n\n          bool D_valid = pipeDataValid && D.valid;\n          unsigned int D_idx = D.lineitemIdx;\n\n          // grab LINEITEM data from global memory and compute 'amount'\n          DBDecimal quantity=0, extendedprice=0, discount=0, supplycost=0;\n          if(D_valid) {\n            quantity = l_quantity_accessor[D_idx];\n            extendedprice = l_extendedprice_accessor[D_idx];\n            discount = l_discount_accessor[D_idx];\n            supplycost = D.supplycost;\n          }\n\n          // Why quantity x 100? So we can divide 'amount' by 100*100 later\n          DBDecimal amount = (extendedprice * (100 - discount)) -\n                              (supplycost * quantity * 100);\n\n          // compute index based on order year and nation\n          // See Date.hpp\n          unsigned int orderyear = (D.orderdate >> 9) & 0x07FFFFF;\n          unsigned int nation = D.nationkey;\n          unsigned char idx = (orderyear - 1992) * 25 + nation;\n\n          unsigned char idx_final = D_valid ? idx : 0;\n          DBDecimal amount_final = D_valid ? amount : 0;\n\n          auto current_amount = sum_profit_local.template get<j>().read(idx_final);\n          auto computed_amount = current_amount + amount_final;\n          sum_profit_local.template get<j>().write(idx_final, computed_amount);\n        });\n      } while (!done);\n\n      // push back the accumulated data to global memory\n      for (size_t n = 0; n < 25; n++) {\n        for (size_t y = 0; y < 7; y++) {\n          size_t in_idx = y * 25 + n;\n          size_t out_idx = (y + 1992) * 25 + n;\n\n          DBDecimal amount = 0;\n\n          UnrolledLoop<0, kFinalDataMaxSize>([&](auto j) {\n            amount += sum_profit_local.template get<j>().read(in_idx);\n          });\n\n          sum_profit_accessor[out_idx] = amount;\n        }\n      }\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////////////\n  //// FeedSort Kernel: kernel to filter out invalid data and feed the sorter\n  auto feed_sort_event = q.submit([&](handler& h) {\n    h.single_task<FeedSort>([=]() [[intel::kernel_args_restrict]] {\n      bool done = false;\n      size_t num_rows = 0;\n\n      do {\n        // get data from upstream\n        bool valid;\n        LineItemOrdersMinimalJoinedPipeData pipe_data = \n            LineItemOrdersPipe::read(valid);\n        done = pipe_data.done && valid;\n\n        if (!done && valid && pipe_data.valid) {\n          NTuple<kLineItemOrdersJoinWinSize, LineItemOrdersMinimalJoined>\n              shuffle_data;\n          unsigned char valid_count = 0;\n          char valid_bits = 0;\n\n          // convert the 'valid' bits in the tuple to a bitset (valid_bits)\n          UnrolledLoop<0, kLineItemOrdersJoinWinSize>([&](auto i) {\n            constexpr char mask = 1 << i;\n            valid_bits |= pipe_data.data.get<i>().valid ? mask : 0;\n          });\n\n          // full crossbar to do the shuffling from pipe_data to shuffle_data\n          UnrolledLoop<0, Pow2(kLineItemOrdersJoinWinSize)>([&](auto i) {\n            if (valid_bits == i) {\n              Shuffle<i, kLineItemOrdersJoinWinSize,\n                      LineItemOrdersMinimalJoined>(pipe_data.data,\n                                                   shuffle_data);\n              valid_count = CountOnes<char>(i);\n            }\n          });\n\n          // Send the data to sorter.\n          // The idea here is that this loop executes in the range\n          // [0,kLineItemOrdersJoinWinSize] times.\n          // However, we know that at most 6% of the data will match the filter\n          // and go to the sorter. So, that means for every ~16 pieces of\n          // data, we expect <1 will match the filter and go to the sorter.\n          // Therefore, so long as kLineItemOrdersJoinWinSize <= 16\n          // this loop will, on average, execute ONCE per outer loop iteration\n          // (i.e. statistically, valid_count=1 for every 16 pieces of data).\n          // NOTE: for this loop to get good throughput it is VERY important to:\n          //    A) Apply the [[intel::speculated_iterations(0)]] attribute\n          //    B) Explicitly bound the loop iterations\n          // For an explanation why, see the optimize_inner_loops tutorial.\n          [[intel::speculated_iterations(0)]]\n          for (char i = 0; i < valid_count && \n                i < kLineItemOrdersJoinWinSize; i++) {\n            UnrolledLoop<0, kLineItemOrdersJoinWinSize>([&](auto j) {\n              if (j == i) {\n                SortInPipe::write(SortData(shuffle_data.get<j>()));\n              }\n            });\n          }\n          \n          num_rows += valid_count;\n        }\n      } while (!done);\n\n      // send in pad data to ensure we send in exactly kSortSize elements\n      ShannonIterator<int, 3> i(num_rows, kSortSize);\n\n      while (i.InRange()) {\n        SortInPipe::write(\n            SortData(0, std::numeric_limits<DBIdentifier>::max(), 0, 0));\n\n        i.Step();\n      }\n\n      // drain the input pipe\n      while (!done) {\n        bool valid;\n        LineItemOrdersMinimalJoinedPipeData pipe_data = \n            LineItemOrdersPipe::read(valid);\n        done = pipe_data.done && valid;\n      }\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////////////\n  //// ConsumeSort Kernel: consume the output of the sorter\n  auto consume_sort_event = q.submit([&](handler& h) {\n    h.single_task<ConsumeSort>([=]() [[intel::kernel_args_restrict]] {\n      bool done = false;\n      size_t num_rows = 0;\n\n      // read out data from the sorter until 'done' signal from upstream\n      [[intel::initiation_interval(1)]]\n      do {\n        bool valid;\n        SortData in_data = SortOutPipe::read(valid);\n        done = (in_data.partkey == std::numeric_limits<DBIdentifier>::max()) &&\n               valid;\n        num_rows += valid ? 1 : 0;\n\n        if (!done && valid) {\n          NTuple<1, LineItemOrdersMinimalJoined> out_data;\n          out_data.get<0>() = LineItemOrdersMinimalJoined(\n              true, in_data.lineitemIdx, in_data.partkey, in_data.suppkey,\n              in_data.orderdate);\n\n          LineItemOrdersSortedPipe::write(\n              LineItemOrdersMinimalSortedPipeData(false, true, out_data));\n        }\n      } while (!done);\n\n      // tell downstream kernel that the sort is done\n      LineItemOrdersSortedPipe::write(\n          LineItemOrdersMinimalSortedPipeData(true, false));\n\n      // drain the data we don't care about from the sorter\n      ShannonIterator<int, 3> i(num_rows, kSortSize);\n      while (i.InRange()) {\n        bool valid;\n        (void)SortOutPipe::read(valid);\n\n        if (valid) {\n          i.Step();\n        }\n      }\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////////////\n  //// FifoSort Kernel: the sorter\n  auto sort_event = q.submit([&](handler& h) {\n    h.single_task<FifoSort>([=]() [[intel::kernel_args_restrict]] {\n      ihc::sort<SortType, kSortSize, SortInPipe, SortOutPipe>(ihc::LessThan());\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////////////\n  //// JoinEverything Kernel: join the sorted\n  ////    LINEITEM+ORDERS with SUPPLIER+PARTSUPPLIER\n  auto join_li_o_s_ps_event = q.submit([&](handler& h) {\n    h.single_task<JoinEverything>([=]() [[intel::kernel_args_restrict]] {\n      DuplicateMergeJoin<PartSupplierPartsPipe, SupplierPartSupplierJoined,\n                         kPartSupplierDuplicatePartkeys,\n                         LineItemOrdersSortedPipe, LineItemOrdersMinimalJoined,\n                         1, FinalPipe, FinalData>();\n\n      // join is done, tell downstream\n      FinalPipe::write(FinalPipeData(true, false));\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n  // wait for kernel to finish\n  filter_parts_event.wait();\n  computation_kernel_event.wait();\n  join_li_o_s_ps_event.wait();\n  sort_event.wait();\n  consume_sort_event.wait();\n  feed_sort_event.wait();\n  produce_part_supplier_event.wait();\n  join_partsupplier_supplier_event.wait();\n  join_lineitem_orders_event.wait();\n  producer_orders_event.wait();\n\n  high_resolution_clock::time_point host_end = high_resolution_clock::now();\n  duration<double, std::milli> diff = host_end - host_start;\n\n  // gather profiling info\n  auto filter_parts_start =\n      filter_parts_event\n          .get_profiling_info<info::event_profiling::command_start>();\n  auto computation_end =\n      computation_kernel_event\n          .get_profiling_info<info::event_profiling::command_end>();\n\n  // calculating the kernel execution time in ms\n  auto kernel_execution_time = (computation_end - filter_parts_start) * 1e-6;\n\n  kernel_latency = kernel_execution_time;\n  total_latency = diff.count();\n\n  return true;\n}\n"
    },
    {
        "label": "query9_kernel.hpp",
        "data": "#ifndef __QUERY9_KERNEL_HPP__\n#define __QUERY9_KERNEL_HPP__\n#pragma once\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"../dbdata.hpp\"\n\nusing namespace sycl;\n\nbool SubmitQuery9(queue& q, Database& dbinfo,\n                  std::string colour,\n                  std::array<DBDecimal, 25 * 2020>& sum_profit,\n                  double& kernel_latency, double& total_latency);\n\n#endif  //__QUERY9_KERNEL_HPP__\n"
    },
    {
        "label": "query12_kernel.cpp",
        "data": "#include <array>\n#include <limits>\n#include <stdio.h>\n\n#include \"query12_kernel.hpp\"\n#include \"pipe_types.hpp\"\n\n#include \"../db_utils/MergeJoin.hpp\"\n#include \"../db_utils/Unroller.hpp\"\n#include \"../db_utils/Tuple.hpp\"\n\nusing namespace std::chrono;\n\n// kernel class names\nclass LineItemProducer;\nclass OrdersProducer;\nclass Join;\nclass Compute;\nclass StartProduction;\n\nbool SubmitQuery12(queue& q, Database& dbinfo, DBDate low_date,\n                    DBDate high_date, int shipmode1, int shipmode2,\n                    std::array<DBDecimal, 2>& high_line_count,\n                    std::array<DBDecimal, 2>& low_line_count,\n                    double& kernel_latency, double& total_latency) {\n  // create space for the input buffers\n  // LINEITEM table\n  buffer l_orderkey_buf(dbinfo.l.orderkey);\n  buffer l_shipmode_buf(dbinfo.l.shipmode);\n  buffer l_commitdate_buf(dbinfo.l.commitdate);\n  buffer l_shipdate_buf(dbinfo.l.shipdate);\n  buffer l_receiptdate_buf(dbinfo.l.receiptdate);\n\n  // ORDERS table\n  buffer o_orderkey_buf(dbinfo.o.orderkey);\n  buffer o_orderpriority_buf(dbinfo.o.orderpriority);\n\n  // setup the output buffers\n  buffer high_line_count_buf(high_line_count);\n  buffer low_line_count_buf(low_line_count);\n\n  // number of producing iterations depends on the number of elements per cycle\n  const size_t l_rows = dbinfo.l.rows;\n  const size_t l_iters =\n      (l_rows + kLineItemJoinWindowSize - 1) / kLineItemJoinWindowSize;\n  const size_t o_rows = dbinfo.o.rows;\n  const size_t o_iters =\n      (o_rows + kOrderJoinWindowSize - 1) / kOrderJoinWindowSize;\n\n  // start timer\n  high_resolution_clock::time_point host_start = high_resolution_clock::now();\n\n  /////////////////////////////////////////////////////////////////////////////\n  //// LineItemProducer Kernel: produce the LINEITEM table\n  auto produce_lineitem_event = q.submit([&](handler& h) {\n    size_t l_rows = dbinfo.l.rows;\n    accessor l_orderkey_accessor(l_orderkey_buf, h, read_only);\n    accessor l_shipmode_accessor(l_shipmode_buf, h, read_only);\n    accessor l_commitdate_accessor(l_commitdate_buf, h, read_only);\n    accessor l_shipdate_accessor(l_shipdate_buf, h, read_only);\n    accessor l_receiptdate_accessor(l_receiptdate_buf, h, read_only);\n\n    h.single_task<LineItemProducer>([=]() [[intel::kernel_args_restrict]] {\n#ifdef PRECISE_TIMING\n      (void) LineItemProducerStartPipe::read();\n#endif\n      [[intel::initiation_interval(1)]]\n      for (size_t i = 0; i < l_iters + 1; i++) {\n        bool done = (i == l_iters);\n        bool valid = (i != l_iters);\n\n        // bulk read of data from global memory\n        NTuple<kLineItemJoinWindowSize, LineItemRow> data;\n\n        UnrolledLoop<0, kLineItemJoinWindowSize>([&](auto j) {\n          size_t idx = (i*kLineItemJoinWindowSize + j);\n          bool in_range = idx < l_rows;\n          DBIdentifier key_tmp = l_orderkey_accessor[idx];\n          int shipmode = l_shipmode_accessor[idx];\n          DBDate commitdate = l_commitdate_accessor[idx];\n          DBDate shipdate = l_shipdate_accessor[idx];\n          DBDate receiptdate = l_receiptdate_accessor[idx];\n\n          DBIdentifier key =\n              in_range ? key_tmp : std::numeric_limits<DBIdentifier>::max();\n\n          data.get<j>() = LineItemRow(in_range, key, shipmode, commitdate,\n                                      shipdate, receiptdate);\n        });\n\n        // write to pipe\n        LineItemProducerPipe::write(LineItemRowPipeData(done, valid, data));\n      }\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////////////\n  //// OrdersProducer Kernel: produce the ORDERS table\n  auto produce_orders_event = q.submit([&](handler& h) {\n    size_t o_rows = dbinfo.o.rows;\n    accessor o_orderkey_accessor(o_orderkey_buf, h, read_only);\n    accessor o_orderpriority_accessor(o_orderpriority_buf, h, read_only);\n\n    h.single_task<OrdersProducer>([=]() [[intel::kernel_args_restrict]] {\n#ifdef PRECISE_TIMING\n      (void) OrdersProducerStartPipe::read();\n#endif\n      [[intel::initiation_interval(1)]]\n      for (size_t i = 0; i < o_iters + 1; i++) {\n        bool done = (i == o_iters);\n        bool valid = (i != o_iters);\n\n        // bulk read of data from global memory\n        NTuple<kOrderJoinWindowSize, OrdersRow> data;\n\n        UnrolledLoop<0, kOrderJoinWindowSize>([&](auto j) {\n          size_t idx = (i*kOrderJoinWindowSize + j);\n          bool in_range = idx < o_rows;\n          \n          DBIdentifier key_tmp = o_orderkey_accessor[idx];\n          int orderpriority = o_orderpriority_accessor[idx];\n\n          DBIdentifier key =\n              in_range ? key_tmp : std::numeric_limits<DBIdentifier>::max();\n\n          data.get<j>() = OrdersRow(in_range, key, orderpriority);\n        });\n\n        // write to pipe\n        OrdersProducerPipe::write(OrdersRowPipeData(done, valid, data));\n      }\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////////////\n  //// Join kernel\n  auto join_event = q.submit([&](handler& h) {\n    // streaming query12 computation\n    h.single_task<Join>([=]() [[intel::kernel_args_restrict]] {\n      MergeJoin<OrdersProducerPipe, OrdersRow, kOrderJoinWindowSize,\n                LineItemProducerPipe, LineItemRow, kLineItemJoinWindowSize,\n                JoinedProducerPipe, JoinedRow>();\n\n      // join is done, tell downstream\n      JoinedProducerPipe::write(JoinedRowPipeData(true, false));\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////////////\n  //// Compute Kernel\n  auto compute_event = q.submit([&](handler& h) {\n    // output write accessors\n    accessor high_line_count_accessor(high_line_count_buf, h, write_only, no_init);\n    accessor low_line_count_accessor(low_line_count_buf, h, write_only, no_init);\n\n    h.single_task<Compute>([=]() [[intel::kernel_args_restrict]] {\n      // local accumulators\n      DBDecimal high_line_count1_local = 0, high_line_count2_local = 0;\n      DBDecimal low_line_count1_local = 0, low_line_count2_local = 0;\n      bool done;\n\n      [[intel::initiation_interval(1)]]\n      do {\n        // get joined row from pipe\n        JoinedRowPipeData joined_data = JoinedProducerPipe::read();\n\n        // upstream kernel tells this kernel when it is done\n        done = joined_data.done;\n\n        if (!done && joined_data.valid) {\n          DBDecimal high_line_count1_local_tmp[kLineItemJoinWindowSize];\n          DBDecimal low_line_count1_local_tmp[kLineItemJoinWindowSize];\n          DBDecimal high_line_count2_local_tmp[kLineItemJoinWindowSize];\n          DBDecimal low_line_count2_local_tmp[kLineItemJoinWindowSize];\n\n          UnrolledLoop<0, kLineItemJoinWindowSize>([&](auto i) {\n            // determine 'where' criteria of query\n            const bool is_shipmode1 =\n                (joined_data.data.get<i>().shipmode == shipmode1);\n                \n            const bool is_shipmode2 =\n                (joined_data.data.get<i>().shipmode == shipmode2);\n\n            const bool valid_shipmode = (is_shipmode1 || is_shipmode2);\n\n            const bool valid_commitdate =\n                (joined_data.data.get<i>().commitdate <\n                 joined_data.data.get<i>().receiptdate);\n\n            const bool valid_shipdate = (joined_data.data.get<i>().shipdate <\n                                         joined_data.data.get<i>().commitdate);\n\n            const bool receipt_within_year_of_date =\n                ((joined_data.data.get<i>().receiptdate >= low_date) &&\n                 (joined_data.data.get<i>().receiptdate < high_date));\n\n            const bool urgent_or_high =\n                (joined_data.data.get<i>().orderpriority == 1 ||\n                 joined_data.data.get<i>().orderpriority == 2);\n\n            const bool do_computation = joined_data.data.get<i>().valid &&\n                valid_shipmode && valid_commitdate && valid_shipdate &&\n                receipt_within_year_of_date;\n\n            if (do_computation) {\n              // is this order priority urgent or high\n              const DBDecimal high_line_val = urgent_or_high ? 1 : 0;\n              const DBDecimal low_line_val = urgent_or_high ? 0 : 1;\n\n              high_line_count1_local_tmp[i] = is_shipmode1 ? high_line_val : 0;\n              low_line_count1_local_tmp[i] = is_shipmode1 ? low_line_val : 0;\n\n              high_line_count2_local_tmp[i] = is_shipmode2 ? high_line_val : 0;\n              low_line_count2_local_tmp[i] = is_shipmode2 ? low_line_val : 0;\n            } else {\n              high_line_count1_local_tmp[i] = 0;\n              low_line_count1_local_tmp[i] = 0;\n\n              high_line_count2_local_tmp[i] = 0;\n              low_line_count2_local_tmp[i] = 0;\n            }\n          });\n\n          // this creates an adder reduction tree from *_local_tmp to *_local\n#pragma unroll\n          for (size_t i = 0; i < kLineItemJoinWindowSize; ++i) {\n            high_line_count1_local += high_line_count1_local_tmp[i];\n            low_line_count1_local += low_line_count1_local_tmp[i];\n            high_line_count2_local += high_line_count2_local_tmp[i];\n            low_line_count2_local += low_line_count2_local_tmp[i];\n          }\n        }\n      } while (!done);\n\n      // write back the local data to global memory\n      high_line_count_accessor[0] = high_line_count1_local;\n      high_line_count_accessor[1] = high_line_count2_local;\n      low_line_count_accessor[0] = low_line_count1_local;\n      low_line_count_accessor[1] = low_line_count2_local;\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n#ifdef PRECISE_TIMING\n  // Started last to get more reliable timings\n  /////////////////////////////////////////////////////////////////////////////\n  //// Start Production - Ensure accurate timings\n  auto start_production_event = q.submit([&](handler& h) {\n    h.single_task<StartProduction>([=]() [[intel::kernel_args_restrict]] {\n      OrdersProducerStartPipe::write(true);\n      LineItemProducerStartPipe::write(true);\n    });\n  });\n  /////////////////////////////////////////////////////////////////////////////\n\n  start_production_event.wait();\n#endif\n  produce_orders_event.wait();\n  produce_lineitem_event.wait();\n  join_event.wait();\n  compute_event.wait();\n\n  // stop timer\n  high_resolution_clock::time_point host_end = high_resolution_clock::now();\n  duration<double, std::milli> diff = host_end - host_start;\n\n  //// gather profiling info\n#ifdef PRECISE_TIMING\n  // Measure complete timing from start of pipeline to the end.\n  auto start_time =\n      start_production_event.get_profiling_info<info::event_profiling::command_start>();\n#else\n  // Just measure computation\n  auto start_time =\n      compute_event.get_profiling_info<info::event_profiling::command_start>();\n#endif // PRECISE_TIMING\n  auto end_time =\n      compute_event.get_profiling_info<info::event_profiling::command_end>();\n\n  // calculating the kernel execution time in ms\n  auto kernel_execution_time = (end_time - start_time) * 1e-6;\n\n  kernel_latency = kernel_execution_time;\n  total_latency = diff.count();\n\n  return true;\n}\n"
    },
    {
        "label": "query12_kernel.hpp",
        "data": "#ifndef __QUERY12_KERNEL_HPP__\n#define __QUERY12_KERNEL_HPP__\n#pragma once\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"../dbdata.hpp\"\n\nusing namespace sycl;\n\nbool SubmitQuery12(queue& q, Database& dbinfo,\n                   DBDate low_date, DBDate high_date,\n                   int shipmode1, int shipmode2,\n                   std::array<DBDecimal, 2>& high_line_count,\n                   std::array<DBDecimal, 2>& low_line_count,\n                   double& kernel_latency, double& total_latency);\n\n#endif  //__QUERY12_KERNEL_HPP__\n"
    },
    {
        "label": "matmul_demo.cpp",
        "data": "#include <cmath>\n#include <iomanip>\n#include <iostream>\n\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n#include \"matmul.hpp\"\n\n// Fills a matrix with random numbers within the range [l_bound, u_bound).\nvoid FillRand(std::vector<float> &m_matrix, int l_bound, int u_bound,\n              int elements) {\n  for (int element = 0; element < elements; element++) {\n    m_matrix[element] =\n        static_cast<float>(rand()) /\n            (static_cast<float>((RAND_MAX) / (u_bound - l_bound))) +\n        l_bound;\n  }\n}\n\n// Compares num_matrices pairs of matrices; returns true iff they are equal\n// given a tolerated error bound.\nbool EqualMat(std::vector<float> &c_matrix, std::vector<float> &c_reference,\n              int rows, int cols, int num_matrices) {\n  int matsize = rows * cols;\n  bool passed = true;\n\n  // Floating-point error threshold value\n  constexpr float kEpsilon = 0.01f;\n\n  for (int matrix_idx = 0; matrix_idx < num_matrices; matrix_idx++) {\n    for (int col = 0; col < cols; col++) {\n      for (int row = 0; row < rows; row++) {\n        int idx = matrix_idx * matsize + col * rows + row;\n        if (abs(c_matrix[idx] - c_reference[idx]) > kEpsilon) {\n          passed = false;\n#if DEBUG\n          std::cout << \"Error: C[\" << col << \"][\" << row << \"] = \"\n                    << c_matrix[idx]\n                    << \" but REF[\" << col << \"][\" << row << \"] = \"\n                    << c_reference[idx] << std::endl;\n#endif\n        }\n        if (!sycl::isfinite(c_matrix[idx])) {\n          passed = false;\n#if DEBUG\n          std::cout << \"C[\" << col << \"][\" << row << \"] = \" << c_matrix[idx]\n                    << \" is not finite\" << std::endl;\n#endif\n        }\n      }\n    }\n  }\n  return passed;\n}\n\n// Output a matrix to the screen (assumes column-major format).\nvoid PrintMat(std::vector<float> &m_matrix, int rows, int cols) {\n  for (int row = 0; row < rows; row++) {\n    for (int col = 0; col < cols; col++) {\n      // Copy old state of cout\n      std::ios oldState(nullptr);\n      oldState.copyfmt(std::cout);\n\n      // Edit the output format of cout\n      std::cout << std::fixed << std::setprecision(2);\n\n      // Print the results\n      std::cout << std::setw(8) << m_matrix[col * rows + row] << \" \";\n\n      // Restore the output format of cout\n      std::cout.copyfmt(oldState);\n    }\n    std::cout << std::endl;\n  }\n}\n\n// Transpose num_matrices matrices in m_matrix and store the results in\n// m_transposed.\nvoid TransposeMat(std::vector<float> &m_matrix,\n                  std::vector<float> &m_transposed, int rows, int cols,\n                  int num_matrices) {\n  int matsize = rows * cols;\n\n  for (int matrix_idx = 0; matrix_idx < num_matrices; matrix_idx++) {\n    for (int row = 0; row < rows; row++) {\n      for (int col = 0; col < cols; col++) {\n        m_transposed[matrix_idx * matsize + row * cols + col] =\n            m_matrix[matrix_idx * matsize + col * rows + row];\n      }\n    }\n  }\n}\n\n// Multiply num_matrices pairs of matrices from a_matrix and b_matrix and store\n// all the results in c_matrix.\nvoid MatmulRef(std::vector<float> &a_matrix, std::vector<float> &b_matrix,\n               std::vector<float> &c_matrix, int rows_a, int common, int cols_b,\n               int num_matrices) {\n  int matsize_a = rows_a * common;\n  int matsize_b = cols_b * common;\n  int matsize_c = rows_a * cols_b;\n\n  for (int matrix_idx = 0; matrix_idx < num_matrices; matrix_idx++) {\n    for (int col = 0; col < cols_b; col++) {\n      for (int row = 0; row < rows_a; row++) {\n        float sum = 0;\n        for (int k = 0; k < common; k++) {\n          sum += a_matrix[matrix_idx * matsize_a + k * rows_a + row] *\n                 b_matrix[matrix_idx * matsize_b + col * common + k];\n        }\n        c_matrix[matrix_idx * matsize_c + col * rows_a + row] = sum;\n      }\n    }\n  }\n}\n\nint main(int argc, char *argv[]) {\n  // Matrix paramters specified by build system\n  constexpr int kRowsA = ROWS_A;\n  constexpr int kCommon = COMMON;\n  constexpr int kColsB = COLS_B;\n  constexpr int kTileA = TILE_A;\n  constexpr int kTileB = TILE_B;\n\n  // Matrix sizes\n  constexpr int kMatsizeA = kRowsA * kCommon;\n  constexpr int kMatsizeB = kColsB * kCommon;\n  constexpr int kMatsizeC = kRowsA * kColsB;\n\n  // Repetitions and number of matrices to measure performance\n#if FPGA_SIMULATOR\n  int repetitions = argc > 1 ? atoi(argv[1]) : 1;\n  constexpr int kNumMatrices = 1;\n#elif FPGA_HARDWARE\n  int repetitions = argc > 1 ? atoi(argv[1]) : 819200;\n  constexpr int kNumMatrices = 2;\n#else // #if FPGA_EMULATOR\n  int repetitions = argc > 1 ? atoi(argv[1]) : 16;\n  constexpr int kNumMatrices = 2;\n#endif\n\n  try {\n\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  // Enable the queue profiling to time the execution\n  sycl::property_list queue_properties{\n      sycl::property::queue::enable_profiling()};\n  sycl::queue q =\n      sycl::queue(selector, fpga_tools::exception_handler, queue_properties);\n\n  std::cout << \"Running on device: \"\n            << q.get_device().get_info<sycl::info::device::name>().c_str()\n            << std::endl;\n\n  // Create arrays to hold the input and output matrices\n  std::vector<float> a_matrix(kMatsizeA * kNumMatrices);\n  std::vector<float> b_matrix(kMatsizeB * kNumMatrices);\n  std::vector<float> c_matrix(kMatsizeC * kNumMatrices);\n\n  // Generate random A and B matrices\n  constexpr int kRandMin = 1;\n  constexpr int kRandMax = 10;\n  srand(1138);\n  FillRand(a_matrix, kRandMin, kRandMax, kMatsizeA * kNumMatrices);\n  FillRand(b_matrix, kRandMin, kRandMax, kMatsizeB * kNumMatrices);\n\n  // Calculate a reference to compare our answer to and store it in c_reference\n  // NOTE: since the systolic matrix multiply interprets B as transposed, we\n  // need to first transpose b_matrix to b_transposed to use it in the standard\n  // MM algorithm\n  std::vector<float> b_transposed(kMatsizeB * kNumMatrices);\n  std::vector<float> c_reference(kMatsizeC * kNumMatrices);\n  TransposeMat(b_matrix, b_transposed, kColsB, kCommon, kNumMatrices);\n  MatmulRef(a_matrix, b_transposed, c_reference, kRowsA, kCommon, kColsB,\n            kNumMatrices);\n\n  std::cout << \" Matrix A size: \" << kRowsA << \" x \" << kCommon\n            << \" (tile: \" << kTileA << \" x \" << kCommon << \")\" << std::endl\n            << \" Matrix B size: \" << kCommon << \" x \" << kColsB\n            << \" (tile: \" << kCommon << \" x \" << kTileB << \")\" << std::endl\n            << \" Systolic array size: \" << kTileA << \" x \" << kTileB << \" PEs\"\n            << std::endl;\n  std::cout << \"Running matrix multiplication of \" << kNumMatrices\n            << ((kNumMatrices > 1) ? \" matrices \" : \" matrix \") << repetitions\n            << \" times\" << std::endl;\n\n  // Run the matrix multiplication\n  MatmulImpl<float, kRowsA, kCommon, kColsB, kTileA, kTileB, kNumMatrices>(\n      q, a_matrix, b_matrix, c_matrix, repetitions);\n\n#if DEBUG\n  // Print A, B, C and reference matrices\n  for (int matrix_idx = 0; matrix_idx < kNumMatrices; matrix_idx++) {\n    std::cout << std::endl << matrix_idx << std::endl;\n\n    std::cout << std::endl << \"Matrix A\" << std::endl;\n    std::vector<float> a_vector = {\n        a_matrix.begin() + matrix_idx * kMatsizeA,\n        a_matrix.begin() + (matrix_idx + 1) * kMatsizeA};\n    PrintMat(a_vector, kRowsA, kCommon);\n\n    std::cout << std::endl << \"Matrix B\" << std::endl;\n    std::vector<float> b_vector = {\n        b_transposed.begin() + matrix_idx * kMatsizeB,\n        b_transposed.begin() + (matrix_idx + 1) * kMatsizeB};\n    PrintMat(b_vector, kCommon, kColsB);\n\n    std::cout << std::endl << \"Matrix C reference\" << std::endl;\n    std::vector<float> c_ref_vector = {\n        c_reference.begin() + matrix_idx * kMatsizeC,\n        c_reference.begin() + (matrix_idx + 1) * kMatsizeC};\n    PrintMat(c_ref_vector, kRowsA, kColsB);\n\n    std::cout << std::endl << \"Matrix C calculated\" << std::endl;\n    std::vector<float> c_vector = {\n        c_matrix.begin() + matrix_idx * kMatsizeC,\n        c_matrix.begin() + (matrix_idx + 1) * kMatsizeC};\n    PrintMat(c_vector, kRowsA, kColsB);\n  }\n#endif\n\n  // Verify results\n  bool passed = EqualMat(c_matrix, c_reference, kRowsA, kColsB, kNumMatrices);\n  std::cout << std::endl << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n  return !passed;\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::cerr << \"   If you are targeting an FPGA hardware, \"\n                 \"ensure that your system is plugged to an FPGA board that is \"\n                 \"set up correctly\"\n              << std::endl;\n    std::cerr << \"   If you are targeting the FPGA emulator, compile with \"\n                 \"-DFPGA_EMULATOR\"\n              << std::endl;\n\n    std::terminate();\n  }\n} // end of main\n"
    },
    {
        "label": "cholesky_inversion_demo.cpp",
        "data": "#include <cmath>\n\n#include <sycl/sycl.hpp>\n#include <list>\n#include <sycl/ext/intel/ac_types/ac_complex.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n// included from ../../../../include\n#include \"cholesky_inversion.hpp\"\n\n// Use \"#define DEBUG\" to print debugging information such as matrices content\n\n/*\n  COMPLEX, MATRIX_DIMENSION, FIXED_ITERATIONS_DECOMPOSITION and\n  FIXED_ITERATIONS_INVERSION are defined by the build system. Depending on the\n  value of COMPLEX, computes the real or complex Cholesky-based inversion. The\n  Cholesky decompostion provides the L matrix from A such that: A = LL*\n  Therefore we can compute inv(A) = inv(LL*)\n                                  = inv(L*) x inv(L)\n                                  = inv(L)* x inv(L)\n\n  Function arguments:\n  - a_matrix:    The input matrix.\n  - i_matrix     The inverse matrix. The function will overwrite this matrix.\n  - q:           The device queue.\n  - matrix_count: Number of matrices to invert.\n  - repetitions: The number of repetitions of the computation to execute.\n                 (for performance evaluation)\n*/\ntemplate <typename T, bool is_complex>\nvoid CholeskyInversion(std::vector<T> &a_matrix, std::vector<T> &i_matrix,\n                       sycl::queue &q, int matrix_count, int repetitions) {\n  CholeskyInversionImpl<MATRIX_DIMENSION, FIXED_ITERATIONS_DECOMPOSITION,\n                        FIXED_ITERATIONS_INVERSION, is_complex, float>(\n      a_matrix, i_matrix, q, matrix_count, repetitions);\n}\n\n/*\n  Returns true if both the real and complex parts of the given ac_complex\n  value are finite\n*/\nbool IsFinite(ac_complex<float> val) {\n  return std::isfinite(val.r()) && std::isfinite(val.i());\n}\n\n/*\n  Returns true if the given value is finite\n*/\nbool IsFinite(float val) { return std::isfinite(val); }\n\n/*\n  Returns a random floating-point value between min and max\n*/\nfloat RandomValueInInterval(float min, float max) {\n  return min + static_cast<float>(rand()) /\n                   (static_cast<float>(RAND_MAX) / (max - min));\n}\n\n/*\n  Generate the input matrices for the cholesky inversion\n*/\ntemplate <int matrices_to_invert, int matrix_size, int columns, typename T>\nvoid GenerateInputData(std::vector<T> &a_matrix) {\n  constexpr bool kComplex = COMPLEX != 0;\n\n  std::cout << \"Generating \" << matrices_to_invert << \" random \";\n  if constexpr (kComplex) {\n    std::cout << \"complex \";\n  } else {\n    std::cout << \"real \";\n  }\n  std::cout << \"matri\" << (matrices_to_invert > 1 ? \"ces\" : \"x\") << \" of size \"\n            << columns << \"x\" << columns << \" \" << std::endl;\n            \n  constexpr size_t kRandomSeed = 1138;\n\n  // Generate the random (Hermitian and positive-definite) input matrices\n  srand(kRandomSeed);\n\n  // Max condition number\n  constexpr float kEpsilon = 0.5;\n\n  // Random min and max values for the random floating-point value\n  // generation\n  constexpr float kRandomMin = 0;\n  constexpr float kRandomMax = 1;\n\n  /*\n    Generate a random matrix with a given epsilon such that\n    cond(M, inf) <= (1+epsilon)/(1-epsilon)\n    This is helpful as having a condition number with infinite norm close to 1\n    improves the numerical stability of the matrix inversion.\n    Provided an epsilon value, this function populates the output vector with\n    a matrix in a row fashion.\n\n    Algorithm courtesy of Carl Christian Kjelgaard Mikkelsen (spock@cs.umu.se)\n\n    Once this matrix is generated, we need to alter it a little to make\n    it Hermitian\n  */\n  for (int mat_idx = 0; mat_idx < matrices_to_invert; mat_idx++) {\n    int current_matrix = mat_idx * matrix_size;\n\n    // Generate a random matrix R with diagonal elements set to 0\n    // and measure the weights of the off diagonal entries\n    std::vector<T> r, weights, a_matrix_non_hermitian;\n    r.resize(columns * columns);\n    a_matrix_non_hermitian.resize(columns * columns);\n    weights.resize(columns);\n    for (int row = 0; row < columns; row++) {\n      weights[row] = {0};\n      for (int col = 0; col < columns; col++) {\n        if (col != row) {\n          int index = (row * columns) + col;\n          float random1 = RandomValueInInterval(kRandomMin, kRandomMax);\n          T elem;\n#if COMPLEX == 1\n          float random1I = RandomValueInInterval(kRandomMin, kRandomMax);\n          elem = {random1, random1I};\n          r[index] = elem;\n#else\n          elem = random1;\n          r[index] = elem;\n#endif\n          weights[row] += elem;\n        }\n      }\n\n      // Construct the new diagonal element\n      weights[row] /= kEpsilon;\n      r[(row * columns) + row] = weights[row];\n    }\n\n    // Perform the diagonal scaling by solving:\n    // diag(diag(A))*output = A\n    for (int row = 0; row < columns; row++) {\n      for (int col = 0; col < columns; col++) {\n        int index = row * columns + col;\n        a_matrix_non_hermitian[index] = r[index] / r[(row * columns) + row];\n      }\n    }\n\n    // Make the matrix Hermitian\n    for (int row = 0; row < columns; row++) {\n      for (int col = 0; col < columns; col++) {\n        int index = row * columns + col;\n\n        a_matrix[current_matrix + index] =\n            (a_matrix_non_hermitian[index] +\n             a_matrix_non_hermitian[(col * columns) + row]) /\n            2;\n\n#if COMPLEX == 1\n        if (row > col) {\n          a_matrix[current_matrix + index] =\n              a_matrix[current_matrix + index].conj();\n        }\n#endif\n      }\n    }\n\n#ifdef DEBUG\n    std::cout << \"A MATRIX \" << mat_idx << std::endl;\n    for (size_t row = 0; row < columns; row++) {\n      for (size_t col = 0; col < columns; col++) {\n        std::cout << a_matrix[current_matrix + (col * columns) + row] << \" \";\n      }  // end of col\n      std::cout << std::endl;\n    }  // end of row\n#endif\n\n  }  // end of mat_idx\n}\n\n/*\n  Check results for correctness\n*/\ntemplate <int inverted_matrices, int matrix_size, int invert_matrix_size,\n          int rows, int columns, typename T>\nint CheckResults(std::vector<T> &a_matrix, std::vector<T> &i_matrix) {\n  // For output post-processing (op)\n  T i_matrix_op[rows][columns];\n\n  // Floating-point error threshold value at which we decide that the design\n  // computed an incorrect value\n  constexpr float kErrorThreshold = 1e-4;\n\n  // Check I matrices\n  std::cout << \"Verifying results...\" << std::endl;\n  for (int mat_idx = 0; mat_idx < inverted_matrices; mat_idx++) {\n    // Keep track of I element index\n    size_t i_idx = 0;\n\n    // Read the I matrix from the output vector to the i_matrix_op matrix\n    for (size_t j = 0; j < columns; j++) {\n      for (size_t i = 0; i < rows; i++) {\n        if (i < j) {\n#if COMPLEX == 0\n          i_matrix_op[i][j] = i_matrix_op[j][i];\n#else\n          i_matrix_op[i][j] = i_matrix_op[j][i].conj();\n#endif\n        } else {\n          i_matrix_op[i][j] = i_matrix[(mat_idx * invert_matrix_size) + i_idx];\n          i_idx++;\n        }\n      }\n    }\n\n#ifdef DEBUG\n    std::cout << \"I MATRIX\" << std::endl;\n    for (size_t i = 0; i < rows; i++) {\n      for (size_t j = 0; j < columns; j++) {\n        std::cout << i_matrix_op[i][j] << \" \";\n      }\n      std::cout << std::endl;\n    }\n#endif\n\n    // Count the number of errors found for this matrix\n    size_t error_count = 0;\n    bool error = false;\n\n    // Current A matrix start index\n    int current_matrix = mat_idx * matrix_size;\n\n    for (size_t i = 0; i < rows; i++) {\n      for (size_t j = 0; j < columns; j++) {\n        // Compute I x A at index i,j\n        T i_times_a_ij{0};\n        // Compute A x I at index i,j\n        T a_times_i_ij{0};\n\n        for (size_t k = 0; k < columns; k++) {\n#if COMPLEX == 0\n          i_times_a_ij +=\n              i_matrix_op[i][k] * a_matrix[current_matrix + (k * columns) + j];\n          a_times_i_ij +=\n              a_matrix[current_matrix + (i * columns) + k] * i_matrix_op[k][j];\n#else\n          i_times_a_ij += i_matrix_op[i][k] *\n                          a_matrix[current_matrix + (k * columns) + j].conj();\n          a_times_i_ij += a_matrix[current_matrix + (i * columns) + k] *\n                          i_matrix_op[k][j].conj();\n#endif\n        }\n\n        // Verify that all the results are OK:\n        // I x A = Id at index i,j\n        bool i_times_a_is_id = false;\n        // A x I = Id at index i,j\n        bool a_times_i_is_id = false;\n        // I is finite at index i,j\n        bool i_is_finite = false;\n\n#if COMPLEX == 0\n        if (i == j) {\n          // Diagonal elements\n          i_times_a_is_id = (abs(i_times_a_ij - 1)) < kErrorThreshold;\n          a_times_i_is_id = (abs(a_times_i_ij - 1)) < kErrorThreshold;\n        } else {\n          // Non diagonal elements\n          i_times_a_is_id = abs(i_times_a_ij) < kErrorThreshold;\n          a_times_i_is_id = abs(a_times_i_ij) < kErrorThreshold;\n        }\n#else\n        if (i == j) {\n          // Diagonal elements\n          i_times_a_is_id = (abs(i_times_a_ij.r() - 1)) < kErrorThreshold;\n          a_times_i_is_id = (abs(a_times_i_ij.r() - 1)) < kErrorThreshold;\n        } else {\n          // Non diagonal elements\n          i_times_a_is_id = abs(i_times_a_ij.r()) < kErrorThreshold;\n          a_times_i_is_id = abs(a_times_i_ij.r()) < kErrorThreshold;\n        }\n\n        bool imag_is_zero_i_times_a = abs(i_times_a_ij.i()) < kErrorThreshold;\n        i_times_a_is_id &= imag_is_zero_i_times_a;\n        bool imag_is_zero_a_times_i = abs(a_times_i_ij.i()) < kErrorThreshold;\n        a_times_i_is_id &= imag_is_zero_a_times_i;\n#endif\n\n        i_is_finite = IsFinite(i_matrix_op[i][j]);\n\n        // If any of the checks failed\n        if (!i_times_a_is_id || !a_times_i_is_id || !i_is_finite) {\n          // Increase the error count for this matrix\n          error_count++;\n\n          // Continue counting the errors even if we are going to\n          // produce an error\n          if (error) {\n            continue;\n          }\n\n          std::cerr << \"Error in matrix \" << mat_idx << std::endl;\n\n          if (!i_times_a_is_id) {\n            std::cerr << \"Error: I*A at [\" << i << \"][\" << j\n                      << \"] = \" << i_times_a_ij << std::endl;\n          }\n          if (!a_times_i_is_id) {\n            std::cerr << \"Error: A*I at [\" << i << \"][\" << j\n                      << \"] = \" << a_times_i_ij << std::endl;\n          }\n          if (!i_is_finite) {\n            std::cerr << \"I[\" << i << \"][\" << j << \"] = \" << i_matrix_op[i][j]\n                      << \" is not finite\" << std::endl;\n          }\n          error = true;\n        }\n      }  // end of j\n    }    // end of i\n\n    if (error_count > 0) {\n      std::cerr << std::endl << \"FAILED\" << std::endl;\n      std::cerr << std::endl\n                << \"!!!!!!!!!!!!!! \" << error_count << \" errors\" << std::endl;\n      return 1;\n    }\n  }  // end of mat_idx\n\n  // All passed\n  std::cout << std::endl << \"PASSED\" << std::endl;\n  return 0;\n}\n\nint main(int argc, char *argv[]) {\n  constexpr size_t kRows = MATRIX_DIMENSION;\n  constexpr size_t kColumns = MATRIX_DIMENSION;\n  constexpr size_t kAMatrixSize = kRows * kColumns;\n  constexpr size_t kIMatrixSize = kColumns * (kColumns + 1) / 2;\n  constexpr bool kComplex = COMPLEX != 0;\n\n#if defined(FPGA_SIMULATOR)\n  constexpr size_t kMatricesToInvert = 1;\n#else\n  constexpr size_t kMatricesToInvert = 8;\n#endif\n\n  // Get the number of times we want to repeat the inversion from the command\n  // line.\n#if defined(FPGA_EMULATOR)\n  int repetitions = argc > 1 ? atoi(argv[1]) : 16;\n#elif defined(FPGA_SIMULATOR)\n  int repetitions = argc > 1 ? atoi(argv[1]) : 1;\n#else\n  int repetitions = argc > 1 ? atoi(argv[1]) : 819200;\n#endif\n\n  if (repetitions < 1) {\n    std::cerr << \"Number of repetitions given is lower than 1.\" << std::endl;\n    std::cerr << \"The inversion must occur at least 1 time.\" << std::endl;\n    std::cerr << \"Increase the number of repetitions (e.g. 16).\" << std::endl;\n    return 1;\n  }\n\n  try {\n\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // Enable the queue profiling to time the execution\n    sycl::queue q = sycl::queue(\n        selector, fpga_tools::exception_handler,\n        sycl::property_list{sycl::property::queue::enable_profiling()});\n    sycl::device device = q.get_device();\n\n    std::cout << \"Running on device: \"\n        << device.get_info<sycl::info::device::name>().c_str() \n        << std::endl;\n\n    // Select a type for this compile depending on the value of COMPLEX\n    using T = std::conditional_t<kComplex, ac_complex<float>, float>;\n\n    // Create vectors to hold all the input and output matrices\n    std::vector<T> a_matrix;\n    std::vector<T> i_matrix;\n    std::vector<T> r, weights;\n\n    a_matrix.resize(kAMatrixSize * kMatricesToInvert);\n    i_matrix.resize(kIMatrixSize * kMatricesToInvert);\n\n    // Generate the input matrices to be inverted\n    GenerateInputData<kMatricesToInvert, kAMatrixSize, kColumns>(a_matrix);\n\n    std::cout << \"Computing the Cholesky-based inversion of \"\n              << kMatricesToInvert << \" matri\"\n              << (kMatricesToInvert > 1 ? \"ces \" : \"x \") << repetitions\n              << \" times\" << std::endl;\n\n    // Invert the matrices\n    CholeskyInversion<T, kComplex>(a_matrix, i_matrix, q, kMatricesToInvert,\n                                   repetitions);\n\n    // Check the returned matrices for correctness\n    return CheckResults<kMatricesToInvert, kAMatrixSize, kIMatrixSize, kRows,\n                        kColumns>(a_matrix, i_matrix);\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::cerr << \"   If you are targeting FPGA hardware, \"\n                 \"ensure that your system is connected to an FPGA board that \"\n                 \"is set up correctly\"\n              << std::endl;\n    std::cerr << \"   If you are targeting the FPGA emulator, compile with \"\n                 \"-DFPGA_EMULATOR\"\n              << std::endl;\n\n    std::terminate();\n  } catch (std::bad_alloc const &e) {\n    std::cerr << \"Caught a memory allocation exception on the host: \"\n              << e.what() << std::endl;\n    std::cerr << \"   You can reduce the memory requirement by reducing the \"\n                 \"number of matrices generated. Specify a smaller number when \"\n                 \"running the executable.\"\n              << std::endl;\n    std::cerr << \"   In this run, more than \"\n              << ((kAMatrixSize + kIMatrixSize) * 2 * kMatricesToInvert *\n                  sizeof(float)) /\n                     pow(2, 30)\n              << \" GBs of memory was requested for the inversion of a \"\n              << \"matrix of size \" << kRows << \" x \" << kColumns << std::endl;\n    std::terminate();\n  }\n}  // end of main\n"
    },
    {
        "label": "fft2d_demo.cpp",
        "data": "#include <cmath>\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n\n#include <sycl/ext/intel/ac_types/ac_complex.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n#include \"fft2d.hpp\"\n\n// Forward declarations\nvoid TestFFT(bool mangle, bool inverse);\ntemplate <int n>\nint Coordinates(int iteration, int i);\ntemplate <int lognr_points>\nvoid FourierTransformGold(ac_complex<double> *data, bool inverse);\ntemplate <int lognr_points>\nvoid FourierStage(ac_complex<double> *data);\n\nint main(int argc, char **argv) {\n  if (argc == 1) {\n    std::cout << \"No program argument was passed, running all fft2d variants\"\n              << std::endl;\n\n    // test FFT transform with ordered memory layout\n    TestFFT(false, false);\n    // test inverse FFT transform with ordered memory layout\n    TestFFT(false, true);\n    // test FFT transform with alternative memory layout\n    TestFFT(true, false);\n    // test inverse FFT transform with alternative memory layout\n    TestFFT(true, true);\n\n  } else {\n    std::string mode = argv[1];\n\n    bool mangle{};\n    bool inverse{};\n\n    if (mode == \"normal\") {\n      mangle = false;\n      inverse = false;\n    } else if (mode == \"inverse\") {\n      mangle = false;\n      inverse = true;\n    } else if (mode == \"mangle\") {\n      mangle = true;\n      inverse = false;\n    } else if (mode == \"inverse-mangle\") {\n      mangle = true;\n      inverse = true;\n    } else {\n      std::cerr << \"Usage: fft2d <mode>\" << std::endl;\n      std::cerr << \"Where mode can be normal|inverse|mangle|inverse-mangle|all\"\n                << std::endl;\n      std::terminate();\n    }\n\n    TestFFT(mangle, inverse);\n  }\n  return 0;\n}\n\nvoid TestFFT(bool mangle, bool inverse) {\n  try {\n    // Device selector selection\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // Enable the queue profiling to time the execution\n    sycl::property_list queue_properties{\n        sycl::property::queue::enable_profiling()};\n    sycl::queue q =\n        sycl::queue(selector, fpga_tools::exception_handler, queue_properties);\n\n    sycl::device device = q.get_device();\n\n    // Print out the device information.\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>() << std::endl;\n\n    // Define the log of the FFT size on each dimension and the level of\n    // parallelism to implement\n#if FPGA_SIMULATOR\n    // Force small sizes in simulation mode to reduce simulation time\n    constexpr int kLogN = 4;\n    constexpr int kParallelism = 4;\n#else\n    constexpr int kLogN = LOGN;\n    constexpr int kParallelism = PARALLELISM;\n#endif\n\n    static_assert(kParallelism == 4 || kParallelism == 8,\n                  \"The FFT kernel implementation only supports 4-parallel and \"\n                  \"8-parallel FFTs.\");\n\n    constexpr int kN = 1 << kLogN;\n    constexpr int kLogParallelism = kParallelism == 8 ? 3 : 2;\n\n    // Host memory\n    ac_complex<float> *host_input_data =\n        (ac_complex<float> *)std::malloc(sizeof(ac_complex<float>) * kN * kN);\n    ac_complex<float> *host_output_data =\n        (ac_complex<float> *)std::malloc(sizeof(ac_complex<float>) * kN * kN);\n    ac_complex<double> *host_verify =\n        (ac_complex<double> *)std::malloc(sizeof(ac_complex<double>) * kN * kN);\n    ac_complex<double> *host_verify_tmp =\n        (ac_complex<double> *)std::malloc(sizeof(ac_complex<double>) * kN * kN);\n\n    if ((host_input_data == nullptr) || (host_output_data == nullptr) ||\n        (host_verify == nullptr) || (host_verify_tmp == nullptr)) {\n      std::cerr << \"Failed to allocate host memory with malloc.\" << std::endl;\n      std::terminate();\n    }\n\n    // Initialize input and produce verification data\n    for (int i = 0; i < kN; i++) {\n      for (int j = 0; j < kN; j++) {\n        int where = mangle ? MangleBits<kLogN>(Coordinates<kN>(i, j))\n                           : Coordinates<kN>(i, j);\n        host_verify[Coordinates<kN>(i, j)].r() = host_input_data[where].r() =\n            (float)((double)rand() / (double)RAND_MAX);\n        host_verify[Coordinates<kN>(i, j)].i() = host_input_data[where].i() =\n            (float)((double)rand() / (double)RAND_MAX);\n      }\n    }\n\n    // Device memory\n    ac_complex<float> *input_data;\n    ac_complex<float> *output_data;\n    ac_complex<float> *temp_data;\n\n    if (q.get_device().has(sycl::aspect::usm_device_allocations)) {\n      std::cout << \"Using USM device allocations\" << std::endl;\n      // Allocate FPGA DDR memory.\n      input_data = sycl::malloc_device<ac_complex<float>>(kN * kN, q);\n      output_data = sycl::malloc_device<ac_complex<float>>(kN * kN, q);\n      temp_data = sycl::malloc_device<ac_complex<float>>(kN * kN, q);\n    } else if (q.get_device().has(sycl::aspect::usm_host_allocations)) {\n      std::cout << \"Using USM host allocations\" << std::endl;\n      // No device allocations means that we are probably in a SYCL HLS\n      // flow\n\n#if defined IS_BSP\n      auto prop_list = sycl::property_list{};\n#else\n      // In the SYCL HLS flow, we need to define the memory interface.\n      // For, that we need to assign a location to the memory being accessed.\n      auto prop_list = sycl::property_list{\n          sycl::ext::intel::experimental::property::usm::buffer_location(1)};\n#endif\n\n      input_data = sycl::malloc_host<ac_complex<float>>(kN * kN, q);\n      output_data = sycl::malloc_host<ac_complex<float>>(kN * kN, q, prop_list);\n      temp_data = sycl::malloc_host<ac_complex<float>>(kN * kN, q, prop_list);\n    } else {\n      std::cerr << \"USM device allocations or USM host allocations must be \"\n                   \"supported to run this sample.\"\n                << std::endl;\n      std::terminate();\n    }\n\n    if (input_data == nullptr || output_data == nullptr ||\n        temp_data == nullptr) {\n      std::cerr << \"Failed to allocate USM memory.\" << std::endl;\n      std::terminate();\n    }\n\n    // Copy the input data from host DDR to USM memory\n    q.memcpy(input_data, host_input_data, sizeof(ac_complex<float>) * kN * kN)\n        .wait();\n\n    std::cout << \"Launching a \" << kN * kN << \" points \" << kParallelism\n              << \"-parallel \" << (inverse ? \"inverse \" : \"\")\n              << \"FFT transform (\" << (mangle ? \"alternative\" : \"ordered\")\n              << \" data layout)\" << std::endl;\n\n    /*\n     * A 2D FFT transform requires applying a 1D FFT transform to each matrix\n     * row followed by a 1D FFT transform to each column of the intermediate\n     * result.\n     * A single FFT engine can process rows and columns back-to-back. However,\n     * as matrix data is stored in global memory, the efficiency of memory\n     * accesses will impact the overall performance. Accessing consecutive\n     * memory locations leads to efficient access patterns. However, this is\n     * obviously not possible when accessing both rows and columns.\n     *\n     * The implementation is divided between three concurrent SYCL kernels, as\n     * depicted below:\n     *\n     *  --------------------      --------------      --------------------------\n     *  | read matrix rows | ---> | FFT engine | ---> | bit-reverse, transpose |\n     *  |                  |      |            |      |    and write matrix    |\n     *  --------------------      --------------      --------------------------\n     *\n     * This sequence of kernels does back-to-back row processing followed by a\n     * data transposition and writes the results back to memory. The host code\n     * runs these kernels twice to produce the overall 2D FFT transform\n     *\n     *\n     * These kernels transfer data through pipes.\n     * This avoids the need to read and write intermediate data using global\n     * memory.\n     *\n     * In many cases the FFT engine is a building block in a large application.\n     * In this case, the memory layout of the matrix can be altered to achieve\n     * higher memory transfer efficiency. This implementation demonstrates how\n     * an alternative memory layout can improve performance. The host switches\n     * between the two memory layouts using a kernel argument. See the\n     * 'MangleBits' function for additional details.\n     */\n\n    double start_time;\n    double end_time;\n\n    // This is a limitation of the design\n    static_assert(kN / kParallelism >= kParallelism);\n\n    // Kernel to kernel pipes\n    using FetchToFFT =\n        sycl::ext::intel::pipe<class FetchToFFTPipe,\n                               std::array<ac_complex<float>, kParallelism>, 0>;\n    using FFTToTranspose =\n        sycl::ext::intel::pipe<class FFTToTransposePipe,\n                               std::array<ac_complex<float>, kParallelism>, 0>;\n\n    for (int i = 0; i < 2; i++) {\n      ac_complex<float> *to_read = i == 0 ? input_data : temp_data;\n      ac_complex<float> *to_write = i == 0 ? temp_data : output_data;\n\n      // Start a 1D FFT on the matrix rows/columns\n      auto fetch_event = q.single_task<class FetchKernel>(\n          Fetch<kLogN, kLogParallelism, FetchToFFT, float>{to_read, mangle});\n\n      auto fft_event = q.single_task<class FFTKernel>(\n          FFT<kLogN, kLogParallelism, FetchToFFT, FFTToTranspose, float>{\n              inverse});\n\n      auto transpose_event = q.single_task<class TransposeKernel>(\n          Transpose<kLogN, kLogParallelism, FFTToTranspose, float>{to_write,\n                                                                   mangle});\n\n      fft_event.wait();\n      transpose_event.wait();\n\n      if (i == 0) {\n        start_time = fetch_event.template get_profiling_info<\n            sycl::info::event_profiling::command_start>();\n      } else {\n        end_time = transpose_event.template get_profiling_info<\n            sycl::info::event_profiling::command_end>();\n      }\n    }\n\n    double kernel_runtime = (end_time - start_time) / 1.0e9;\n\n    // Copy the output data from the USM memory to the host DDR\n    q.memcpy(host_output_data, output_data, sizeof(ac_complex<float>) * kN * kN)\n        .wait();\n\n    std::cout << \"Processing time = \" << kernel_runtime << \"s\" << std::endl;\n\n    double gpoints_per_sec = ((double)kN * kN / kernel_runtime) * 1e-9;\n    double gflops = 2 * 5 * kN * kN * (log((float)kN) / log((float)2)) /\n                    (kernel_runtime * 1e9);\n\n    std::cout << \"Throughput = \" << gpoints_per_sec << \" Gpoints / sec (\"\n              << gflops << \" Gflops)\" << std::endl;\n\n    // Check signal to noise ratio\n\n    // Run reference code\n    for (int i = 0; i < kN; i++) {\n      FourierTransformGold<kLogN>(host_verify + Coordinates<kN>(i, 0), inverse);\n    }\n\n    for (int i = 0; i < kN; i++) {\n      for (int j = 0; j < kN; j++) {\n        host_verify_tmp[Coordinates<kN>(j, i)] =\n            host_verify[Coordinates<kN>(i, j)];\n      }\n    }\n\n    for (int i = 0; i < kN; i++) {\n      FourierTransformGold<kLogN>(host_verify_tmp + Coordinates<kN>(i, 0),\n                                  inverse);\n    }\n\n    for (int i = 0; i < kN; i++) {\n      for (int j = 0; j < kN; j++) {\n        host_verify[Coordinates<kN>(j, i)] =\n            host_verify_tmp[Coordinates<kN>(i, j)];\n      }\n    }\n\n    double magnitude_sum = 0;\n    double noise_sum = 0;\n    for (int i = 0; i < kN; i++) {\n      for (int j = 0; j < kN; j++) {\n        int where = mangle ? MangleBits<kLogN>(Coordinates<kN>(i, j))\n                           : Coordinates<kN>(i, j);\n        double magnitude = (double)host_verify[Coordinates<kN>(i, j)].r() *\n                               (double)host_verify[Coordinates<kN>(i, j)].r() +\n                           (double)host_verify[Coordinates<kN>(i, j)].i() *\n                               (double)host_verify[Coordinates<kN>(i, j)].i();\n        double noise = (host_verify[Coordinates<kN>(i, j)].r() -\n                        (double)host_output_data[where].r()) *\n                           (host_verify[Coordinates<kN>(i, j)].r() -\n                            (double)host_output_data[where].r()) +\n                       (host_verify[Coordinates<kN>(i, j)].i() -\n                        (double)host_output_data[where].i()) *\n                           (host_verify[Coordinates<kN>(i, j)].i() -\n                            (double)host_output_data[where].i());\n\n        magnitude_sum += magnitude;\n        noise_sum += noise;\n      }\n    }\n    double db = 10 * log(magnitude_sum / noise_sum) / log(10.0);\n\n    std::cout << \"Signal to noise ratio on output sample: \" << db << std::endl;\n    std::cout << \" --> \" << (db > 120 ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    sycl::free(input_data, q);\n    free(output_data, q);\n    free(temp_data, q);\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::terminate();\n  }\n}\n\n/////// HELPER FUNCTIONS ///////\n\n// provides a linear offset in the input array\ntemplate <int n>\nint Coordinates(int iteration, int i) {\n  return iteration * n + i;\n}\n\n// Reference Fourier transform\ntemplate <int lognr_points>\nvoid FourierTransformGold(ac_complex<double> *data, bool inverse) {\n  constexpr int kNrPoints = 1 << lognr_points;\n\n  // The inverse requires swapping the real and imaginary component\n  if (inverse) {\n    for (int i = 0; i < kNrPoints; i++) {\n      double tmp = data[i].r();\n      data[i].r() = data[i].i();\n      data[i].i() = tmp;\n    }\n  }\n\n  // Do a FT recursively\n  FourierStage<lognr_points>(data);\n\n  // The inverse requires swapping the real and imaginary component\n  if (inverse) {\n    for (int i = 0; i < kNrPoints; i++) {\n      double tmp = data[i].r();\n      data[i].r() = data[i].i();\n      data[i].i() = tmp;\n    }\n  }\n}\n\ntemplate <int lognr_points>\nvoid FourierStage(ac_complex<double> *data) {\n  if constexpr (lognr_points > 0) {\n    constexpr int kNrPoints = 1 << lognr_points;\n\n    ac_complex<double> *half1 = (ac_complex<double> *)malloc(\n        sizeof(ac_complex<double>) * kNrPoints / 2);\n    ac_complex<double> *half2 = (ac_complex<double> *)malloc(\n        sizeof(ac_complex<double>) * kNrPoints / 2);\n\n    if (half1 == nullptr || half2 == nullptr) {\n      std::cerr << \"Failed to allocate memory in validation function.\"\n                << std::endl;\n      std::terminate();\n    }\n\n    for (int i = 0; i < kNrPoints / 2; i++) {\n      half1[i] = data[2 * i];\n      half2[i] = data[2 * i + 1];\n    }\n\n    FourierStage<lognr_points - 1>(half1);\n    FourierStage<lognr_points - 1>(half2);\n\n    for (int i = 0; i < kNrPoints / 2; i++) {\n      data[i].r() = half1[i].r() +\n                    cos(2 * M_PI * i / kNrPoints) * half2[i].r() +\n                    sin(2 * M_PI * i / kNrPoints) * half2[i].i();\n      data[i].i() = half1[i].i() -\n                    sin(2 * M_PI * i / kNrPoints) * half2[i].r() +\n                    cos(2 * M_PI * i / kNrPoints) * half2[i].i();\n      data[i + kNrPoints / 2].r() =\n          half1[i].r() - cos(2 * M_PI * i / kNrPoints) * half2[i].r() -\n          sin(2 * M_PI * i / kNrPoints) * half2[i].i();\n      data[i + kNrPoints / 2].i() =\n          half1[i].i() + sin(2 * M_PI * i / kNrPoints) * half2[i].r() -\n          cos(2 * M_PI * i / kNrPoints) * half2[i].i();\n    }\n\n    free(half1);\n    free(half2);\n  }\n}\n"
    },
    {
        "label": "main.cpp",
        "data": "// ==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n//\n// This agreement shall be governed in all respects by the laws of the State of\n// California and by the laws of the United States of America.\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// CRRSolver CPU/FPGA Accelerator Demo Program\n//\n////////////////////////////////////////////////////////////////////////////////\n//\n// This design implements simple Cox-Ross-Rubinstein(CRR) binomial tree model\n// with Greeks for American exercise options.\n//\n//\n// Optimization summary:\n//    -- Area-consuming but infrequent calculation is done on CPU.\n//    -- Parallelize the calculation of a single CRR.\n//    -- Run multiple independent CRRs in parallel.\n//    -- Optimized memory configurations to reduce the need for replication\n//       and to eliminate the need for double-pumping M20Ks.\n//\n// The following diagram shows the mechanism of optimizations to CRR.\n//\n//\n//                                               +------+         ^\n//                                 +------------>|optval|         |\n//                                 |             | [2]  |         |\n//                                 |             +------+         |\n//                                 |                              |\n//                                 |                              |\n//                              +--+---+                          |\n//                +------------>|optval|                          |\n//                |             | [1]  |                          |\n//                |             +--+---+                          |\n//                |                |                              |\n//                |                |                              |\n//                |                |                              |   Loop4(L4)\n//                |                |                              |   updates\n//            +---+--+             +------------>+------+         |   multiple\n//            |optval|                           |optval|         |   elements\n//            | [0]  |                           | [1]  |         |   in optval[]\n//            +---+--+             +------------>+------+         |   simultaneously\n//                |                |                              |\n//                |                |                              |\n//                |                |                              |\n//                |                |                              |\n//                |             +--+---+                          |\n//                |             |optval|                          |\n//                +------------>| [0]  |                          |\n//                              +--+---+                          |\n//                                 |                              |\n//                                 |                              |\n//                                 |             +------+         |\n//                                 |             |optval|         |\n//                                 +------------>| [0]  |         |\n//                                               +------+         +\n//\n//\n//\n//\n//                              step 1           step 2\n//\n//\n//                <------------------------------------------+\n//                  Loop3(L3) updates each level of the tree\n//\n//\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <cmath>\n#include <cstddef>\n#include <cstdlib>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <regex>\n#include <sstream>\n#include <string>\n\n#include \"CRR_common.hpp\"\n\n#include \"exception_handler.hpp\"\n\nusing namespace std;\nusing namespace sycl;\n\n#ifdef FPGA_SIMULATOR\n#define OUTER_UNROLL 1\n#define INNER_UNROLL 2\n#define OUTER_UNROLL_POW2 1\n#else\n#define OUTER_UNROLL OUTER_UNROLL_V\n#define INNER_UNROLL INNER_UNROLL_V\n#define OUTER_UNROLL_POW2 OUTER_UNROLL_POW2_V\n#endif\n\nclass CRRSolver;\ndouble CrrSolver(const int n_items, vector<CRRMeta> &in_params,\n                  vector<CRRResParams> &res_params,\n                  vector<CRRPerStepMeta> &in_params2, queue &q) {\n  auto start = std::chrono::steady_clock::now();\n\n  int steps = std::max_element(in_params.begin(), in_params.end(),\n                               [](const CRRMeta &a, const CRRMeta &b) {\n                                 return a.n_steps < b.n_steps;\n                               })->n_steps;\n\n  const int n_crr =\n      (((n_items + (OUTER_UNROLL - 1)) / OUTER_UNROLL) * OUTER_UNROLL) * 3;\n\n  {\n    buffer<CRRMeta, 1> i_params(in_params.size());\n    buffer<CRRPerStepMeta, 1> a_params(in_params2.size());\n    buffer<CRRResParams, 1> r_params(res_params.size());\n    r_params.set_final_data(res_params.data());\n\n    event e;\n    {\n      // copy the input buffers\n      q.submit([&](handler& h) {\n        auto accessor_v =\n          i_params.template get_access<access::mode::discard_write>(h);\n        h.copy(in_params.data(), accessor_v);\n      });\n\n      q.submit([&](handler& h) {\n        auto accessor_v2 =\n          a_params.template get_access<access::mode::discard_write>(h);\n        h.copy(in_params2.data(), accessor_v2);\n      });\n\n      // start the main kernel\n      e = q.submit([&](handler &h) {\n        auto accessor_v =\n            i_params.template get_access<access::mode::read_write>(h);\n\n        auto accessor_v2 =\n            a_params.template get_access<access::mode::read_write>(h);\n\n        auto accessor_r =\n            r_params.template get_access<access::mode::discard_write>(h);\n\n        h.single_task<CRRSolver>([=]() [[intel::kernel_args_restrict]] {\n          // Kernel requires n_crr to be a multiple of OUTER_UNROLL.\n          // This is taken care of by the host.\n          const int n_crr_div = n_crr / OUTER_UNROLL;\n\n          // Outerloop counter. Use while-loop for better timing-closure\n          // characteristics because it tells the compiler the loop body will\n          // never be skipped.\n          int oc = 0;\n          do {\n            // Metadata of CRR problems\n            [[intel::fpga_register]] double u[OUTER_UNROLL];\n            [[intel::fpga_register]] double c1[OUTER_UNROLL];\n            [[intel::fpga_register]] double c2[OUTER_UNROLL];\n            [[intel::fpga_register]] double param_1[OUTER_UNROLL];\n            [[intel::fpga_register]] double param_2[OUTER_UNROLL];\n            [[intel::fpga_register]] short n_steps[OUTER_UNROLL];\n\n            // Current values in binomial tree.  We only need to keep track of\n            // one level worth of data, not the entire tree.\n            [[intel::fpga_memory, intel::singlepump,\n              intel::bankwidth(sizeof(double)),\n              intel::numbanks(INNER_UNROLL * OUTER_UNROLL_POW2),\n              intel::private_copies(\n                  8)]] double optval[kMaxNSteps3][OUTER_UNROLL_POW2];\n\n            // Initial values in binomial tree, which correspond to the last\n            // level of the binomial tree.\n            [[intel::fpga_memory, intel::singlepump,\n              intel::bankwidth(sizeof(double)),\n              intel::numbanks(INNER_UNROLL * OUTER_UNROLL_POW2),\n              intel::private_copies(\n                  8)]] double init_optval[kMaxNSteps3][OUTER_UNROLL_POW2];\n\n            // u2_array pre-calculates the power function of u2.\n            [[intel::fpga_memory, intel::singlepump,\n              intel::bankwidth(sizeof(double)),\n              intel::numbanks(INNER_UNROLL * OUTER_UNROLL_POW2),\n              intel::private_copies(\n                  8)]] double u2_array[kMaxNSteps3][OUTER_UNROLL_POW2];\n\n            // p1powu_array precalculates p1 multipy the power of u.\n            [[intel::fpga_memory, intel::singlepump,\n              intel::bankwidth(sizeof(double)),\n              intel::numbanks(INNER_UNROLL * OUTER_UNROLL_POW2),\n              intel::private_copies(\n                  8)]] double p1powu_array[kMaxNSteps3][OUTER_UNROLL_POW2];\n\n            // n0_optval stores the binomial tree value corresponding to node 0\n            // of a level. This is the same as what's stored in\n            // optval/init_optval, but replicating this data allows us to have\n            // only one read port for optval and init_optval, thereby removing\n            // the need of double-pumping or replication. n0_optval_2 is a copy\n            // of n0_optval that stores the node 0 value for a specific layer of\n            // the tree. pgreek is the array saving values for post-calculating\n            // Greeks.\n            [[intel::fpga_register]] double n0_optval[OUTER_UNROLL];\n            [[intel::fpga_register]] double n0_optval_2[OUTER_UNROLL];\n            [[intel::fpga_register]] double pgreek[4][OUTER_UNROLL];\n\n            // L1 + L2:\n            // Populate init_optval -- calculate the last level of the binomial\n            // tree.\n            for (short ic = 0; ic < OUTER_UNROLL; ++ic) {\n              // Transfer data from DRAM to local memory or registers\n              const int c = oc * OUTER_UNROLL + ic;\n              const CRRMeta param = accessor_v[c];\n\n              u[ic] = param.u;\n              c1[ic] = param.c1;\n              c2[ic] = param.c2;\n              param_1[ic] = param.param_1;\n              param_2[ic] = param.param_2;\n              n_steps[ic] = param.n_steps;\n\n              for (short t = steps; t >= 0; --t) {\n                const ArrayEle param_array = accessor_v2[c].array_eles[t];\n\n                const double init_val = param_array.init_optval;\n\n                init_optval[t][ic] = init_val;\n\n                // n0_optval intends to store the node value at t == 0.\n                // Instead of qualifying this statement by an \"if (t == 0)\",\n                // which couples the loop counter to the timing path of the\n                // assignment, we reverse the loop direction so the last value\n                // stored corresponds to t == 0.\n                n0_optval[ic] = init_val;\n\n                // Transfer data from DRAM to local memory or registers\n                u2_array[t][ic] = param_array.u2;\n                p1powu_array[t][ic] = param_array.p1powu;\n              }\n            }\n\n            // L3:\n            // Update optval[] -- calculate each level of the binomial tree.\n            // reg[] helps to achieve updating INNER_UNROLL elements in optval[]\n            // simultaneously.\n            [[intel::disable_loop_pipelining]] // NO-FORMAT: Attribute\n            for (short t = 0; t <= steps - 1; ++t) {\n              [[intel::fpga_register]] double reg[INNER_UNROLL + 1][OUTER_UNROLL];\n\n              double val_1, val_2;\n\n              #pragma unroll\n              for (short ic = 0; ic < OUTER_UNROLL; ++ic) {\n                reg[0][ic] = n0_optval[ic];\n              }\n\n              // L4:\n              // Calculate all the elements in optval[] -- all the tree nodes\n              // for one level of the tree\n              [[intel::initiation_interval(1)]] // NO-FORMAT: Attribute\n              for (int n = 0; n <= steps - 1 - t; n += INNER_UNROLL) {\n\n                #pragma unroll\n                for (short ic = 0; ic < OUTER_UNROLL; ++ic) {\n\n                  #pragma unroll\n                  for (short ri = 1; ri <= INNER_UNROLL; ++ri) {\n                    reg[ri][ic] =\n                        (t == 0) ? init_optval[n + ri][ic] : optval[n + ri][ic];\n                  }\n\n                  #pragma unroll\n                  for (short ri = 0; ri < INNER_UNROLL; ++ri) {\n                    const double val = sycl::fmax(\n                        c1[ic] * reg[ri][ic] + c2[ic] * reg[ri + 1][ic],\n                        p1powu_array[t][ic] * u2_array[n + ri][ic] -\n                            param_2[ic]);\n\n                    optval[n + ri][ic] = val;\n                    if (n + ri == 0) {\n                      n0_optval[ic] = val;\n                    }\n                    if (n + ri == 1) {\n                      val_1 = val;\n                    }\n                    if (n + ri == 2) {\n                      val_2 = val;\n                    }\n                  }\n\n                  reg[0][ic] = reg[INNER_UNROLL][ic];\n\n                  if (t == steps - 5) {\n                    pgreek[3][ic] = val_2;\n                  }\n                  if (t == steps - 3) {\n                    pgreek[0][ic] = n0_optval[ic];\n                    pgreek[1][ic] = val_1;\n                    pgreek[2][ic] = val_2;\n                    n0_optval_2[ic] = n0_optval[ic];\n                  }\n                }\n              }\n            }\n\n            // L5: transfer crr_res_params to DRAM\n            #pragma unroll\n            for (short ic = 0; ic < OUTER_UNROLL; ++ic) {\n              const int c = oc * OUTER_UNROLL + ic;\n              if (n_steps[ic] < steps) {\n                accessor_r[c].optval0 = n0_optval_2[ic];\n              } else {\n                accessor_r[c].optval0 = n0_optval[ic];\n              }\n              accessor_r[c].pgreek[0] = pgreek[0][ic];\n              accessor_r[c].pgreek[1] = pgreek[1][ic];\n              accessor_r[c].pgreek[2] = pgreek[2][ic];\n              accessor_r[c].pgreek[3] = pgreek[3][ic];\n            }\n            // Increment counters\n            oc += 1;\n          } while (oc < n_crr_div);\n        });\n      });\n    }\n  }\n\n  auto end = std::chrono::steady_clock::now();\n  double diff = std::chrono::duration_cast<std::chrono::duration<double>>(end - start).count();\n  return diff;\n}\n\nvoid ReadInputFromFile(ifstream &input_file, vector<InputData> &inp) {\n  string line_of_args;\n  while (getline(input_file, line_of_args)) {\n    InputData temp;\n    istringstream line_of_args_ss(line_of_args);\n    line_of_args_ss >> temp.n_steps;\n    line_of_args_ss.ignore(1, ',');\n    line_of_args_ss >> temp.cp;\n    line_of_args_ss.ignore(1, ',');\n    line_of_args_ss >> temp.spot;\n    line_of_args_ss.ignore(1, ',');\n    line_of_args_ss >> temp.fwd;\n    line_of_args_ss.ignore(1, ',');\n    line_of_args_ss >> temp.strike;\n    line_of_args_ss.ignore(1, ',');\n    line_of_args_ss >> temp.vol;\n    line_of_args_ss.ignore(1, ',');\n    line_of_args_ss >> temp.df;\n    line_of_args_ss.ignore(1, ',');\n    line_of_args_ss >> temp.t;\n\n    inp.push_back(temp);\n  }\n}\n\nstatic string ToStringWithPrecision(const double value, const int p = 6) {\n  ostringstream out;\n  out.precision(p);\n  out << std::fixed << value;\n  return out.str();\n}\n\nvoid WriteOutputToFile(ofstream &output_file, const vector<OutputRes> &outp) {\n  size_t n = outp.size();\n  for (size_t i = 0; i < n; ++i) {\n    OutputRes temp;\n    temp = outp[i];\n    string line = ToStringWithPrecision(temp.value, 12) + \" \" +\n                  ToStringWithPrecision(temp.delta, 12) + \" \" +\n                  ToStringWithPrecision(temp.gamma, 12) + \" \" +\n                  ToStringWithPrecision(temp.vega, 12) + \" \" +\n                  ToStringWithPrecision(temp.theta, 12) + \" \" +\n                  ToStringWithPrecision(temp.rho, 12) + \"\\n\";\n\n    output_file << line;\n  }\n}\n\nbool FindGetArgString(const string &arg, const char *str, char *str_value,\n                      size_t maxchars) {\n  size_t found = arg.find(str, 0, strlen(str));\n  if (found != string::npos) {\n    const char *sptr = &arg.c_str()[strlen(str)];\n    for (int i = 0; i < maxchars - 1; i++) {\n      char ch = sptr[i];\n      switch (ch) {\n        case ' ':\n        case '\\t':\n        case '\\0':\n          str_value[i] = 0;\n          return true;\n          break;\n        default:\n          str_value[i] = ch;\n          break;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\n// Perform data pre-processing work\n// Three different option prices are required to solve each CRR problem\n// The following lists why each option price is required:\n// [0] : Used to compute Premium, Delta, Gamma and Theta\n// [1] : Used to compute Rho\n// [2] : Used to compute Vega\nCRRInParams PrepareData(const InputData &inp) {\n  CRRInParams in_params;\n  in_params.n_steps = inp.n_steps;\n\n  double r[2];\n  r[0] = sycl::pow(inp.df, 1.0 / inp.n_steps);\n  double d_df = sycl::exp(-inp.t * kEpsilon);\n  r[1] = sycl::pow(inp.df * d_df, 1.0 / inp.n_steps);\n  in_params.u[0] = sycl::exp(inp.vol * sycl::sqrt(inp.t / inp.n_steps));\n  in_params.u[1] = in_params.u[0];\n  in_params.u[2] = sycl::exp((inp.vol + kEpsilon) * sycl::sqrt(inp.t / inp.n_steps));\n\n  in_params.u2[0] = in_params.u[0] * in_params.u[0];\n  in_params.u2[1] = in_params.u[1] * in_params.u[1];\n  in_params.u2[2] = in_params.u[2] * in_params.u[2];\n  in_params.umin[0] = inp.spot * sycl::pow(1 / in_params.u[0], inp.n_steps + kOpt0);\n  in_params.umin[1] = inp.spot * sycl::pow(1 / in_params.u[1], inp.n_steps);\n  in_params.umin[2] = inp.spot * sycl::pow(1 / in_params.u[2], inp.n_steps);\n  in_params.c1[0] =\n      r[0] * (in_params.u[0] - sycl::pow(inp.fwd / inp.spot, 1.0 / inp.n_steps)) /\n      (in_params.u[0] - 1 / in_params.u[0]);\n  in_params.c1[1] =\n      r[1] *(in_params.u[1] - sycl::pow((inp.fwd / d_df) / inp.spot, 1.0 / inp.n_steps)) /\n      (in_params.u[1] - 1 / in_params.u[1]);\n  in_params.c1[2] =\n      r[0] * (in_params.u[2] - sycl::pow(inp.fwd / inp.spot, 1.0 / inp.n_steps)) /\n      (in_params.u[2] - 1 / in_params.u[2]);\n  in_params.c2[0] = r[0] - in_params.c1[0];\n  in_params.c2[1] = r[1] - in_params.c1[1];\n  in_params.c2[2] = r[0] - in_params.c1[2];\n\n  in_params.param_1[0] = inp.cp * in_params.umin[0];\n  in_params.param_1[1] = inp.cp * in_params.umin[1];\n  in_params.param_1[2] = inp.cp * in_params.umin[2];\n  in_params.param_2 = inp.cp * inp.strike;\n\n  return in_params;\n}\n\nCRRArrayEles PrepareArrData(const CRRInParams &in) {\n  CRRArrayEles arr;\n\n  // Write in reverse t-direction to match kernel access pattern\n  for (int i = 0; i <= in.n_steps + kOpt0; ++i) {\n    for (int inner_func_index = 0; inner_func_index < 3; ++inner_func_index) {\n      arr.array_eles[i][inner_func_index].u2 = sycl::pow(in.u2[inner_func_index], (double) i);\n      arr.array_eles[i][inner_func_index].p1powu =\n          in.param_1[inner_func_index] * sycl::pow(in.u[inner_func_index], (double) (i + 1));\n      arr.array_eles[i][inner_func_index].init_optval =\n          sycl::fmax(in.param_1[inner_func_index] * sycl::pow(in.u2[inner_func_index], (double) i) -\n                   in.param_2, 0.0);\n    }\n  }\n\n  return arr;\n}\n\n// Metadata, used in the Kernel, is generated from the input data\n// Each CRR problem is split into 3 sub-problems to calculate\n// each required option price separately\nvoid PrepareKernelData(vector<CRRInParams> &in_params,\n                       vector<CRRArrayEles> &array_params,\n                       vector<CRRMeta> &in_buff_params,\n                       vector<CRRPerStepMeta> &in_buff2_params,\n                       const int n_crrs) {\n\n  constexpr short offset = 0;\n\n  for (int wi_idx = offset, dst = offset * 3; wi_idx < n_crrs; ++wi_idx) {\n    CRRInParams &src_crr_params = in_params[wi_idx];\n\n    CRRArrayEles &src_crr_eles = array_params[wi_idx];\n\n    for (int inner_func_index = 0; inner_func_index < 3;\n         ++inner_func_index, ++dst) {\n      CRRMeta &dst_crr_meta = in_buff_params[dst];\n      CRRPerStepMeta &dst_crr_per_step_meta = in_buff2_params[dst];\n\n      dst_crr_meta.u = src_crr_params.u[inner_func_index];\n      dst_crr_meta.c1 = src_crr_params.c1[inner_func_index];\n      dst_crr_meta.c2 = src_crr_params.c2[inner_func_index];\n\n      dst_crr_meta.param_1 = src_crr_params.param_1[inner_func_index];\n      dst_crr_meta.param_2 = src_crr_params.param_2;\n\n      if (inner_func_index == 0) {\n        dst_crr_meta.n_steps = src_crr_params.n_steps + kOpt0;\n      } else {\n        dst_crr_meta.n_steps = src_crr_params.n_steps;\n      }\n      for (int i = 0; i <= kMaxNSteps2; ++i) {\n        dst_crr_per_step_meta.array_eles[i].u2 =\n            src_crr_eles.array_eles[i][inner_func_index].u2;\n        dst_crr_per_step_meta.array_eles[i].p1powu =\n            src_crr_eles.array_eles[i][inner_func_index].p1powu;\n        dst_crr_per_step_meta.array_eles[i].init_optval =\n            src_crr_eles.array_eles[i][inner_func_index].init_optval;\n      }\n    }\n  }\n}\n\n// Takes in the result from the kernel and stores the 3 option prices\n// belonging to the same CRR problem in one InterRes element\nvoid ProcessKernelResult(const vector<CRRResParams> &res_params,\n                         vector<InterRes> &postp_buff, const int n_crrs) {\n  constexpr int offset = 0;\n\n  for (int wi_idx = offset, src = offset * 3; wi_idx < n_crrs; ++wi_idx) {\n    InterRes &dst_res = postp_buff[wi_idx];\n\n    for (int inner_func_index = 0; inner_func_index < 3;\n         ++inner_func_index, ++src) {\n      const CRRResParams &src_res = res_params[src];\n\n      for (int i = 0; i < 4; ++i) {\n        if (inner_func_index == 0) {\n          dst_res.pgreek[i] = src_res.pgreek[i];\n        }\n      }\n\n      dst_res.vals[inner_func_index] = src_res.optval0;\n    }\n  }\n}\n\n// Computes the Premium and Greeks\nOutputRes ComputeOutput(const InputData &inp, const CRRInParams &in_params,\n                        const InterRes &res_params) {\n  double h;\n  OutputRes res;\n  h = inp.spot * (in_params.u2[0] - 1 / in_params.u2[0]);\n  res.value = res_params.pgreek[1];\n  res.delta = (res_params.pgreek[2] - res_params.pgreek[0]) / h;\n  res.gamma = 2 / h *\n              ((res_params.pgreek[2] - res_params.pgreek[1]) / inp.spot /\n                   (in_params.u2[0] - 1) -\n               (res_params.pgreek[1] - res_params.pgreek[0]) / inp.spot /\n                   (1 - (1 / in_params.u2[0])));\n  res.theta =\n      (res_params.vals[0] - res_params.pgreek[3]) / 4 / inp.t * inp.n_steps;\n  res.rho = (res_params.vals[1] - res.value) / kEpsilon;\n  res.vega = (res_params.vals[2] - res.value) / kEpsilon;\n  return res;\n}\n\n// Perform CRR solving using the CPU and compare FPGA results with CPU results\n// to test correctness.\nvoid TestCorrectness(int k, int n_crrs, bool &pass, const InputData &inp,\n                     CRRInParams &vals, const OutputRes &fpga_res) {\n  if (k == 0) {\n    std::cout << \"\\n============= Correctness Test ============= \\n\";\n    std::cout << \"Running analytical correctness checks... \\n\";\n  }\n\n  // This CRR benchmark ensures a minimum 4 decimal points match between FPGA and CPU\n  // \"threshold\" is chosen to enforce this guarantee\n  float threshold = 0.00001;\n  int i, j, q;\n  double x;\n  int n_steps = vals.n_steps;\n  int m = n_steps + kOpt0;\n  vector<double> pvalue(kMaxNSteps3);\n  vector<double> pvalue_1(kMaxNSteps1);\n  vector<double> pvalue_2(kMaxNSteps1);\n  vector<double> pgreek(5);\n  InterRes cpu_res_params;\n  OutputRes cpu_res;\n\n  // option value computed at each final node\n  x = vals.umin[0];\n  for (i = 0; i <= m; i++, x *= vals.u2[0]) {\n    pvalue[i] = sycl::fmax(inp.cp * (x - inp.strike), 0.0);\n  }\n\n  // backward recursion to evaluate option price\n  for (i = m - 1; i >= 0; i--) {\n    vals.umin[0] *= vals.u[0];\n    x = vals.umin[0];\n    for (j = 0; j <= i; j++, x *= vals.u2[0]) {\n      pvalue[j] = sycl::fmax(vals.c1[0] * pvalue[j] + vals.c2[0] * pvalue[j + 1],\n                       inp.cp * (x - inp.strike));\n    }\n    if (i == 4) {\n      pgreek[4] = pvalue[2];\n    }\n    if (i == 2) {\n      for (q = 0; q <= 2; q++) {\n        pgreek[q + 1] = pvalue[q];\n      }\n    }\n  }\n  cpu_res_params.vals[0] = pvalue[0];\n\n  // the above computation is repeated for each option price\n  x = vals.umin[1];\n  for (i = 0; i <= n_steps; i++, x *= vals.u2[1]) {\n    pvalue_1[i] = sycl::fmax(inp.cp * (x - inp.strike), 0.0);\n  }\n\n  for (i = n_steps - 1; i >= 0; i--) {\n    vals.umin[1] *= vals.u[1];\n    x = vals.umin[1];\n\n    for (j = 0; j <= i; j++, x *= vals.u2[1]) {\n      pvalue_1[j] =\n          sycl::fmax(vals.c1[1] * pvalue_1[j] + vals.c2[1] * pvalue_1[j + 1],\n               inp.cp * (x - inp.strike));\n    }\n  }\n  cpu_res_params.vals[1] = pvalue_1[0];\n\n  x = vals.umin[2];\n  for (i = 0; i <= n_steps; i++, x *= vals.u2[2]) {\n    pvalue_2[i] = sycl::fmax(inp.cp * (x - inp.strike), 0.0);\n  }\n\n  for (i = n_steps - 1; i >= 0; i--) {\n    vals.umin[2] *= vals.u[2];\n    x = vals.umin[2];\n    for (j = 0; j <= i; j++, x *= vals.u2[2]) {\n      pvalue_2[j] =\n          sycl::fmax(vals.c1[2] * pvalue_2[j] + vals.c2[2] * pvalue_2[j + 1],\n               inp.cp * (x - inp.strike));\n    }\n  }\n  cpu_res_params.vals[2] = pvalue_2[0];\n  pgreek[0] = 0;\n\n  for (i = 1; i < 5; ++i) {\n    cpu_res_params.pgreek[i - 1] = pgreek[i];\n  }\n\n  cpu_res = ComputeOutput(inp, vals, cpu_res_params);\n\n  if (abs(cpu_res.value - fpga_res.value) > threshold) {\n    pass = false;\n    std::cout << \"fpga_res.value \" << k << \" = \" << std::fixed\n              << std::setprecision(20) << fpga_res.value << \"\\n\";\n    std::cout << \"cpu_res.value \" << k << \" = \" << std::fixed\n              << std::setprecision(20) << cpu_res.value << \"\\n\";\n    std::cout << \"Mismatch detected for value of crr \" << k << \"\\n\";\n  }\n  if (abs(cpu_res.delta - fpga_res.delta) > threshold) {\n    pass = false;\n    std::cout << \"fpga_res.delta \" << k << \" = \" << std::fixed\n              << std::setprecision(20) << fpga_res.delta << \"\\n\";\n    std::cout << \"cpu_res.delta \" << k << \" = \" << std::fixed\n              << std::setprecision(20) << cpu_res.delta << \"\\n\";\n    std::cout << \"Mismatch detected for value of crr \" << k << \"\\n\";\n  }\n  if (abs(cpu_res.gamma - fpga_res.gamma) > threshold) {\n    pass = false;\n    std::cout << \"fpga_res.gamma \" << k << \" = \" << std::fixed\n              << std::setprecision(20) << fpga_res.gamma << \"\\n\";\n    std::cout << \"cpu_res.gamma \" << k << \" = \" << std::fixed\n              << std::setprecision(20) << cpu_res.gamma << \"\\n\";\n    std::cout << \"Mismatch detected for value of crr \" << k << \"\\n\";\n  }\n  if (abs(cpu_res.vega - fpga_res.vega) > threshold) {\n    pass = false;\n    std::cout << \"fpga_res.vega \" << k << \" = \" << std::fixed\n              << std::setprecision(20) << fpga_res.vega << \"\\n\";\n    std::cout << \"cpu_res.vega \" << k << \" = \" << std::fixed\n              << std::setprecision(20) << cpu_res.vega << \"\\n\";\n    std::cout << \"Mismatch detected for value of crr \" << k << \"\\n\";\n  }\n  if (abs(cpu_res.theta - fpga_res.theta) > threshold) {\n    pass = false;\n    std::cout << \"fpga_res.theta \" << k << \" = \" << std::fixed\n              << std::setprecision(20) << fpga_res.theta << \"\\n\";\n    std::cout << \"cpu_res.theta \" << k << \" = \" << std::fixed\n              << std::setprecision(20) << cpu_res.theta << \"\\n\";\n    std::cout << \"Mismatch detected for value of crr \" << k << \"\\n\";\n  }\n  if (abs(cpu_res.rho - fpga_res.rho) > threshold) {\n    pass = false;\n    std::cout << \"fpga_res.rho \" << k << \" = \" << std::fixed\n              << std::setprecision(20) << fpga_res.rho << \"\\n\";\n    std::cout << \"cpu_res.rho \" << k << \" = \" << std::fixed\n              << std::setprecision(20) << cpu_res.rho << \"\\n\";\n    std::cout << \"Mismatch detected for value of crr \" << k << \"\\n\";\n  }\n\n  if (k == n_crrs - 1) {\n    std::cout << \"CPU-FPGA Equivalence: \" << (pass ? \"PASS\" : \"FAIL\") << \"\\n\";\n  }\n}\n\n// Print out the achieved CRR throughput\nvoid TestThroughput(const double &time, const int &n_crrs) {\n  std::cout << \"\\n============= Throughput Test =============\\n\";\n\n  std::cout << \"   Avg throughput:   \" << std::fixed << std::setprecision(1)\n            << (n_crrs / time) << \" assets/s\\n\";\n}\n\nint main(int argc, char *argv[]) {\n  string infilename = \"\";\n  string outfilename = \"\";\n\n#if FPGA_SIMULATOR\n  const string default_ifile = \"src/data/small_ordered_inputs.csv\";\n#else\n  const string default_ifile = \"src/data/ordered_inputs.csv\";\n#endif\n  const string default_ofile = \"src/data/ordered_outputs.csv\";\n\n  char str_buffer[kMaxStringLen] = {0};\n  for (int i = 1; i < argc; i++) {\n    if (argv[i][0] == '-') {\n      string sarg(argv[i]);\n\n      FindGetArgString(sarg, \"-o=\", str_buffer, kMaxStringLen);\n      FindGetArgString(sarg, \"--output-file=\", str_buffer, kMaxStringLen);\n    } else {\n      infilename = string(argv[i]);\n    }\n  }\n\n  try {\n\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    queue q(selector, fpga_tools::exception_handler);\n\n    device device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<info::device::name>().c_str()\n              << std::endl;\n\n    vector<InputData> inp;\n\n    // Get input file name, if users don't have their test input file, this\n    // design will use the default input file\n    if (infilename == \"\") {\n      infilename = default_ifile;\n    }\n    ifstream inputFile(infilename);\n\n    if (!inputFile.is_open()) {\n      std::cerr << \"Input file doesn't exist \\n\";\n      return 1;\n    }\n\n    // Check input file format\n    string filename = infilename;\n    std::size_t found = filename.find_last_of(\".\");\n    if (!(filename.substr(found + 1).compare(\"csv\") == 0)) {\n      std::cerr << \"Input file format only support .csv\\n\";\n      return 1;\n    }\n\n    // Get output file name, if users don't define output file name, the design\n    // will use the default output file\n    outfilename = default_ofile;\n    if (strlen(str_buffer)) {\n      outfilename = string(str_buffer);\n    }\n\n    // Check output file format\n    filename = outfilename;\n    found = filename.find_last_of(\".\");\n    if (!(filename.substr(found + 1).compare(\"csv\") == 0)) {\n      std::cerr << \"Output file format only support .csv\\n\";\n      return 1;\n    }\n\n    // Read inputs data from input file\n    ReadInputFromFile(inputFile, inp);\n\n// Get the number of data from the input file\n// Emulator mode only goes through one input (or through OUTER_UNROLL inputs) to\n// ensure fast runtime\n#if defined(FPGA_EMULATOR)\n    int temp_crrs = 1;\n#else\n    int temp_crrs = inp.size();\n#endif\n\n    // Check if n_crrs >= OUTER_UNROLL\n    if (OUTER_UNROLL >= temp_crrs) {\n      if (inp.size() < OUTER_UNROLL) {\n        std::cerr << \"Input size must be greater than or equal to OUTER_UNROLL\\n\";\n        return 1;\n      } else {\n        temp_crrs = OUTER_UNROLL;\n      }\n    }\n\n    const int n_crrs = temp_crrs;\n\n    vector<CRRInParams> in_params(n_crrs);\n    vector<CRRArrayEles> array_params(n_crrs);\n\n    for (int j = 0; j < n_crrs; ++j) {\n      in_params[j] = PrepareData(inp[j]);\n      array_params[j] = PrepareArrData(in_params[j]);\n    }\n\n    // following vectors are arguments for CrrSolver\n    vector<CRRMeta> in_buff_params(n_crrs * 3);\n    vector<CRRPerStepMeta> in_buff2_params(n_crrs * 3);\n\n    // Prepare metadata as input to kernel\n    PrepareKernelData(in_params, array_params, in_buff_params, in_buff2_params,\n                      n_crrs);\n\n#ifdef FPGA_HARDWARE\n    // warmup run - use this run to warmup accelerator\n    vector<CRRResParams> res_params_dummy(n_crrs * 3);\n    CrrSolver(n_crrs, in_buff_params, res_params_dummy, in_buff2_params,\n               q);\n#endif\n\n    // Timed run - profile performance\n    vector<CRRResParams> res_params(n_crrs * 3);\n    double time = CrrSolver(n_crrs, in_buff_params, res_params,\n                             in_buff2_params, q);\n    bool pass = true;\n\n    // Post-processing step\n    // process_res used to compute final results\n    vector<InterRes> process_res(n_crrs);\n    ProcessKernelResult(res_params, process_res, n_crrs);\n\n    vector<OutputRes> result(n_crrs);\n    for (int i = 0; i < n_crrs; ++i) {\n      result[i] = ComputeOutput(inp[i], in_params[i], process_res[i]);\n      TestCorrectness(i, n_crrs, pass, inp[i], in_params[i], result[i]);\n    }\n\n    // Write outputs data to output file\n    ofstream outputFile(outfilename);\n\n    WriteOutputToFile(outputFile, result);\n\n    TestThroughput(time, n_crrs);\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what() << \"\\n\";\n    std::cerr << \"   If you are targeting an FPGA hardware, \"\n                 \"ensure that your system is plugged to an FPGA board that is \"\n                 \"set up correctly\\n\";\n    std::cerr << \"   If you are targeting the FPGA emulator, compile with \"\n                 \"-DFPGA_EMULATOR\\n\";\n    return 1;\n  }\n  return 0;\n}\n"
    },
    {
        "label": "simple_dma.cpp",
        "data": "//  Copyright (c) 2022 Intel Corporation\n//  SPDX-License-Identifier: MIT\n\n#include <stdlib.h>\n\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n#include \"exception_handler.hpp\"\n\n// define buffer locations so the IP can have two unique Avalon memory-mapped\n// host interfaces\nstatic constexpr int kBL1 = 1;\nstatic constexpr int kBL2 = 2;\n\n// define alignment of Avalon memory-mapped host interfaces to be 4 bytes per\n// read\nstatic constexpr int kAlignment = 4;\n\nstruct SimpleDMA {\n  using params1 = decltype(sycl::ext::oneapi::experimental::properties(\n      // give this a unique Avalon memory-mapped host interface\n      sycl::ext::intel::experimental::buffer_location<kBL1>,\n      sycl::ext::intel::experimental::dwidth<32>,\n      sycl::ext::intel::experimental::awidth<32>,\n      sycl::ext::intel::experimental::maxburst<15>,\n      sycl::ext::oneapi::experimental::alignment<kAlignment>,\n      // latency (choose 0-latency so that waitrequest will work)\n      sycl::ext::intel::experimental::latency<0>,\n      sycl::ext::intel::experimental::read_write_mode_read));\n\n  using params2 = decltype(sycl::ext::oneapi::experimental::properties(\n      // give this a unique Avalon memory-mapped host interface\n      sycl::ext::intel::experimental::buffer_location<kBL2>,\n      sycl::ext::intel::experimental::dwidth<32>,\n      sycl::ext::intel::experimental::awidth<32>,\n      sycl::ext::intel::experimental::maxburst<15>,\n      sycl::ext::oneapi::experimental::alignment<kAlignment>,\n      // latency (choose 0-latency so that waitrequest will work)\n      sycl::ext::intel::experimental::latency<0>,\n      sycl::ext::intel::experimental::read_write_mode_write));\n\n  // Struct members will be interpreted as kernel arguments. The pointers are\n  // declared first since they are 64-bit types and won't get split up\n  sycl::ext::oneapi::experimental::annotated_arg<unsigned int *, params1>\n      source;\n  sycl::ext::oneapi::experimental::annotated_arg<unsigned int *, params2> dest;\n\n  // measured in bytes, must be a multiple of 4. This is only 32 bits wide so if\n  // it was declared first it would result in the pointers getting split across\n  // multiple CSR lines.\n  unsigned int length_bytes;\n\n  // This accelerator will be controlled via its Avalon-MM agent interface, so\n  // no kernel properties are set.\n\n  // Implementation of the DMA kernel.\n  void operator()() const {\n    // This loop does not handle partial accesses (less than 4 bytes) at the\n    // start and end of the source/destination so ensure they are at least\n    // 4-byte aligned\n    for (unsigned int i = 0; i < (length_bytes / 4); i++) {\n      dest[i] = source[i];\n    }\n  }\n};\n\nconstexpr int kLen = 128;  // bytes\n\nint main() {\n  // Use compile-time macros to select either:\n  //  - the FPGA emulator device (CPU emulation of the FPGA)\n  //  - the FPGA device (a real FPGA)\n  //  - the simulator device\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  // create the device queue\n  sycl::queue q(selector, fpga_tools::exception_handler);\n\n  // make sure the device supports USM host allocations\n  auto device = q.get_device();\n\n  std::cout << \"Running on device: \"\n            << device.get_info<sycl::info::device::name>().c_str() << std::endl;\n\n  unsigned int *src = sycl::aligned_alloc_shared<unsigned int>(\n      kAlignment, kLen, q,\n      sycl::ext::intel::experimental::property::usm::buffer_location(kBL1));\n  unsigned int *dest = sycl::aligned_alloc_shared<unsigned int>(\n      kAlignment, kLen, q,\n      sycl::ext::intel::experimental::property::usm::buffer_location(kBL2));\n  unsigned int len = kLen;\n\n  // ensure that shared pointers are successfully allocated\n  if (nullptr == src) {\n    std::cerr << \"failed to allocate pointer src: make sure that awidth is \"\n                 \"sufficient for the allocation size.\"\n              << std::endl;\n    return EXIT_FAILURE;\n  }\n  if (nullptr == dest) {\n    std::cerr << \"failed to allocate pointer dest: make sure that awidth is \"\n                 \"sufficient for the allocation size.\"\n              << std::endl;\n    return EXIT_FAILURE;\n  }\n\n  // pre-load\n  for (int i = 0; i < len; i++) {\n    src[i] = len - i;\n    dest[i] = 0;\n  }\n\n  // line below is what associates the name \"SimpleDMA\" to the kernel\n  q.single_task(SimpleDMA{src, dest, len}).wait();\n\n  // check results\n  bool passed = true;\n  for (int i = 0; i < (len / 4); i++) {\n    bool ok = (src[i] == dest[i]);\n    passed &= ok;\n\n    if (!passed) {\n      std::cerr << \"ERROR: [\" << i << \"] expected \" << src[i] << \" saw \"\n                << dest[i] << \". \" << std::endl;\n    }\n  }\n\n  std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n  sycl::free(src, q);\n  sycl::free(dest, q);\n\n  return EXIT_SUCCESS;\n}\n"
    },
    {
        "label": "simple_dma_test.c",
        "data": "//  Copyright (c) 2022 Intel Corporation\n//  SPDX-License-Identifier: MIT\n//\n// This design leverages a simple DMA oneAPI kernel that has had its RTL\n// generated and integrated into the Nios V test system that will be used to\n// control the accelerator. The DMA kernel has been configured to read from\n// memory in memory location 0 (Buffer Location 0) and write to memory in memory\n// location 1 (Buffer Location 1).\n//\n// The CPU is configured to have a single peripheral space located at\n// 0x0010_0000 and it is 1MB in size.  So if you want to connect a different\n// kernel/IP make sure to place it between data master address\n// 0x0010_0000-0x001F_FFFF.\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// This comes from the BSP and contains Nios V data cache flushing APIs\n#include <sys/alt_cache.h>\n\n// This comes from the BSP that was generated by software_build.h, it includes\n// the macros used to access the control/status registers of peripherals\n#include \"io.h\"\n\n// This comes from the BSP that was generated by software_build.h, it contains\n// information like address map, IRQ mapping, etc...\n#include \"system.h\"\n\n// including the kernel register map directly from the kernel build directory\n#include \"../../../kernels/simple_dma/build/simple_dma.report.prj/include/register_map_offsets.h\"\n\n// In bytes, must be a multiple of 4.  Keep it a small number to shorten the\n// simulation time and do not exceed the 1MB memory size (remember this code is\n// in there too). Once the DMA gets going this buffer will fly by fast so\n// setting it too high mostly affects the memory initialization and the\n// correctness check at the end once the DMA gets going this buffer will fly by\n// fast so setting it too high mostly affects the memory initialization and the\n// correctness check at the end.\n#define BUFFER_LENGTH 1024\n\n// Error numbers\n#define TEST_PASS 0\n#define TEST_FAIL 1\n\n/// Calculate DMA kernel register offsets from system.h, and the kernel register\n/// offsets from register_map_offsets.hpp\n\n#define REG_ARG_SOURCE_BASE \\\n  (SIMPLE_DMA_ACCELERATOR_BASE + SIMPLEDMA_REGISTER_MAP_ARG_ARG_SOURCE_REG)\n\n#define REG_ARG_DEST_BASE \\\n  (SIMPLE_DMA_ACCELERATOR_BASE + SIMPLEDMA_REGISTER_MAP_ARG_ARG_DEST_REG)\n\n#define REG_ARG_LENGTH_BASE      \\\n  (SIMPLE_DMA_ACCELERATOR_BASE + \\\n   SIMPLEDMA_REGISTER_MAP_ARG_ARG_LENGTH_BYTES_REG)\n\n#define REG_START_BASE \\\n  (SIMPLE_DMA_ACCELERATOR_BASE + SIMPLEDMA_REGISTER_MAP_START_REG)\n\n#define REG_STATUS \\\n  (SIMPLE_DMA_ACCELERATOR_BASE + SIMPLEDMA_REGISTER_MAP_STATUS_REG)\n\n/// @brief configure and start the Simple DMA Accelerator IP\n///\n/// @details `configure_and_start_dma` will accept the source, destination, and\n/// transfer length and write them into the kernel CSRs.\n///\n/// @note Since the kernel is located in the peripheral space of the Nios V\n/// processor, we simply dereference a pointer to bypass the data\n/// cache.\n///\n/// @param[in] source Pointer to source memory to copy from\n///\n/// @param[in] destination Pointer to which to copy data\n///\n/// @param[in] length_bytes Number of bytes of data to copy\nvoid configure_and_start_dma(unsigned int *source, unsigned int *destination,\n                             unsigned int length_bytes) {\n  // Make these pointers volatile since they point to registers. Repeated\n  // accesses to volatile pointers will not be optimized away. Since these\n  // pointers are only accessed once, marking them volatile is not strictly\n  // necessary, but they are made volatile so that future potential\n  // modifications will be safe.\n\n  // DMA source\n  volatile unsigned int **reg_arg_source_ptr =\n      (volatile unsigned int **)REG_ARG_SOURCE_BASE;\n  *reg_arg_source_ptr = source;\n\n  // DMA destination\n  volatile unsigned int **reg_arg_destination_ptr =\n      (volatile unsigned int **)REG_ARG_DEST_BASE;\n  *reg_arg_destination_ptr = destination;\n\n  // DMA length\n  volatile unsigned int *reg_arg_length_ptr =\n      (volatile unsigned int *)REG_ARG_LENGTH_BASE;\n  *reg_arg_length_ptr = length_bytes;\n\n  // DMA start\n  volatile unsigned int *reg_start_ptr =\n      (volatile unsigned int *)REG_START_BASE;\n  *reg_start_ptr = 1;\n\n  // The DMA kernel should immediately start at this point\n}\n\n/// @brief Exercise the DMA kernel.\n///\n/// The test has the following phases: \\n\n///\n/// 1. populate a source buffer with an incrementing pattern of 'BUFFER_LENGTH'\n/// bytes \\n\n///\n/// 2. clear out the destination buffer \\n\n///\n/// 3. instruct the DMA kernel to perform the source --> destination transfer \\n\n///\n/// 4. check that the destination contents match the source\n///\n/// @return 0 if the test passes.\nint test_simple_dma() {\n  // allocating source and destination buffers at compile time so that if too\n  // large a value is set for BUFFER_LENGTH then we'll find out early at compile\n  // time\n  unsigned int source[BUFFER_LENGTH / 4];\n  unsigned int destination[BUFFER_LENGTH / 4];\n  int i;\n\n  // initialize the source buffer with an incrementing pattern and clear out the\n  // destination before the accelerator clobbers it\n  for (i = 0; i < (BUFFER_LENGTH / 4); i++) {\n    source[i] = i;\n    destination[i] = 0;\n  }\n\n  // main memory (code_data_ram) is *not* in a peripheral region, so all the\n  // writes to the source and destination need to be flushed from the data cache\n  // to avoid cache coherency issues when the accelerator attempts to access\n  // memory.\n\n  // make sure all that source data that was set gets flushed out to main memory\n  alt_dcache_flush(source, BUFFER_LENGTH);\n\n  // make sure all that destination data that was zeroed out gets flushed out to\n  // main memory\n  alt_dcache_flush(destination, BUFFER_LENGTH);\n\n  // Configure and start the DMA kernel\n  configure_and_start_dma(source, destination, BUFFER_LENGTH);\n\n  // Make this volatile so the compiler doesn't optimize repeated accesses away\n  volatile unsigned int *status_reg_ptr = (unsigned int *)REG_STATUS;\n\n  // Busy-waiting for the accelerator to complete (kernel will fire off\n  // interrupt as well but there is no register as of 2024.0 to clear it)\n  while ((*status_reg_ptr & KERNEL_REGISTER_MAP_DONE_MASK) !=\n         KERNEL_REGISTER_MAP_DONE_MASK) {\n  }\n\n  // Now that the accelerator is done, test the destination buffer for\n  // correctness. Since the destination buffer was already flushed from the data\n  // cache, software can safely read the destination without additional data\n  // flushes. Since the source was previously flushed as well, it will get\n  // fetched from main memory and warm up the data cache just like the\n  // destination buffer in the correctness loop.\n\n  // test the results at the destination buffer, if a failure is detected set\n  // pass to 0 and stop testing\n  for (i = 0; i < (BUFFER_LENGTH / 4); i++) {\n    if (source[i] != destination[i]) {\n      printf(\n          \"Test Fail:  Source address = 0x%x, Destination address = 0x%x, byte \"\n          \"offset 0x%x.  Read value 0x%x instead of expected value 0x%x.\\n\",\n          (unsigned int)source, (unsigned int)destination, (i * 4),\n          destination[i], source[i]);\n      return TEST_FAIL;\n    }\n  }\n\n  // If we reach this point then all the data must have passed so we can issue a\n  // blanket statement that the entire test passed\n  printf(\"Test Pass:  All the data at the destination matches the source.\\n\");\n\n  return TEST_PASS;\n}\n\n/// @brief main function\n///\n/// @return 0 on a test pass and non-zero on failures, see error numbers near\n/// top of this file.\nint main() {\n  int return_val;\n\n  printf(\"Test design for the simple DMA kernel\\n\\n\");\n  printf(\n      \"Test will initialize %d incrementing four byte unsigned integers, have \"\n      \"the accelerator DMA copy the data to a destination and then check the \"\n      \"destination for correctness.\\n\",\n      (BUFFER_LENGTH / 4));\n\n  return_val = test_simple_dma();\n  printf(\"Software will now exit.\\n\");\n  return return_val;\n}\n"
    },
    {
        "label": "mvdr_beamforming.cpp",
        "data": "#define _USE_MATH_DEFINES\n#include <cmath>\n\n#include <chrono>\n#include <cstring>\n#include <iomanip>\n#include <thread>\n#include <vector>\n#include <fstream>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"tuple.hpp\"  // DirectProgramming/C++SYCL_FPGA/include\n#include \"mvdr_complex.hpp\"\n\n#if not defined(REAL_IO_PIPES)\n#include \"exception_handler.hpp\"\n#endif\n\n#include \"Constants.hpp\"\n#include \"FakeIOPipes.hpp\"\n#include \"MVDR.hpp\"\n\n#if defined(REAL_IO_PIPES) && defined(FPGA_EMULATOR)\nstatic_assert(false, \"Real IO pipes cannot be emulated for this design\");\n#endif\n\n#if defined(REAL_IO_PIPES) && (defined(_WIN32) || defined(_WIN64))\nstatic_assert(false, \"Real IO pipes cannot be used in windows\");\n#endif\n\n#if defined(REAL_IO_PIPES)\n#include <sys/mman.h>\n#include \"UDP.hpp\"\n#endif\n\nusing namespace sycl;\nusing namespace std::chrono_literals;\nusing namespace std::chrono;\n\n// We will have the producer and consumer use USM host allocations\n// if they are enabled, otherwise they use device allocations\ntemplate <typename Id, typename T, size_t min_capacity = 0>\nusing MyProducer = Producer<Id, T, kUseUSMHostAllocation, min_capacity>;\ntemplate <typename Id, typename T, size_t min_capacity = 0>\nusing MyConsumer = Consumer<Id, T, kUseUSMHostAllocation, min_capacity>;\n\n////////////////////////////////////////////////////////////////////////////////\n// utility functions\nstd::ostream &operator<<(std::ostream &os, const ComplexType &val) {\n  os << val.real() << \" + \" << val.imag() << \"i\";\n  return os;\n}\n\nbool AlmostEqual(float x, float y, float epsilon = 0.0004f) {\n  return std::fabs(x - y) < epsilon;\n}\n\nbool AlmostEqual(ComplexType x, ComplexType y, float epsilon = 0.0004f) {\n  bool real_close = AlmostEqual(x.real(), y.real(), epsilon);\n  bool imag_close = AlmostEqual(x.imag(), y.imag(), epsilon);\n  return real_close && imag_close;\n}\n////////////////////////////////////////////////////////////////////////////////\n\n// Forward declare the kernel names to reduce name mangling\n#if not defined(REAL_IO_PIPES)\nclass DataProducerID;\nclass DataOutConsumerID;\n#endif\nclass SinThetaProducerID;\n\n// the data type that goes through the IO pipes; both fake and real\nusing XrxPipeType = fpga_tools::NTuple<ComplexType, kNumComplexPerXrxPipe>;\n\n// size of Training Data matrix, in units of XrxPipeTypes\nconstexpr size_t kTrainingDataSize =\n    kNumSensorInputs * kTrainingMatrixNumRows / kNumComplexPerXrxPipe;\n\n// size of data to be processed, in units of XrxPipeTypes\nconstexpr size_t kXrxDataSize =\n    kNumSensorInputs * kNumInputVectors / kNumComplexPerXrxPipe;\n\n// size of header data per set of training and processing data matrices, in\n// units of XrxPipeTypes (one header word per matrix)\nconstexpr size_t kHeadersSize = 2;\n\n// total size of one 'quanta' of input data, in units of XrxPipeTypes\nconstexpr size_t kInputDataSize =\n    kTrainingDataSize + kXrxDataSize + kHeadersSize;\n\n// total size of one 'quanta' of output data, in units of ComplexTypes\nconstexpr size_t kDataOutSize = kNumInputVectors * kNumSteer;\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n// host producer and consumers\n#if defined(REAL_IO_PIPES)\n// REAL IO PIPES\nstruct ReadIOPipeID {\n  static constexpr unsigned id = 1;\n};\nstruct WriteIOPipeID {\n  static constexpr unsigned id = 0;\n};\n\nusing DataInPipe =\n    ext::intel::kernel_readable_io_pipe<ReadIOPipeID, XrxPipeType, 512>;\n\nusing DataOutPipe =\n    ext::intel::kernel_writeable_io_pipe<WriteIOPipeID, XrxPipeType, 512>;\n#else\n// FAKE IO PIPES\nusing DataProducer =\n    MyProducer<DataProducerID, XrxPipeType, kInputDataSize * 2>;\nusing DataInPipe = DataProducer::Pipe;\n\nusing DataOutConsumer =\n    MyConsumer<DataOutConsumerID, ComplexType, kDataOutSize * 2>;\nusing DataOutPipe = DataOutConsumer::Pipe;\n#endif\n\nusing SinThetaProducer = MyProducer<SinThetaProducerID, float, kNumSteer * 2>;\nusing SinThetaPipe = SinThetaProducer::Pipe;\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n// File I/O\nbool ReadInputData(std::string in_dir, ComplexType *data_in,\n                   int num_matrix_copies);\nbool WriteOutputData(std::string out_dir, ComplexType *data_out);\nbool CheckOutputData(std::string in_dir, ComplexType *data_out,\n                     int num_matrix_copies, bool print_diffs);\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\nstruct UDPArgs {\n  unsigned long fpga_mac_addr = 0;\n  unsigned long host_mac_addr = 0;\n  unsigned int fpga_udp_port = 0;\n  unsigned int host_udp_port = 0;\n  char *fpga_ip_addr = nullptr;\n  char *fpga_netmask = nullptr;\n  char *host_ip_addr = nullptr;\n};\n\n// arguments\nbool ParseArgs(int argc, char *argv[], int &num_matrix_copies,\n               std::string &in_dir, std::string &out_dir, UDPArgs *udp_args);\nvoid PrintUsage();\n////////////////////////////////////////////////////////////////////////////////\n\n// the main function\nint main(int argc, char *argv[]) {\n  UDPArgs udp_args;\n#if defined(FPGA_SIMULATOR)\n  int num_matrix_copies = 2;\n#else\n  int num_matrix_copies = 1024;\n#endif\n  std::string in_dir = \"../data\";\n  std::string out_dir = \".\";\n\n  // parse the command line arguments\n  if (!ParseArgs(argc, argv, num_matrix_copies, in_dir, out_dir, &udp_args)) {\n    PrintUsage();\n    std::terminate();\n  }\n\n  printf(\"\\n\");\n#if defined(REAL_IO_PIPES)\n  printf(\"FPGA MAC Address: %012lx\\n\", udp_args.fpga_mac_addr);\n  printf(\"FPGA IP Address:  %s\\n\", udp_args.fpga_ip_addr);\n  printf(\"FPGA UDP Port:    %d\\n\", udp_args.fpga_udp_port);\n  printf(\"FPGA Netmask:     %s\\n\", udp_args.fpga_netmask);\n  printf(\"Host MAC Address: %012lx\\n\", udp_args.host_mac_addr);\n  printf(\"Host IP Address:  %s\\n\", udp_args.host_ip_addr);\n  printf(\"Host UDP Port:    %d\\n\", udp_args.host_udp_port);\n#endif\n  printf(\"Matrices:         %d\\n\", num_matrix_copies);\n  printf(\"Input Directory:  '%s'\\n\", in_dir.c_str());\n  printf(\"Output Directory: '%s'\\n\", out_dir.c_str());\n  printf(\"\\n\");\n\n  bool passed = true;\n\n  const size_t in_count = kInputDataSize * num_matrix_copies;\n  const size_t out_count = kDataOutSize * num_matrix_copies;\n\n  // find number of full matrices.\n  // For the real IO pipes, we cannot send and receive a partial\n  // packet so we need to find the number of FULL matrices that\n  // we will send and receive\n#if defined(REAL_IO_PIPES)\n  const size_t in_size = in_count * sizeof(ComplexType);\n\n  size_t full_in_packet_count = in_size / kUDPDataSize;\n  size_t full_in_size = full_in_packet_count * kUDPDataSize;\n  size_t full_in_count = full_in_size / sizeof(ComplexType);\n\n  const size_t num_full_matrix_copies = full_in_count / kInputDataSize;\n\n  const size_t full_out_count = kDataOutSize * num_full_matrix_copies;\n  const size_t full_out_size = full_out_count * sizeof(ComplexType);\n  const size_t full_out_packet_count = full_out_size / kUDPDataSize;\n\n  std::cout << \"full_matrix_copies    = \" << num_full_matrix_copies << \"\\n\";\n  std::cout << \"full_in_packet_count  = \" << full_in_packet_count << \"\\n\";\n  std::cout << \"full_out_packet_count = \" << full_out_packet_count << \"\\n\";\n\n  // allocate aligned memory for raw input and output data\n  unsigned char *in_packets = AllocatePackets(full_in_packet_count);\n  unsigned char *out_packets = AllocatePackets(full_out_packet_count);\n#else\n  // for the fake IO pipes we don't need to worry about data fitting into\n  // UDP packets, so the number of full matrices is the amount requested\n  const size_t num_full_matrix_copies = num_matrix_copies;\n#endif\n\n  // the input and output data\n  std::vector<XrxPipeType> in_data(in_count);\n  std::vector<XrxPipeType> out_data(out_count);\n\n  try {\n    // device selector\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n#if defined(REAL_IO_PIPES)\n    queue q(selector);\n#else\n    queue q(selector, fpga_tools::exception_handler);\n#endif\n\n    device device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<info::device::name>().c_str() \n              << std::endl;\n\n    // initialize the producers and consumers\n#if not defined(REAL_IO_PIPES)\n    DataProducer::Init(q, kInputDataSize * num_matrix_copies);\n    DataOutConsumer::Init(q, kDataOutSize * num_matrix_copies);\n#endif\n    SinThetaProducer::Init(q, kNumSteer);\n\n    // read the input data\n    passed &=\n        ReadInputData(in_dir, (ComplexType *)in_data.data(), num_matrix_copies);\n    if (!passed) {\n      std::terminate();\n    }\n\n#if defined(REAL_IO_PIPES)\n    // convert the input data into UDP packets for the real IO pipes\n    ToPackets(in_packets, in_data.data(), full_in_count);\n#else\n    // copy the input data to the producer fake IO pipe buffer\n    std::copy_n(in_data.data(), in_count, DataProducer::Data());\n#endif\n\n    // calculate the sin(theta) values for each steering vector\n    constexpr float degree_unit = 120.0f / (kNumSteer - 1);\n    for (int i = 0; i < kNumSteer; i++) {\n      float degree = -60.0f + i * degree_unit;\n      SinThetaProducer::Data()[i] = sycl::sin(degree / 180.0f * M_PI);\n    }\n\n    // launch the mvdr kernels\n    MVDREventArray mvdr_events;\n    mvdr_events = SubmitMVDRKernels<\n        kNumSensorInputs,           // number of sensor array inputs\n        kRMBFactor,                 // Reed-Mallett-Brennan rule\n                                    // Number of 'rows' of sensor data used\n                                    // by the QRD is k_num_sensor_inputs *\n                                    // k_rmb_factor (generally 2-5)\n        kNumSteer,                  // number of steering vectors\n        kSubstitutionUnrollFactor,  // unroll factor used by the forward and\n                                    // backward substitution kernels\n        kBeamformingUnrollFactor,   // unroll factor used by beamformer\n        kQRDMinIterations,          // minimum 'inner loop' iterations for QRD\n        kNumComplexPerXrxPipe,      // Number of complex numbers (contained\n                                    // in NTuple) per read from the\n                                    // Xrx input pipes\n        DataInPipe,                 // Input data for MVDR\n        SinThetaPipe,               // sin(theta) input for steering vectors\n        DataOutPipe                 // output from MVDR\n        >(q, kNumInputVectors);\n\n    std::cout << \"Launched MVDR kernels\" << std::endl;\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Throughput test\n    ////////////////////////////////////////////////////////////////////////////\n    std::cout << std::endl\n              << \"*** Launching throughput test of \" << num_matrix_copies\n              << \" matrices ***\" << std::endl;\n\n    std::cout << \"Sensor inputs                 : \" << kNumSensorInputs\n              << std::endl;\n    std::cout << \"Training matrix rows          : \" << kTrainingMatrixNumRows\n              << std::endl;\n    std::cout << \"Data rows per training matrix : \" << kNumInputVectors\n              << std::endl;\n    std::cout << \"Steering vectors              : \" << kNumSteer << std::endl;\n    std::cout << \"Streaming pipe width          : \" << kNumComplexPerXrxPipe\n              << std::endl;\n\n    // Start the host producer for the sin theta data\n    // By waiting on this kernel to finish, we are assuring that the runtime\n    // has already programmed the FPGA with the image for this kernel. This\n    // makes calling SetupFPGA below safe (for the real IO pipes).\n    event steer_dma_event, steer_kernel_event;\n    std::tie(steer_dma_event, steer_kernel_event) =\n      SinThetaProducer::Start(q, kNumSteer);\n    steer_dma_event.wait();\n    steer_kernel_event.wait();\n\n    // Setup CSRs on FPGA (this function is in UDP.hpp)\n    // NOTE: this must be done AFTER programming the FPGA, which happens\n    // when the kernel is launched (if it is not already programmed)\n#if defined(REAL_IO_PIPES)\n    SetupFPGA(udp_args.fpga_mac_addr, udp_args.fpga_ip_addr,\n             udp_args.fpga_udp_port, udp_args.fpga_netmask,\n             udp_args.host_mac_addr, udp_args.host_ip_addr,\n             udp_args.host_udp_port);\n\n    // give some time for the FPGA to set things up\n    std::this_thread::sleep_for(100ms);\n#endif\n\n    ////////////////////////////////////////////////////////////////////////////\n    // start the producer and consumer of data\n#if defined(REAL_IO_PIPES)\n    // REAL IO PIPES: start CPU threads to produce/consume data to/from the\n    // IO pipes of the FPGA using UDP\n\n    // start the receiver\n    std::cout << \"Starting receiver thread\" << std::endl;\n    std::thread receiver_thread([&] {\n      std::this_thread::sleep_for(10ms);\n      std::cout << \"Receiver running on CPU \" << sched_getcpu() << \"\\n\";\n      UDPReceiver(udp_args.host_ip_addr, udp_args.fpga_udp_port, out_packets,\n                  full_out_packet_count, nullptr);\n    });\n\n    // pin the receiver to CPU 1\n    if (PinThreadToCPU(receiver_thread, 1) != 0) {\n      std::cerr << \"ERROR: could not pin receiver thread to core 1\\n\";\n    }\n\n    // give a little time for the receiver to start\n    std::this_thread::sleep_for(20ms);\n\n    // Start the sender\n    std::cout << \"Starting sender thread\" << std::endl;\n    std::thread sender_thread([&] {\n      std::this_thread::sleep_for(10ms);\n      std::cout << \"Sender running on CPU \" << sched_getcpu() << \"\\n\";\n      UDPSender(udp_args.fpga_ip_addr, udp_args.host_udp_port, in_packets,\n                full_in_packet_count, nullptr);\n    });\n\n    // pin the sender to CPU 3\n    if (PinThreadToCPU(sender_thread, 3) != 0) {\n      std::cerr << \"ERROR: could not pin sender thread to core 3\\n\";\n    }\n#else\n    // start the fake IO pipe kernels\n    event consume_dma_event, consume_kernel_event;\n    event produce_dma_event, produce_kernel_event;\n    std::tie(consume_dma_event, consume_kernel_event) =\n        DataOutConsumer::Start(q, kDataOutSize * num_matrix_copies);\n    std::tie(produce_dma_event, produce_kernel_event) =\n        DataProducer::Start(q, kInputDataSize * num_matrix_copies);\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Wait for the DMA event to finish for the producer before starting the\n    // timer. If USM host allocations are used, this is a noop.\n    produce_dma_event.wait();\n#endif\n\n    auto start_time = high_resolution_clock::now();\n\n    // wait for producer and consumer to finish\n#if defined(REAL_IO_PIPES)\n    sender_thread.join();\n    receiver_thread.join();\n#else\n    produce_kernel_event.wait();\n    consume_kernel_event.wait();\n#endif\n\n    auto end_time = high_resolution_clock::now();\n\n#if not defined(REAL_IO_PIPES)\n    // Stop the timer before performing the DMA from the consumer. Again,\n    // if USM host allocations are used then this is a noop.\n    consume_dma_event.wait();\n#endif\n\n    // compute latency and throughput\n    duration<double, std::milli> process_time(end_time - start_time);\n    double latency_s = process_time.count() * 1e-3;\n    double throughput = num_full_matrix_copies / latency_s;\n\n    std::cout << \"Throughput: \" << throughput << \" matrices/second\\n\";\n\n    // copy the output back from the consumer\n#if defined(REAL_IO_PIPES)\n    const size_t count_to_extract =\n        full_out_packet_count * kUDPDataSize / sizeof(ComplexType);\n\n    FromPackets(out_packets, out_data.data(), count_to_extract);\n\n    const size_t num_out_matrix_copies_to_check =\n        count_to_extract / kDataOutSize;\n#else\n    std::copy_n(DataOutConsumer::Data(), out_count,\n                (ComplexType *)out_data.data());\n\n    const size_t num_out_matrix_copies_to_check = num_full_matrix_copies;\n#endif\n\n    // check one instance of output data\n    passed &= CheckOutputData(in_dir, (ComplexType *)out_data.data(),\n                              num_out_matrix_copies_to_check, true);\n    if (passed) {\n      std::cout << \"Output data check succeeded\" << std::endl;\n    } else {\n      std::cout << \"Output data check failed\" << std::endl;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Post-test cleanup\n    ////////////////////////////////////////////////////////////////////////////\n#if defined(REAL_IO_PIPES)\n    FreePackets(in_packets, full_in_packet_count);\n    FreePackets(out_packets, full_out_packet_count);\n#else\n    DataProducer::Destroy(q);\n    DataOutConsumer::Destroy(q);\n#endif\n    SinThetaProducer::Destroy(q);\n\n  } catch (exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  if (passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n\nbool ReadInputData(std::string in_dir, ComplexType *data_in,\n                   int num_matrix_copies) {\n  // file paths relative the base directory\n  std::string training_real_path = in_dir + \"/\" + \"A_real.txt\";\n  std::string training_imag_path = in_dir + \"/\" + \"A_imag.txt\";\n  std::string x_real_path = in_dir + \"/\" + \"X_real.txt\";\n  std::string x_imag_path = in_dir + \"/\" + \"X_imag.txt\";\n\n  std::cout << \"Reading training data from '\" << training_real_path << \" and \"\n            << training_imag_path << std::endl;\n\n  // parse A\n  std::ifstream a_real_is, a_imag_is;\n  a_real_is.open(training_real_path);\n  a_imag_is.open(training_imag_path);\n  if (a_real_is.fail()) {\n    std::cerr << \"Failed to open \" << training_real_path << \"\\n\";\n    return false;\n  }\n  if (a_imag_is.fail()) {\n    std::cerr << \"Failed to open \" << training_imag_path << \"\\n\";\n    return false;\n  }\n\n  constexpr float kIsTrainingData = 0.0f;\n  constexpr float kIsNotTrainingData = 1.0f;  // any non-zero number is fine\n\n  // insert the header to mark the first training matrix\n  data_in[0].real() = std::nanf(\"\");    // marks this word as a header\n  data_in[0].imag() = kIsTrainingData;  // marks this as training data\n\n  // load the first matrix from the input file\n  int data_offset = kNumComplexPerXrxPipe;  // skip the header\n  for (size_t i = 0; i < kTrainingMatrixNumRows * kNumSensorInputs; i++) {\n    a_real_is >> data_in[data_offset + i].real();\n    a_imag_is >> data_in[data_offset + i].imag();\n  }\n\n  a_real_is.close();\n  a_imag_is.close();\n\n  std::cout << \"Reading input data from \" << x_real_path << \" and \"\n            << x_imag_path << std::endl;\n\n  // parse X\n  std::ifstream x_real_is, x_imag_is;\n  x_real_is.open(x_real_path);\n  x_imag_is.open(x_imag_path);\n  if (x_real_is.fail()) {\n    std::cerr << \"Failed to open \" << x_real_path << \"\\n\";\n    return false;\n  }\n  if (x_imag_is.fail()) {\n    std::cerr << \"Failed to open \" << x_imag_path << \"\\n\";\n    return false;\n  }\n\n  // insert header to mark processing data\n  data_offset = (kTrainingDataSize + 1) * kNumComplexPerXrxPipe;\n  data_in[data_offset].real() = std::nanf(\"\");\n  data_in[data_offset].imag() = kIsNotTrainingData;\n  data_offset += kNumComplexPerXrxPipe;\n\n  // load the first matrix\n  for (size_t i = 0; i < kInputDataSize * kNumComplexPerXrxPipe; i++) {\n    x_real_is >> data_in[data_offset + i].real();\n    x_imag_is >> data_in[data_offset + i].imag();\n  }\n\n  x_real_is.close();\n  x_imag_is.close();\n\n  // copy the first data and training matrices num_matrix_copies times\n  for (size_t matrix_num = 1; matrix_num < num_matrix_copies; matrix_num++) {\n    for (size_t i = 0; i < kInputDataSize * kNumComplexPerXrxPipe; i++) {\n      size_t data_copy_index =\n          i + (matrix_num * kInputDataSize * kNumComplexPerXrxPipe);\n      data_in[data_copy_index] = data_in[i];\n    }\n  }\n\n  return true;\n}\n\nbool CheckOutputData(std::string in_dir, ComplexType *data_out,\n                     int num_matrix_copies, bool print_diffs) {\n  bool match = true;\n\n  // file paths relative the base directory\n  std::string expected_out_real_path =\n      in_dir + \"/\" + \"small_expected_out_real.txt\";\n  std::string expected_out_imag_path =\n      in_dir + \"/\" + \"small_expected_out_imag.txt\";\n#ifdef LARGE_SENSOR_ARRAY\n  expected_out_real_path = in_dir + \"/\" + \"large_expected_out_real.txt\";\n  expected_out_imag_path = in_dir + \"/\" + \"large_expected_out_imag.txt\";\n#endif\n  if (print_diffs) {\n    std::cout << \"Checking output data against \" << expected_out_real_path\n              << \" and \" << expected_out_imag_path << std::endl;\n  }\n\n  std::ifstream exp_real_is, exp_imag_is;\n  exp_real_is.open(expected_out_real_path);\n  exp_imag_is.open(expected_out_imag_path);\n  if (exp_real_is.fail()) {\n    std::cerr << \"Failed to open \" << expected_out_real_path << \"\\n\";\n    return false;\n  }\n  if (exp_imag_is.fail()) {\n    std::cerr << \"Failed to open \" << expected_out_imag_path << \"\\n\";\n    return false;\n  }\n\n  // parse the expected output data\n  std::vector<ComplexType> ref_data(kNumInputVectors * kNumSteer);\n  for (size_t i = 0; i < kNumInputVectors; i++) {\n    for (size_t j = 0; j < kNumSteer; j++) {\n      exp_real_is >> ref_data[i * kNumSteer + j].real();\n      exp_imag_is >> ref_data[i * kNumSteer + j].imag();\n    }\n  }\n\n  exp_real_is.close();\n  exp_imag_is.close();\n\n  // validate the result for all output matrices\n  for (size_t m = 0; m < num_matrix_copies; m++) {\n    for (size_t i = 0; i < kNumInputVectors; i++) {\n      for (size_t j = 0; j < kNumSteer; j++) {\n        auto result =\n            data_out[m * kNumSteer * kNumInputVectors + i * kNumSteer + j];\n        auto expected = ref_data[i * kNumSteer + j];\n\n        if (!AlmostEqual(expected, result)) {\n          if (print_diffs) {\n            std::cout << \"Error in output matrix \" << m << \" for input vector \"\n                      << i << \", steering vector \" << j << \".\\n\"\n                      << \"Expected: \" << expected << \", \"\n                      << \"Actual: \" << result << \"\\n\";\n          }\n          match = false;\n        }\n      }\n    }\n  }\n\n  return match;\n}\n\nbool WriteOutputData(std::string out_dir, ComplexType *data_out) {\n  // file paths relative the base directory\n  std::string out_real_path = out_dir + \"/\" + \"out_real.txt\";\n  std::string out_imag_path = out_dir + \"/\" + \"out_imag.txt\";\n\n  std::cout << \"Writing output to \" << out_real_path << \" and \" << out_imag_path\n            << std::endl;\n\n  std::ofstream out_real_os, out_imag_os;\n  out_real_os.open(out_real_path, std::ios::out | std::ios::trunc);\n  out_imag_os.open(out_imag_path, std::ios::out | std::ios::trunc);\n  if (out_real_os.fail()) {\n    std::cerr << \"Failed to open \" << out_real_path << \"\\n\";\n    return false;\n  }\n  if (out_imag_os.fail()) {\n    std::cerr << \"Failed to open \" << out_imag_path << \"\\n\";\n    return false;\n  }\n\n  for (size_t i = 0; i < kNumInputVectors; i++) {\n    for (size_t j = 0; j < kNumSteer; j++) {\n      out_real_os << std::fixed << std::setw(11)\n                  << data_out[i * kNumSteer + j].real() << \" \";\n      out_imag_os << std::fixed << std::setw(11)\n                  << data_out[i * kNumSteer + j].imag() << \" \";\n    }\n    out_real_os << std::endl;\n    out_imag_os << std::endl;\n  }\n\n  out_real_os.close();\n  out_imag_os.close();\n\n  return true;\n}\n\nbool ParseArgs(int argc, char *argv[], int &num_matrix_copies,\n               std::string &in_dir, std::string &out_dir, UDPArgs *udp_args) {\n#if defined(REAL_IO_PIPES)\n  if (argc < 8) {\n    return false;\n  } else {\n    // parse FPGA and HOST MAC addresses\n    udp_args->fpga_mac_addr = ParseMACAddress(argv[1]);\n    udp_args->host_mac_addr = ParseMACAddress(argv[5]);\n\n    // parse ports\n    udp_args->fpga_udp_port = (unsigned int)atoi(argv[3]);\n    udp_args->host_udp_port = (unsigned int)atoi(argv[7]);\n\n    // get IP addresses and netmask\n    udp_args->fpga_ip_addr = argv[2];\n    udp_args->fpga_netmask = argv[4];\n    udp_args->host_ip_addr = argv[6];\n\n    if (argc > 8) {\n      if (atoi(argv[8]) > 0) {\n        num_matrix_copies = atoi(argv[8]);\n      }\n    }\n    if (argc > 9) {\n      in_dir = argv[9];\n    }\n    if (argc > 10) {\n      out_dir = argv[10];\n    }\n\n    return true;\n  }\n#else\n  if (argc > 1) {\n    if (atoi(argv[1]) > 0) {\n      num_matrix_copies = atoi(argv[1]);\n    }\n  }\n  if (argc > 2) {\n    in_dir = argv[2];\n  }\n  if (argc > 3) {\n    out_dir = argv[3];\n  }\n  return true;\n#endif\n}\n\nvoid PrintUsage() {\n#if defined(REAL_IO_PIPES)\n  std::cout << \"USAGE: ./mvdr_beamforming.fpga fpga_mac_adr fpga_ip_addr \"\n            << \"fpga_udp_port fpga_netmask host_mac_adr host_ip_addr \"\n            << \"host_udp_port [num_matrices] [in directory] [out directory]\\n\";\n  std::cout << \"EXAMPLE: ./mvdr_beamforming.fpga 64:4C:36:00:2F:20 \"\n            << \"192.168.0.11 34543 255.255.255.0 94:40:C9:71:8D:10 \"\n            << \" 192.168.0.10 34543 1024 ../data .\\n\";\n#else\n  std::cout << \"USAGE: ./mvdr_beamforming.fpga \"\n            << \"[num_matrices] [in directory] [out directory]\\n\";\n  std::cout << \"EXAMPLE: ./mvdr_beamforming.fpga 1024 ../data .\\n\";\n#endif\n}\n"
    },
    {
        "label": "udp_loopback_test.cpp",
        "data": "#include <algorithm>\n#include <chrono>\n#include <cstdlib>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <thread>\n\n#include <sys/mman.h>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/ac_types/ac_complex.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"tuple.hpp\"\n#include \"UDP.hpp\"\n\nusing WordType = unsigned long long;\nstatic_assert(sizeof(WordType) <= kUDPDataSize);\nstatic_assert((kUDPDataSize % sizeof(WordType)) == 0);\nconstexpr size_t kWordsPerPacket = kUDPDataSize / sizeof(WordType);\n\nusing namespace sycl;\nusing namespace std::chrono;\n\n// declare kernel and pipe IDs globally to reduce name mangling\nclass RealLoopbackKernel;\nclass NoopKernel;\nstruct WriteIOPipeID {\n  static constexpr unsigned id = 0;\n};\nstruct ReadIOPipeID {\n  static constexpr unsigned id = 1;\n};\n\n// the IO pipes\nstruct IOPipeType {\n  uchar dat[8];\n};\nusing WriteIOPipe =\n    ext::intel::kernel_writeable_io_pipe<WriteIOPipeID, IOPipeType, 512>;\nusing ReadIOPipe =\n    ext::intel::kernel_readable_io_pipe<ReadIOPipeID, IOPipeType, 512>;\n\n// submits the main processing kernel, templated on the input and output pipes\n// NOTE: this kernel is agnostic to whether the input/output pipe is a 'real'\n// or 'fake' IO pipe.\ntemplate <typename IOPipeIn, typename IOPipeOut>\nevent SubmitLoopbackKernel(queue &q) {\n  return q.submit([&](handler &h) {\n    h.single_task<RealLoopbackKernel>([=] {\n      while (1) {\n        auto data = IOPipeIn::read();\n        IOPipeOut::write(data);\n      }\n    });\n  });\n}\n\n// this is a kernel that does no work, it is used as a detection mechanism for\n// the FPGA being programmed\nevent SubmitNoopKernel(queue &q) {\n  return q.submit([&](handler &h) { h.single_task<NoopKernel>([=] {}); });\n}\n\nint main(int argc, char **argv) {\n  unsigned long fpga_mac_adr = 0;\n  unsigned long host_mac_adr = 0;\n  unsigned int fpga_udp_port = 0;\n  unsigned int host_udp_port = 0;\n  char *fpga_ip_address = nullptr;\n  char *fpga_netmask = nullptr;\n  char *host_ip_address = nullptr;\n  size_t packets = 100000000;\n\n  if (argc < 8) {\n    std::cout << \"USAGE: ./mvdr_beamforming.fpga fpga_mac_adr fpga_ip_addr \"\n              << \"fpga_udp_port fpga_netmask host_mac_adr host_ip_addr \"\n              << \"host_udp_port [packets]\\n\";\n    std::cout << \"EXAMPLE: ./mvdr_beamforming.fpga 64:4C:36:00:2F:20 \"\n              << \"192.168.0.11 34543 255.255.255.0 94:40:C9:71:8D:10 \"\n              << \" 192.168.0.10 34543 1024 .\\n\";\n  }\n\n  // parse FPGA and HOST MAC addresses\n  fpga_mac_adr = ParseMACAddress(argv[1]);\n  host_mac_adr = ParseMACAddress(argv[5]);\n\n  // parse ports\n  fpga_udp_port = (unsigned int)atoi(argv[3]);\n  host_udp_port = (unsigned int)atoi(argv[7]);\n\n  // get IP addresses and netmask\n  fpga_ip_address = argv[2];\n  fpga_netmask = argv[4];\n  host_ip_address = argv[6];\n\n  // parse number of packets (optional arg)\n  if (argc > 8) {\n    packets = atoi(argv[8]);\n  }\n\n  printf(\"\\n\");\n  printf(\"FPGA MAC Address: %012lx\\n\", fpga_mac_adr);\n  printf(\"FPGA IP Address:  %s\\n\", fpga_ip_address);\n  printf(\"FPGA UDP Port:    %d\\n\", fpga_udp_port);\n  printf(\"FPGA Netmask:     %s\\n\", fpga_netmask);\n  printf(\"Host MAC Address: %012lx\\n\", host_mac_adr);\n  printf(\"Host IP Address:  %s\\n\", host_ip_address);\n  printf(\"Host UDP Port:    %d\\n\", host_udp_port);\n  printf(\"Packets:          %zu\\n\", packets);\n  printf(\"\\n\");\n\n  // set up SYCL queue\n  ext::intel::fpga_selector device_selector;\n  queue q(device_selector);\n\n  // input and output packet words\n  const size_t total_elements = kWordsPerPacket * packets;\n  std::vector<WordType> input(total_elements);\n  std::vector<WordType> output(total_elements);\n\n  // fill input, set output\n  std::iota(input.begin(), input.end(), 0);\n  std::fill(output.begin(), output.end(), 0);\n\n  // allocate aligned memory for input and output data\n  // total bytes including the 2-byte header per packet\n  unsigned char *input_data = AllocatePackets(packets);\n  unsigned char *output_data = AllocatePackets(packets);\n\n  // prepare data to be transferred, added check header 0xABCD, reset output\n  std::cout << \"Creating packets from input data\" << std::endl;\n  ToPackets(input_data, input.data(), total_elements);\n\n  // these are used to track the latency of each packet\n  std::vector<high_resolution_clock::time_point> time_in(packets);\n  std::vector<high_resolution_clock::time_point> time_out(packets);\n\n  // start the main kernel\n  std::cout << \"Starting processing kernel on the FPGA\" << std::endl;\n  auto kernel_event = SubmitLoopbackKernel<ReadIOPipe, WriteIOPipe>(q);\n\n  // Here, we start the noop kernel and wait for it to finish.\n  // By waiting on the finish we assure that the FPGA has been programmed with\n  // the image and the setting of CSRs SetupFPGA will not be undone with by the\n  // runtime reprogramming the FPGA.\n  std::cout << \"Starting and waiting on Noop kernel to ensure \"\n            << \"that the FPGA is programmed \\n\";\n  SubmitNoopKernel(q).wait();\n\n  // Setup CSRs on FPGA (this function is in UDP.hpp)\n  // NOTE: this must be done AFTER programming the FPGA, which happens\n  // when the kernel is launched (if it is not already programmed)\n  SetupFPGA(fpga_mac_adr, fpga_ip_address, fpga_udp_port, fpga_netmask,\n           host_mac_adr, host_ip_address, host_udp_port);\n  std::this_thread::sleep_for(10ms);\n\n  // Start the receiver\n  std::cout << \"Starting receiver thread\" << std::endl;\n  std::thread receiver_thread([&] {\n    std::this_thread::sleep_for(20ms);\n    std::cout << \"Receiver running on CPU \" << sched_getcpu() << \"\\n\";\n    UDPReceiver(host_ip_address, fpga_udp_port, output_data, packets,\n                time_out.data());\n  });\n\n  // pin the receiver to core 1\n  if (PinThreadToCPU(receiver_thread, 1) != 0) {\n    std::cerr << \"ERROR: could not pin receiver thread to core 1\\n\";\n  }\n\n  // give some time for the receiever to start\n  std::this_thread::sleep_for(10ms);\n\n  // Start the sender\n  std::cout << \"Starting sender thread\" << std::endl;\n  std::thread sender_thread([&] {\n    std::this_thread::sleep_for(20ms);\n    std::cout << \"Sender running on CPU \" << sched_getcpu() << \"\\n\";\n    UDPSender(fpga_ip_address, host_udp_port, input_data, packets,\n              time_in.data());\n  });\n\n  // pin the sender to core 3\n  if (PinThreadToCPU(sender_thread, 3) != 0) {\n    std::cerr << \"ERROR: could not pin sender thread to core 3\\n\";\n  }\n\n  // wait for sender and receiver threads to finish\n  sender_thread.join();\n  receiver_thread.join();\n\n  // DON'T wait for kernel to finish, since it is an infinite loop\n  // kernel_event.wait();\n\n  // compute average latency (ignore the first couple of packets)\n  double avg_latency = 0.0;\n  constexpr size_t kWarmupPackets = 8;\n  for (size_t i = kWarmupPackets; i < packets; i++) {\n    duration<double, std::milli> diff(time_out[i] - time_in[i]);\n    avg_latency += diff.count();\n  }\n  avg_latency /= (packets - kWarmupPackets);\n  std::cout << \"Average end-to-end packet latency: \" << avg_latency << \" ms\\n\";\n\n  // convert the output bytes to data (drop the headers)\n  std::cout << \"Getting output data from packets\" << std::endl;\n  FromPackets(output_data, output.data(), total_elements);\n\n  // validate results\n  bool passed = true;\n  for (size_t i = 0; i < total_elements; i++) {\n    if (output[i] != input[i]) {\n      std::cerr << \"ERROR: output mismatch at index \" << i << \", \" << output[i]\n                << \" != \" << input[i] << \" (output != input)\\n\";\n      passed = false;\n    }\n  }\n\n  // Custom free function unpins and frees memory\n  FreePackets(input_data, packets);\n  FreePackets(output_data, packets);\n\n  if (passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n"
    },
    {
        "label": "qri_demo.cpp",
        "data": "#include <cmath>\n#include <sycl/sycl.hpp>\n#include <chrono>\n#include <iomanip>\n#include <list>\n#include <sycl/ext/intel/ac_types/ac_complex.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\n#include \"qri.hpp\"\n\n#ifdef FPGA_SIMULATOR\n#define ROWS_COMPONENT_V 8\n#define COLS_COMPONENT_V 8\n#else\n#define ROWS_COMPONENT_V ROWS_COMPONENT\n#define COLS_COMPONENT_V COLS_COMPONENT\n#endif\n\n/*\n  COMPLEX, COLS_COMPONENT, ROWS_COMPONENT, FIXED_ITERATIONS_QRD and\n  FIXED_ITERATIONS_QRI are defined by the build system.\n  Depending on the value of COMPLEX, the real or complex QR based matrix\n  inversion function (QRI) is defined.\n\n  Each matrix (input and output) are represented using vectors and are\n  interpreted in a column fashion (transposed).\n\n  Function arguments:\n  - a_matrix:    The input matrix to be inverted.\n                Interpreted as a transposed matrix.\n  - inv_matrix:  The output matrix. The function will overwrite this matrix.\n                Will contain the inverse of a_matrix.\n  - q:          The device queue.\n  - matrices:   The number of matrices to be processed.\n                The input matrices are read sequentially from the a_matrix\n                vector.\n  - repetitions: The number of repetitions of the computation to execute.\n                (for performance evaluation)\n*/\n#if COMPLEX == 0\n// Real single precision floating-point QR based inversion\nvoid QRI(std::vector<float> &a_matrix, std::vector<float> &inv_matrix,\n         sycl::queue &q, size_t matrices, size_t repetitions) {\n  constexpr bool is_complex = false;\n  QRIImpl<COLS_COMPONENT_V, ROWS_COMPONENT_V, FIXED_ITERATIONS_QRD,\n           FIXED_ITERATIONS_QRI, is_complex, float>(a_matrix, inv_matrix, q,\n                                                   matrices, repetitions);\n}\n#else\n// Complex single precision floating-point QR based inversion\nvoid QRI(std::vector<ac_complex<float> > &a_matrix,\n         std::vector<ac_complex<float> > &inv_matrix, sycl::queue &q,\n         size_t matrices, size_t repetitions) {\n  constexpr bool is_complex = true;\n  QRIImpl<COLS_COMPONENT_V, ROWS_COMPONENT_V, FIXED_ITERATIONS_QRD,\n           FIXED_ITERATIONS_QRI, is_complex, float>(a_matrix, inv_matrix, q,\n                                                   matrices, repetitions);\n}\n#endif\n\n/*\n  Returns a random floating-point value between min and max\n*/\nfloat RandomValueInInterval(float min, float max) {\n  return min + static_cast<float>(rand()) /\n                   (static_cast<float>(RAND_MAX) / (max - min));\n}\n\n/*\n  returns if both the real and complex parts of the given ac_complex\n  value are finite\n*/\nbool IsFinite(ac_complex<float> val) {\n  return std::isfinite(val.r()) && std::isfinite(val.i());\n}\n\n/*\n  returns if the given value is finite\n*/\nbool IsFinite(float val) { return std::isfinite(val); }\n\n/*\n  Generate a random matrix M with a given epsilon such that\n  cond(M, inf) <= (1+epsilon)/(1-epsilon)\n  This is helpful as having a condition number with infinite norm close to 1\n  reduces the numerical instability of the matrix inversion.\n  Provided an epsilon value, this function populates the output vector with\n  a matrix in a row fashion.\n\n  Algorithm courtesy of Carl Christian Kjelgaard Mikkelsen (spock@cs.umu.se)\n\n  Matlab code snipet this function reimplements in C++:\n\n    function [A, B]=myDiagonal(m,epsilon)\n\n    % Returns a matrix that is diagonally dominant by rows\n    %\n    % CALL SEQUENCE:\n    %    [A, B]=ccDiagonally(m, epsilon)\n    %\n    % INPUT:\n    %    m        the dimension\n    %    epsilon  the dominance factor epsilon in (0,1]\n    %\n    % OUTPUT:\n    %    A        a matrix which is strictly diagonally domimant by rows\n    %    B        B = D\\A, where D is the diagonal of A\n    %\n    % The main purpose of this function is to construct test matrices\n    % for, say, Gaussian elimination with no pivoting.\n    %\n    % The matrix A is not necessarily well-conditioned, but\n    % the infinity norm condition number of the matrix B is bounded by\n    %\n    %                  (1+epsilon)/(1 - epsilon)\n\n    % PROGRAMMING by Carl Christian Kjelgaard Mikkelsen (spock@cs.umu.se)\n    %   2021-10-21  Initial programming and testing.\n\n    % Generate a random matrix\n    R=rand(m,m)-rand(m,m);\n\n    % Eliminate the diagonal\n    D=diag(diag(R)); R=R-D;\n\n    % Measure the weight of the off diagonal entries\n    w=abs(R)*ones(m,1);\n\n    % Construct the new diagonal elements\n    d=w/epsilon;\n\n    % Construct the matrix which is diagonally dominant\n    A=R+diag(d);\n\n    % Do the diagonal scaling\n    B=diag(diag(A))\\A;\n*/\ntemplate <int size, typename T>\nvoid GenerateMatrixWithCondititionNumber(float epsilon,\n                                         std::vector<T> &output) {\n  // Random min and max values for the random floating-point value generation\n  constexpr float kRandomMin = 0;\n  constexpr float kRandomMax = 1;\n\n  // Generate a random matrix R with diagonal elements set to 0\n  // and measure the weights of the off diagonal entries\n  std::vector<T> r, weights;\n  r.resize(size * size);\n  weights.resize(size);\n  for (int row = 0; row < size; row++) {\n    weights[row] = {0};\n    for (int col = 0; col < size; col++) {\n      if (col != row) {\n        float random1 = RandomValueInInterval(kRandomMin, kRandomMax);\n        T elem;\n#if COMPLEX == 1\n        float random1I = RandomValueInInterval(kRandomMin, kRandomMax);\n        elem = {random1, random1I};\n        r[row * size + col] = elem;\n#else\n        elem = random1;\n        r[row * size + col] = elem;\n#endif\n        weights[row] += elem;\n      }\n    }\n\n    // Construct the new diagonal element\n    weights[row] /= epsilon;\n    r[row * size + row] = weights[row];\n  }\n\n  // Perform the diagonal scaling by solving:\n  // diag(diag(A))*output = A\n  for (int row = 0; row < size; row++) {\n    for (int col = 0; col < size; col++) {\n      output[row * size + col] = r[row * size + col] / r[row * size + row];\n    }\n  }\n}\n\nint main(int argc, char *argv[]) {\n  constexpr size_t kRandomSeed = 1138;\n  constexpr size_t kRows = ROWS_COMPONENT_V;\n  constexpr size_t kColumns = COLS_COMPONENT_V;\n  constexpr size_t kAMatrixSize = kRows * kColumns;\n  constexpr size_t kInverseMatrixSize = kRows * kColumns;\n  constexpr bool kComplex = COMPLEX != 0;\n\n#if defined(FPGA_SIMULATOR)\n  constexpr size_t kMatricesToInvert = 1;\n#else\n  constexpr size_t kMatricesToInvert = 8;\n#endif\n\n  // Get the number of times we want to repeat the inversion\n  // from the command line.\n#if defined(FPGA_EMULATOR)\n  int repetitions = argc > 1 ? atoi(argv[1]) : 16;\n#elif defined(FPGA_SIMULATOR)\n  int repetitions = argc > 1 ? atoi(argv[1]) : 1;\n#else\n  int repetitions = argc > 1 ? atoi(argv[1]) : 6553600;\n#endif\n  if (repetitions < 1) {\n    std::cout << \"Number of repetitions given is lower that 1.\" << std::endl;\n    std::cout << \"The decomposition must occur at least 1 time.\" << std::endl;\n    std::cout << \"Increase the number of repetitions (e.g. 16).\" << std::endl;\n    return 1;\n  }\n\n  try {\n\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // Enable the queue profiling to time the execution\n    sycl::property_list\n                    queue_properties{sycl::property::queue::enable_profiling()};\n    sycl::queue q = sycl::queue(selector,\n                                fpga_tools::exception_handler,\n                                queue_properties);\n\n    sycl::device device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Select a type for this compile depending on the value of COMPLEX\n    using TF = std::conditional_t<kComplex, ac_complex<float>, float>;\n    // Select a type for computing the inverse in the testbench using a more\n    // precise format than the kernel\n    using TD = std::conditional_t<kComplex, ac_complex<double>, double>;\n\n    // Create vectors to hold all the input and output matrices\n    std::vector<TF> a;\n    std::vector<TF> inv_matrix;\n    std::vector<TF> precomputed_inv_matrix;\n\n    a.resize(kMatricesToInvert * kAMatrixSize);\n    inv_matrix.resize(kMatricesToInvert * kInverseMatrixSize);\n    precomputed_inv_matrix.resize(kMatricesToInvert * kInverseMatrixSize);\n\n    std::cout << \"Generating \" << kMatricesToInvert << \" random \";\n    if constexpr (kComplex) {\n      std::cout << \"complex \";\n    } else {\n      std::cout << \"real \";\n    }\n    std::cout << \"matri\" << ((kMatricesToInvert == 1) ? \"x \" : \"ces \")\n              << \"of size \"\n              << kRows << \"x\" << kColumns << \" \" << std::endl;\n\n    // Generate the random input matrices and precompute their inverse\n    srand(kRandomSeed);\n    for (size_t i = 0; i < kMatricesToInvert; i++) {\n      std::vector<TF> random_matrix;\n      random_matrix.resize(kAMatrixSize);\n      // Setting an epsilon of 0.5 ensures that the inverse matrix will have\n      // a condition number using the infinite norm lower than 1.5/0.5 = 3\n      float epsilon = 0.5;\n      GenerateMatrixWithCondititionNumber<kRows>(epsilon, random_matrix);\n\n      // Copy the generated matrix in the A vector\n      for (size_t row = 0; row < kRows; row++) {\n        for (size_t col = 0; col < kColumns; col++) {\n          a[i * kAMatrixSize + col * kRows + row] =\n              random_matrix[row * kColumns + col];\n        }\n      }\n\n      // Precompute the inverse of A using the Gaussian elimination\n      // A copy of A that will be modified\n      TD a_copy[kColumns][kRows];\n      // The inverse matrix that will be iteratively constructed starting from\n      // the identity matrix\n      TD inverse[kColumns][kRows];\n\n      // Copy A in a_copy and set \"inverse\" to the identity matrix\n      for (size_t row = 0; row < kRows; row++) {\n        for (size_t col = 0; col < kColumns; col++) {\n          if (row == col) {\n            inverse[row][col] = {1.0};\n          } else {\n            inverse[row][col] = {0.0};\n          }\n          a_copy[row][col] = random_matrix[row * kColumns + col];\n        }\n      }\n\n      // If we can't find a solution using the Gaussian elimination,\n      // we may give up on this matrix and generate another one\n      bool give_up = false;\n\n      // Perform the Gaussian elimination\n      for (int row = 0; row < kRows; row++) {\n        // Find the next pivot\n        auto pivot = a_copy[row][row];\n\n        // If the pivot is zero, we need to swap the current row with\n        // another row that would give a non-zero pivot.\n        bool pivot_is_zero = pivot == 0.0 || pivot == -0.0;\n        if (pivot_is_zero) {\n          // Find an alternate row to use for pivoting\n          for (int next_row = row + 1; next_row < kRows; next_row++) {\n            TD potential_pivot = a_copy[next_row][row];\n            bool potential_pivot_is_zero =\n                potential_pivot == 0.0 || potential_pivot == -0.0;\n            // row can be used to swap\n            if (!potential_pivot_is_zero) {\n              // Swap the two rows\n              for (int j = 0; j < kColumns; j++) {\n                auto tmp = a_copy[row][j];\n                a_copy[row][j] = a_copy[next_row][j];\n                a_copy[next_row][j] = tmp;\n\n                tmp = inverse[row][j];\n                inverse[row][j] = inverse[next_row][j];\n                inverse[next_row][j] = tmp;\n              }\n\n              // The swap was successful, stop searching for a row to swap with\n              break;\n            }\n          }\n\n          // Get the new pivot\n          pivot = a_copy[row][row];\n\n          // If the swapping was unsuccessful are the new pivot is 0,\n          // give up on this matrix generate another one\n          give_up = pivot == 0.0 || pivot == -0.0;\n          if (give_up) {\n            break;\n          }\n        }\n\n        // Divide the current row by the pivot value\n        for (int k = 0; k < kColumns; k++) {\n          a_copy[row][k] = a_copy[row][k] / pivot;\n          inverse[row][k] = inverse[row][k] / pivot;\n        }\n\n        // Eliminate the current row in all other rows\n        for (int row_to_eliminate = kRows - 1; row_to_eliminate >= 0;\n             row_to_eliminate--) {\n          if (row_to_eliminate == row) {\n            continue;\n          }\n\n          auto factor = a_copy[row_to_eliminate][row];\n          for (int k = 0; k < kColumns; k++) {\n            if (k == row) {\n              a_copy[row_to_eliminate][k] = \n                  a_copy[row_to_eliminate][k] - factor;\n            } else {\n              a_copy[row_to_eliminate][k] =\n                  a_copy[row_to_eliminate][k] - (a_copy[row][k] * factor);\n            }\n            inverse[row_to_eliminate][k] =\n                inverse[row_to_eliminate][k] - (inverse[row][k] * factor);\n          }\n        }\n      }\n\n      // Compute the norm inf of both the input and the inverse matrices\n      // to compute the condition number and verify that it is lower than the\n      // expected threshold\n      double norm_inf_a = 0.0;\n      double norm_inf_inverse = 0.0;\n      for (size_t row = 0; row < kRows; row++) {\n        // Compute the norm inf of the current row on both matrices\n        double norm_current_row_of_a = 0.0;\n        double norm_current_row_of_inverse = 0.0;\n        for (size_t col = 0; col < kColumns; col++) {\n          norm_current_row_of_a += abs(random_matrix[row * kColumns + col]);\n          norm_current_row_of_inverse += abs(inverse[row][col]);\n        }\n\n        // Update the norm inf of both matrices if the norm inf of the current\n        // row is the new max\n        if (norm_current_row_of_a > norm_inf_a) {\n          norm_inf_a = norm_current_row_of_a;\n        }\n        if (norm_current_row_of_inverse > norm_inf_inverse) {\n          norm_inf_inverse = norm_current_row_of_inverse;\n        }\n      }\n\n      // Copy the current inverse matrix in the precomputed_inv_matrix vector\n      for (size_t row = 0; row < kRows; row++) {\n        for (size_t col = 0; col < kColumns; col++) {\n          // If any of the element in not finite, give up on this matrix\n          if (!IsFinite(inverse[row][col])) {\n            give_up = true;\n          } else {\n            precomputed_inv_matrix[i * kAMatrixSize + row * kColumns + col] =\n                inverse[row][col];\n          }\n        }\n      }\n\n      // Compute the condition number\n      double condition_number = norm_inf_a * norm_inf_inverse;\n      double expected_conditionNumber = (1 + epsilon) / (1 - epsilon);\n\n      // Regenerate this matrix if:\n      // - the condition number is higher than the expected one\n      // - we gave up earlier\n      if (condition_number > expected_conditionNumber || give_up) {\n        i--;\n      }\n#ifdef DEBUG\n      else {\n        std::cout << \"A matrix\" << std::endl;\n        for (size_t row = 0; row < kRows; row++) {\n          for (size_t col = 0; col < kColumns; col++) {\n            std::cout << a[i * kAMatrixSize + col * kColumns + row] << \" \";\n          }\n          std::cout << std::endl;\n        }\n        std::cout << \"norm_inf_a \" << norm_inf_a << std::endl;\n        std::cout << \"norm_inf_inverse \" << norm_inf_inverse << std::endl;\n        std::cout << \"condition_number \" << condition_number << std::endl;\n      }\n#endif\n    }\n\n    std::cout << \"Running QR inversion of \" << kMatricesToInvert << \" matri\"\n              << ((kMatricesToInvert == 1) ? \"x \" : \"ces \")\n              << repetitions << \" time\"\n              << ((repetitions > 1) ? \"s\" : \"\") \n              << std::endl;\n\n    // Launch the compute kernel\n    QRI(a, inv_matrix, q, kMatricesToInvert, repetitions);\n\n    // Count the number of errors found for this matrix\n    int error_count = 0;\n    // Keep track of the max difference between the precomputed matrix using the\n    // Gaussian elimination on the double datatype and the kernel computed\n    // inverse matrix using a QR based algorithm with the float datatype.\n    double max_diff_between_soft_and_hard = 0.0;\n\n    // For output post-processing (OP)\n    TF inv_matrix_op[kRows][kColumns];\n\n    // Floating-point error threshold value at which we decide that the design\n    // computed an incorrect value\n    constexpr float kErrorThreshold = 1e-4;\n\n    std::cout << \"Verifying results... \";\n    for (int matrix = 0; matrix < kMatricesToInvert; matrix++) {\n\n      // Read the inverse matrix from the output vector to inv_matrix_op\n      size_t idx = 0;\n      for (size_t j = 0; j < kColumns; j++) {\n        for (size_t i = 0; i < kRows; i++) {\n          inv_matrix_op[j][i] = inv_matrix[matrix * kInverseMatrixSize + idx];\n          idx++;\n        }\n      }\n\n#ifdef DEBUG\n      std::cout << \"Kernel inverse\" << std::endl;\n      for (int row = 0; row < kRows; row++) {\n        for (int col = 0; col < kColumns; col++) {\n          std::cout << inv_matrix_op[row][col] << \" \";\n        }\n        std::cout << std::endl;\n      }\n\n      std::cout << \"Precomputed inverse\" << std::endl;\n      for (int row = 0; row < kRows; row++) {\n        for (int col = 0; col < kColumns; col++) {\n          std::cout << precomputed_inv_matrix[matrix * kAMatrixSize +\n                                            row * kColumns + col]\n                    << \" \";\n        }\n        std::cout << std::endl;\n      }\n#endif\n\n      // Keep track of the max difference between the precomputed inverse and\n      // the kernel inverse\n      double max_diff = 0.0;\n\n#if COMPLEX == 1\n      for (size_t row = 0; row < kRows; row++) {\n        for (size_t col = 0; col < kColumns; col++) {\n          double diff_r = abs(\n              inv_matrix_op[row][col].r() -\n      precomputed_inv_matrix[matrix * kAMatrixSize + row * kColumns + col].r());\n\n          double diff_i = abs(\n              inv_matrix_op[row][col].i() -\n      precomputed_inv_matrix[matrix * kAMatrixSize + row * kColumns + col].i());\n\n          if (!std::isfinite(diff_r) || !std::isfinite(diff_r)) {\n            error_count++;\n          }\n\n          if (diff_r > max_diff) {\n            max_diff = diff_r;\n          }\n          if (diff_i > max_diff) {\n            max_diff = diff_i;\n          }\n\n          if (diff_r > kErrorThreshold) {\n            error_count++;\n          }\n          if (diff_i > kErrorThreshold) {\n            error_count++;\n          }\n        }\n      }\n#else\n      for (size_t i = 0; i < kRows; i++) {\n        for (size_t j = 0; j < kColumns; j++) {\n          double diff = abs(\n              inv_matrix_op[i][j] -\n              precomputed_inv_matrix[matrix * kAMatrixSize + i * kColumns + j]);\n\n          if (!std::isfinite(diff)) {\n            error_count++;\n          }\n\n          if (diff > max_diff) {\n            max_diff = diff;\n          }\n\n          if (diff > kErrorThreshold) {\n            error_count++;\n          }\n        }\n      }\n#endif\n\n      // Update the max diff\n      if (max_diff > max_diff_between_soft_and_hard) {\n        max_diff_between_soft_and_hard = max_diff;\n      }\n\n      // If an error was found, stop checking matrices\n      if (error_count > 0) {\n        break;\n      }\n    }  // end of matrix\n\n    if (error_count > 0) {\n      std::cout << std::endl << \"FAILED\" << std::endl;\n      std::cout << std::endl\n                << \"!!!!!!!!!!!!!! \" << error_count << \" errors\" << std::endl;\n      std::cout << \"Max difference between the precomputed inverse and the \"\n                << \"kernel value: \" << max_diff_between_soft_and_hard \n                << std::endl;\n      return 1;\n    }\n\n    std::cout << std::endl << \"PASSED\" << std::endl;\n    return 0;\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::cerr << \"   If you are targeting an FPGA hardware, \"\n                 \"ensure that your system is plugged to an FPGA board that is \"\n                 \"set up correctly\"\n              << std::endl;\n    std::cerr << \"   If you are targeting the FPGA emulator, compile with \"\n                 \"-DFPGA_EMULATOR\"\n              << std::endl;\n\n    std::terminate();\n  } catch (std::bad_alloc const &e) {\n    std::cerr << \"Caught a memory allocation exception on the host: \"\n              << e.what() << std::endl;\n    std::cerr << \"   You can reduce the memory requirement by reducing the \"\n                 \"number of matrices generated. Specify a smaller number when \"\n                 \"running the executable.\"\n              << std::endl;\n    std::cerr << \"   In this run, more than \"\n              << (((long long)kMatricesToInvert \n                * (kAMatrixSize + kInverseMatrixSize) \n                * sizeof(float)) / pow(2, 30))\n              << \" GBs of memory was requested for \" << kMatricesToInvert\n              << \" matrices, each of size \" << kRows << \" x \" << kColumns\n              << std::endl;\n    std::terminate();\n  }\n}\n"
    },
    {
        "label": "double_buffering.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <cmath>\n#include <iomanip>\n#include <random>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// For the system_profiling tutorial, we execute the kernel only a few times.\n// This makes it easier to examine the generated profiling graphs.\n// Note that the performance advantage of double buffering is more apparent on\n// FPGA hardware with a larger number of kernel invocations.\n\n// kTimes = # times to execute the kernel. kTimes must be >= 2\n// kSize = # of floats to process on each kernel execution.\n#if defined(FPGA_EMULATOR)\nconstexpr int kTimes = 3;\nconstexpr int kSize = 4096;\n#elif defined(FPGA_SIMULATOR)\nconstexpr int kTimes = 3;\nconstexpr int kSize = 4096;\n#else\nconstexpr int kTimes = 3;  // originally 100\nconstexpr int kSize = 262144;\n#endif\n\n// Kernel executes a power function (base^kPow). Must be\n// >= 2. Can increase this to increase kernel execution\n// time, but ProcessOutput() time will also increase.\nconstexpr int kPow = 20;\n\n// Number of iterations through the main loop\nconstexpr int kNumRuns = 2;\n\nbool pass = true;\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization report.\nclass SimpleVpow;\n\n/*  Kernel function.\n    Performs buffer_b[i] = buffer_a[i] ** pow\n    Only supports pow >= 2.\n    This kernel is not meant to be an optimal implementation of the power\n   operation -- it's just a sample kernel for this tutorial whose execution time\n   is easily controlled via the pow parameter. SYCL buffers are created\n   externally and passed in by reference to control (external to this function)\n   when the buffers are destructed. The destructor causes a blocking buffer\n   transfer from device to host and double buffering requires us to not block\n   here (because we need to launch another kernel). So we only want this\n   transfer to occur at the end of overall execution, not at the end of each\n   individual kernel execution.\n*/\nvoid SimplePow(sycl::queue &q, buffer<float, 1> &buffer_a,\n               buffer<float, 1> &buffer_b, event &e) {\n  // Submit to the queue and execute the kernel\n  e = q.submit([&](handler &h) {\n    // Get kernel access to the buffers\n    accessor accessor_a(buffer_a, h, read_only);\n    accessor accessor_b(buffer_b, h, write_only, no_init);\n\n    const int num = kSize;\n    assert(kPow >= 2);\n    const int p = kPow - 1;  // Assumes pow >= 2;\n\n    h.single_task<SimpleVpow>([=]() [[intel::kernel_args_restrict]] {\n      for (int j = 0; j < p; j++) {\n        if (j == 0) {\n          for (int i = 0; i < num; i++) {\n            accessor_b[i] = accessor_a[i] * accessor_a[i];\n          }\n        } else {\n          for (int i = 0; i < num; i++) {\n            accessor_b[i] = accessor_b[i] * accessor_a[i];\n          }\n        }\n      }\n    });\n  });\n\n  event update_host_event;\n  update_host_event = q.submit([&](handler &h) {\n    accessor accessor_b(buffer_b, h, read_only);\n    /*\n      Explicitly instruct the SYCL runtime to copy the kernel's output buffer\n      back to the host upon kernel completion. This is not required for\n      functionality since the buffer access in ProcessOutput() also implicitly\n      instructs the runtime to copy the data back. But it should be noted that\n      this buffer access blocks ProcessOutput() until the kernel is complete\n      and the data is copied. In contrast, update_host() instructs the runtime\n      to perform the copy earlier. This allows ProcessOutput() to optionally\n      perform more useful work *before* making the blocking buffer access. Said\n      another way, this allows ProcessOutput() to potentially perform more work\n      in parallel with the runtime's copy operation.\n    */\n    h.update_host(accessor_b);\n  });\n}\n\n// Returns kernel execution time for a given SYCL event from a queue.\nunsigned long SyclGetExecTimeNs(event e) {\n  unsigned long start_time =\n      e.get_profiling_info<info::event_profiling::command_start>();\n  unsigned long end_time = e.get_profiling_info<info::event_profiling::command_end>();\n  return (end_time - start_time);\n}\n\n// Local pow function for verifying results\nfloat MyPow(float input, int pow) {\n  return (pow == 0) ? 1 : input * MyPow(input, pow - 1);\n}\n\n/*  Compares kernel output against expected output. Only compares part of the\n   output so that this method completes quickly. This is done\n   intentionally/artificially keep host-processing time shorter than kernel\n   execution time. Grabs kernel output data from its SYCL buffer. Reading from\n   this buffer is a blocking operation that will block on the kernel completing.\n    Queries and records execution time of the kernel that just completed. This\n   is a natural place to do this because ProcessOutput() is blocked on kernel\n   completion.\n*/\nvoid ProcessOutput(buffer<float, 1> &input_buf, buffer<float, 1> &output_buf,\n                   int exec_number, event e,\n                   unsigned long &total_kernel_time_per_slot) {\n  host_accessor input_buf_acc(input_buf, read_only);\n  host_accessor output_buf_acc(output_buf, read_only);\n  int num_errors = 0;\n  int num_errors_to_print = 10;\n\n  // Max fractional difference between FPGA pow result and CPU pow result\n  // Anything greater than this will be considered an error\n  constexpr double epsilon = 0.01;\n\n  /*  The use of update_host() in the kernel function allows for additional\n     host-side operations to be performed here, in parallel with the buffer copy\n     operation from device to host, before the blocking access to the output\n     buffer is made via output_buf_acc[]. To be clear, no real operations are\n     done here and this is just a note that this is the place\n      where you *could* do it. */\n  for (int i = 0; i < kSize / 8; i++) {\n    const double expected_value = MyPow(input_buf_acc[i], kPow);\n    const bool out_invalid =\n        std::abs(output_buf_acc[i] - expected_value) / expected_value > epsilon;\n    if ((num_errors < num_errors_to_print) && out_invalid) {\n      if (num_errors == 0) {\n        pass = false;\n        std::cout << \"Verification failed on kernel execution # \" << exec_number\n                  << \". Showing up to \" << num_errors_to_print\n                  << \" mismatches.\\n\";\n      }\n      std::cout << \"Verification failed on kernel execution # \" << exec_number\n                << \", at element \" << i << \". Expected \" << std::fixed\n                << std::setprecision(16) << expected_value << \" but got \"\n                << output_buf_acc[i] << \"\\n\";\n      num_errors++;\n    }\n  }\n\n  // At this point we know the kernel has completed,\n  // so can query the profiling data.\n  total_kernel_time_per_slot += SyclGetExecTimeNs(e);\n}\n\n/*\n    Generates input data for the next kernel execution. Only fills part of the\n   buffer so that this method completes quickly. This is done\n   intentionally/artificially keep host-processing time shorter than kernel\n   execution time. Writes the data into the associated SYCL buffer. The write\n   will block until the previous kernel execution, that is using this buffer,\n   completes.\n*/\nvoid ProcessInput(buffer<float, 1> &buf) {\n  // We are generating completely new input data, so can use the no_init property\n  // here to indicate we don't care about the SYCL buffer's current contents.\n  host_accessor buf_acc(buf, write_only, no_init);\n\n  // RNG seed\n  auto seed = std::chrono::system_clock::now().time_since_epoch().count();\n\n  // RNG engine\n  std::default_random_engine dre(seed);\n\n  // generate random numbers between 1 and 2\n  std::uniform_real_distribution<float> di(1.0f, 2.0f);\n\n  // Randomly generate a start value and increment from there.\n  // Compared to randomly generating every value, this is done to\n  // speed up this function a bit.\n  float start_val = di(dre);\n\n  for (int i = 0; i < kSize / 8; i++) {\n    buf_acc[i] = start_val;\n    start_val++;\n  }\n}\n\nint main() {\n// Create queue, get platform and device\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n#ifndef FPGA_HARDWARE\n  std::cout << \"\\nEmulator and simulator outputs do not demonstrate \"\n               \"true hardware performance. The design may need to run \"\n               \"on actual hardware to observe the performance benefit \"\n               \"of the optimization exemplified in this tutorial.\\n\\n\";\n#endif\n\n\n  try {\n    auto prop_list = property_list{property::queue::enable_profiling()};\n\n    sycl::queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    platform platform = q.get_context().get_platform();\n    device device = q.get_device();\n    std::cout << \"Platform name: \"\n              << platform.get_info<info::platform::name>().c_str() << \"\\n\";\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n    std::cout << \"Executing kernel \" << kTimes << \" times in each round.\\n\\n\";\n\n    // Create a vector to store the input/output SYCL buffers\n    std::vector<buffer<float, 1>> input_buf;\n    std::vector<buffer<float, 1>> output_buf;\n\n    // SYCL events for each kernel launch.\n    event sycl_events[2];\n\n    // In nanoseconds. Total execution time of kernels in a given slot.\n    unsigned long total_kernel_time_per_slot[2];\n\n    // Total execution time of all kernels.\n    unsigned long total_kernel_time = 0;\n\n    // Allocate vectors to store the host-side copies of the input data\n    // Create and allocate the SYCL buffers\n    for (int i = 0; i < 2; i++) {\n      input_buf.push_back(buffer<float, 1>(range<1>(kSize)));\n      output_buf.push_back(buffer<float, 1>(range<1>(kSize)));\n    }\n\n    /*\n      Main loop. This loop runs twice to show the performance difference without\n      and with double buffering.\n    */\n    for (int i = 0; i < kNumRuns; i++) {\n      for (int i = 0; i < 2; i++) {\n        total_kernel_time_per_slot[i] = 0;  // Initialize timers to zero.\n      }\n\n      switch (i) {\n        case 0: {\n          std::cout << \"*** Beginning execution, without double buffering\\n\";\n          break;\n        }\n        case 1: {\n          std::cout << \"*** Beginning execution, with double buffering.\\n\";\n          break;\n        }\n        default: {\n          std::cout << \"*** Beginning execution.\\n\";\n        }\n      }\n\n      // Start the timer. This will include the time to process the input data\n      // for the first 2 kernel executions.\n      auto start = std::chrono::steady_clock::now();\n\n      if (i == 0) {  // Single buffering\n        for (int i = 0; i < kTimes; i++) {\n          // Only print every few iterations, just to limit the prints.\n          if (i % 10 == 0) {\n            std::cout << \"Launching kernel #\" << i << \"\\n\";\n          }\n\n          ProcessInput(input_buf[0]);\n          SimplePow(q, input_buf[0], output_buf[0], sycl_events[0]);\n          ProcessOutput(input_buf[0], output_buf[0], i, sycl_events[0],\n                        total_kernel_time_per_slot[0]);\n        }\n      } else {  // Double buffering\n        // Process input for first 2 kernel launches and queue them. Then block\n        // on processing the output of the first kernel.\n        ProcessInput(input_buf[0]);\n        ProcessInput(input_buf[1]);\n\n        std::cout << \"Launching kernel #0\\n\";\n\n        SimplePow(q, input_buf[0], output_buf[0], sycl_events[0]);\n        for (int i = 1; i < kTimes; i++) {\n          if (i % 10 == 0) {\n            std::cout << \"Launching kernel #\" << i << \"\\n\";\n          }  // Only print every few iterations, just to limit the prints.\n\n          // Launch the next kernel\n          SimplePow(q, input_buf[i % 2], output_buf[i % 2], sycl_events[i % 2]);\n\n          // Process output from previous kernel. This will block on kernel\n          // completion.\n          ProcessOutput(input_buf[(i - 1) % 2], output_buf[(i - 1) % 2], i,\n                        sycl_events[(i - 1) % 2],\n                        total_kernel_time_per_slot[(i - 1) % 2]);\n\n          // Generate input for the next kernel.\n          ProcessInput(input_buf[(i - 1) % 2]);\n        }\n\n        // Process output of the final kernel\n        ProcessOutput(input_buf[(kTimes - 1) % 2], output_buf[(kTimes - 1) % 2],\n                      i, sycl_events[(kTimes - 1) % 2],\n                      total_kernel_time_per_slot[(kTimes - 1) % 2]);\n      }\n\n      // Add up the overall kernel execution time.\n      total_kernel_time = 0;\n      for (int i = 0; i < 2; i++) {\n        total_kernel_time += total_kernel_time_per_slot[i];\n      }\n\n      // Stop the timer.\n      auto end = std::chrono::steady_clock::now();\n      double time_span = std::chrono::duration_cast<std::chrono::duration<double>>(end - start).count();\n\n      std::cout << \"\\nOverall execution time \"\n                << ((i == 0) ? \"without\" : \"with\")\n                << \" double buffering = \" << (unsigned)(time_span * 1000)\n                << \" ms\\n\";\n      std::cout << \"Total kernel-only execution time \"\n                << ((i == 0) ? \"without\" : \"with\") << \" double buffering = \"\n                << (unsigned)(total_kernel_time / 1000000) << \" ms\\n\";\n      std::cout << \"Throughput = \" << std::setprecision(8)\n                << (float)kSize * (float)kTimes * (float)sizeof(float) /\n                       (float)time_span / 1000000\n                << \" MB/s\\n\\n\\n\";\n    }\n    if (pass) {\n      std::cout << \"Verification PASSED\\n\";\n    } else {\n      std::cout << \"Verification FAILED\\n\";\n      return 1;\n    }\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n  return 0;\n}\n"
    },
    {
        "label": "add.cpp",
        "data": "//  Copyright (c) 2023 Intel Corporation\n//  SPDX-License-Identifier: MIT\n\n#include <stdlib.h>\n\n#include <iostream>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// use pipes to write into registers in the CSR address space\nclass OutputPipeID;\n\nusing OutputPipeProps = decltype(sycl::ext::oneapi::experimental::properties(\n    sycl::ext::intel::experimental::protocol<\n        sycl::ext::intel::experimental::protocol_name::avalon_mm>));\n\nusing OutputPipe =\n    sycl::ext::intel::experimental::pipe<OutputPipeID, int, 0, OutputPipeProps>;\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass IDAdder;\n\nstruct AdderKernel {\n  int a;\n  int b;\n\n  void operator()() const {\n    int sum = a + b;\n    OutputPipe::write(sum);\n  }\n};\n\nint main() {\n  bool passed = false;\n\n  try {\n// Use compile-time macros to select either:\n//  - the FPGA emulator device (CPU emulation of the FPGA)\n//  - the FPGA device (a real FPGA)\n//  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    int a = 3;\n    int b = 76;\n\n    int expected_sum = a + b;\n\n    std::cout << \"add two integers using CSR for input.\" << std::endl;\n\n    q.single_task<IDAdder>(AdderKernel{a, b}).wait();\n\n    // verify that outputs are correct\n    passed = true;\n\n    std::cout << \"collect results.\" << std::endl;\n    int calc_add = OutputPipe::read(q);\n\n    std::cout << a << \" + \" << b << \" = \" << calc_add << \", expected \"\n              << expected_sum << \". \" << std::endl;\n\n    if (calc_add != expected_sum) {\n      passed = false;\n    }\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"
    },
    {
        "label": "dynamic_profiler.cpp",
        "data": "/*\n  Please refer to the README file for information on how and why the\n  Intel(r) Dynamic Profiler for DPC++ should be used. This code sample\n  does not explain the tool, rather it is an artificial example that\n  demonstates the sort of code changes the profiler data can guide.\n  The main content of this sample is in the README file.\n*/\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <cmath>\n#include <numeric>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// Two identical pipes to demonstrate the behaviour before\n// and after the design re-format\nusing ProducerToConsumerBeforePipe =\n    ext::intel::pipe<                           // Defined in the SYCL headers.\n        class ProducerConsumerBeforePipe,  // An identifier for the pipe.\n        float,                             // The type of data in the pipe.\n        20>;                               // The capacity of the pipe.\nusing ProducerToConsumerAfterPipe =\n    ext::intel::pipe<class ProducerConsumerAfterPipe, float, 20>;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization report.\nclass ProducerBeforeKernel;\nclass ConsumerBeforeKernel;\nclass ProducerAfterKernel;\nclass ConsumerAfterKernel;\n\n// kSize = # of floats to process on each kernel execution.\n#if defined(FPGA_EMULATOR) or defined(FPGA_SIMULATOR)\nconstexpr int kSize = 64;\n#else\nconstexpr int kSize = 262144;\n#endif\n\n// Number of iterations performed in the consumer kernels\n// This controls the amount of work done by the Consumer.\n// After the optimization, the Producer and Consumer split the work.\nconstexpr int kComplexity1 = 1900;\nconstexpr int kComplexity2 = 2000;\n\n// Perform two stages of processing on the input data.\n// The output of ConsumerWork1 needs to go to the input\n// of ConsumerWork2, so they cannot be done concurrently.\n// These functions are currently doing pointless work, but\n// can be replaced with more useful operations.\nfloat ConsumerWork1(float f) {\n  float output = f;\n  for (int j = 0; j < kComplexity1; j++) {\n    output = 20 * f + j - output;\n  }\n  return output;\n}\n\nfloat ConsumerWork2(float f) {\n  auto output = f;\n  for (int j = 0; j < kComplexity2; j++) {\n    output = output + f * j;\n  }\n  return output;\n}\n\n/////////////////////////////////////////////////////////////\n// Pre-optimization kernel versions\n/////////////////////////////////////////////////////////////\n// The Producer kernel reads data from a SYCL buffer and writes it to\n// a pipe. This transfers the input data from the host to the Consumer kernel\n// that is running concurrently.\n// The Consumer kernel reads data from the pipe, performs the two ConsumerWork\n// operations on the data, and writes the results to the output buffer.\n\nvoid ProducerBefore(queue &q, buffer<float, 1> &buffer_a) {\n  auto e = q.submit([&](handler &h) {\n    // Get kernel access to the buffers\n    accessor a(buffer_a, h, read_only);\n\n    h.single_task<ProducerBeforeKernel>([=]() {\n      for (int i = 0; i < kSize; i++) {\n        ProducerToConsumerBeforePipe::write(a[i]);\n      }\n    });\n  });\n}\n\nvoid ConsumerBefore(queue &q, buffer<float, 1> &buffer_a) {\n  auto e = q.submit([&](handler &h) {\n    // Get kernel access to the buffers\n    accessor a(buffer_a, h, write_only, no_init);\n\n    h.single_task<ConsumerBeforeKernel>([=]() {\n      for (int i = 0; i < kSize; i++) {\n        auto input = ProducerToConsumerBeforePipe::read();\n        auto output = ConsumerWork1(input);\n        output = ConsumerWork2(output);\n        a[i] = output;\n      }\n    });\n  });\n}\n\n/////////////////////////////////////////////////////////////\n// Post-optimization kernel versions\n/////////////////////////////////////////////////////////////\n// The Producer kernel reads data from a SYCL buffer and does\n// ConsumerWork1 on it before giving it to the concurrently\n// running Consumer kernel.\n// The Consumer kernel reads data from the pipe, performs the rest\n// of the work (ConsumerWork2), and writes the results\n// to the output buffer.\n\nvoid ProducerAfter(queue &q, buffer<float, 1> &buffer_a) {\n  auto e = q.submit([&](handler &h) {\n    // Get kernel access to the buffers\n    accessor a(buffer_a, h, read_only);\n\n    h.single_task<ProducerAfterKernel>([=]() {\n      for (int i = 0; i < kSize; i++) {\n        auto input = a[i];\n        auto output = ConsumerWork1(input);\n        ProducerToConsumerAfterPipe::write(output);\n      }\n    });\n  });\n}\n\nvoid ConsumerAfter(queue &q, buffer<float, 1> &buffer_a) {\n  auto e = q.submit([&](handler &h) {\n    // Get kernel access to the buffers\n    accessor a(buffer_a, h, write_only, no_init);\n\n    h.single_task<ConsumerAfterKernel>([=]() {\n      for (int i = 0; i < kSize; i++) {\n        auto buffer1_data = ProducerToConsumerAfterPipe::read();\n        auto output = ConsumerWork2(buffer1_data);\n        a[i] = output;\n      }\n    });\n  });\n}\n\n/////////////////////////////////////////////////////////////\n\n// Compares kernel output against expected output. Only compares part of the\n// output so that this method completes quickly. This is done\n// intentionally/artificially to keep host-processing time shorter than kernel\n// execution time. Grabs kernel output data from its SYCL buffers.\nbool ProcessOutput(buffer<float, 1> &input_buf, buffer<float, 1> &output_buf) {\n  host_accessor input_buf_acc(input_buf, read_only);\n  host_accessor output_buf_acc(output_buf, read_only);\n  int num_errors = 0;\n  int num_errors_to_print = 5;\n  bool pass = true;\n\n  // Max fractional difference between FPGA result and CPU result\n  // Anything greater than this will be considered an error\n  constexpr double epsilon = 0.01;\n\n  for (int i = 0; i < kSize / 8; i++) {\n    auto step1 = ConsumerWork1(input_buf_acc[i]);\n    auto valid_result = ConsumerWork2(step1);\n\n    const bool out_invalid =\n        std::abs((output_buf_acc[i] - valid_result) / valid_result) > epsilon;\n    if ((num_errors < num_errors_to_print) && out_invalid) {\n      if (num_errors == 0) {\n        pass = false;\n        std::cout << \"Verification failed. Showing up to \"\n                  << num_errors_to_print << \" mismatches.\\n\";\n      }\n      std::cout << \"Verification failed on the output buffer, \"\n                << \"at element \" << i << \". Expected \" << valid_result\n                << \" but got \" << output_buf_acc[i] << \"\\n\";\n      num_errors++;\n    }\n  }\n  return pass;\n}\n\nint main() {\n// Create queue, get platform and device\n\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n  std::cout << \"\\nThe Dynamic Profiler cannot be used in the emulator \"\n               \"flow. Please compile to FPGA hardware or simulator flow \"\n               \"to collect dynamic profiling data. \\n\\n\";\n#endif\n\n\n  try {\n    queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    std::vector<float> producer_input(kSize, -1);\n    std::vector<float> consumer_output_before(kSize, -1);\n    std::vector<float> consumer_output_after(kSize, -1);\n\n    // Initialize the input data\n    std::iota(producer_input.begin(), producer_input.end(), 1);\n\n    buffer producer_buffer(producer_input);\n    buffer consumer_buffer_before(consumer_output_before);\n    buffer consumer_buffer_after(consumer_output_after);\n\n    std::cout << \"*** Beginning execution before optimization.\\n\";\n    ProducerBefore(q, producer_buffer);\n    ConsumerBefore(q, consumer_buffer_before);\n    bool pass_before = ProcessOutput(producer_buffer, consumer_buffer_before);\n    if (pass_before) {\n      std::cout << \"Verification PASSED for run before optimization\\n\";\n    }\n\n    std::cout << \"*** Beginning execution after optimization.\\n\";\n    ProducerAfter(q, producer_buffer);\n    ConsumerAfter(q, consumer_buffer_after);\n    bool pass_after = ProcessOutput(producer_buffer, consumer_buffer_after);\n    if (pass_after) {\n      std::cout << \"Verification PASSED for run after optimization\\n\";\n    }\n\n    if (pass_before && pass_after) {\n      std::cout << \"Verification PASSED\\n\";\n    } else {\n      std::cout << \"Verification FAILED\\n\";\n      return 1;\n    }\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n  return 0;\n}\n"
    },
    {
        "label": "add.cpp",
        "data": "//  Copyright (c) 2023 Intel Corporation\n//  SPDX-License-Identifier: MIT\n\n#include <stdlib.h>\n\n#include <iostream>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// use pipes to write into registers in the CSR address space\nclass OutputPipeID;\n\nusing OutputPipeProps = decltype(sycl::ext::oneapi::experimental::properties(\n    sycl::ext::intel::experimental::protocol<\n        sycl::ext::intel::experimental::protocol_name::avalon_mm>));\n\nusing OutputPipe =\n    sycl::ext::intel::experimental::pipe<OutputPipeID, int, 0, OutputPipeProps>;\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass IDAdder;\n\nstruct AdderKernel {\n  int a;\n  int b;\n\n  void operator()() const {\n    int sum = a + b;\n    OutputPipe::write(sum);\n  }\n};\n\nint main() {\n  bool passed = false;\n\n  try {\n// Use compile-time macros to select either:\n//  - the FPGA emulator device (CPU emulation of the FPGA)\n//  - the FPGA device (a real FPGA)\n//  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    int a = 3;\n    int b = 76;\n\n    int expected_sum = a + b;\n\n    std::cout << \"add two integers using CSR for input.\" << std::endl;\n\n    q.single_task<IDAdder>(AdderKernel{a, b}).wait();\n\n    // verify that outputs are correct\n    passed = true;\n\n    std::cout << \"collect results.\" << std::endl;\n    int calc_add = OutputPipe::read(q);\n\n    std::cout << a << \" + \" << b << \" = \" << calc_add << \", expected \"\n              << expected_sum << \". \" << std::endl;\n\n    if (calc_add != expected_sum) {\n      passed = false;\n    }\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"
    },
    {
        "label": "use_library.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/ext/intel/ac_types/ac_int.hpp>\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"lib_rtl.hpp\"\n\n// RTL Library will use the Verilog model during hardware generation, and the\n// c++ model during emulation.\n#include \"exception_handler.hpp\"\n#include <stdint.h>\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization report.\nclass KernelCompute;\nclass KernelComputeRTL;\n\n// Using host pipes to stream data in and out of kernal\n// IDPipeA and IDPipeB will be written to by the host, and then read by the kernel (device)\n// IDPipeC will be written to by the kernel (device), and then read by the host\nclass IDPipeA;\nusing InputPipeA = sycl::ext::intel::experimental::pipe<IDPipeA, uint32_t>;\nclass IDPipeB;\nusing InputPipeB = sycl::ext::intel::experimental::pipe<IDPipeB, uint32_t>;\nclass IDPipeC;\nusing OutputPipeC = sycl::ext::intel::experimental::pipe<IDPipeC, uint64_t>;\n\nclass IDPipeD;\nusing InputPipeD = sycl::ext::intel::experimental::pipe<IDPipeD, uint32_t>;\nclass IDPipeE;\nusing InputPipeE = sycl::ext::intel::experimental::pipe<IDPipeE, uint32_t>;\nclass IDPipeF;\nusing OutputPipeF = sycl::ext::intel::experimental::pipe<IDPipeF, uint64_t>;\n\n// This kernel computes multiplier result by using the C++ '*' operator\ntemplate <typename PipeIn1, typename PipeIn2, typename PipeOut>\nstruct NativeMult27x27 {\n\n  // use a streaming pipelined invocation interface to minimize hardware\n  // overhead\n  auto get(sycl::ext::oneapi::experimental::properties_tag) {\n    return sycl::ext::oneapi::experimental::properties{\n        sycl::ext::intel::experimental::streaming_interface_accept_downstream_stall, \n        sycl::ext::intel::experimental::pipelined<1>};\n  }\n  \n   void operator()() const {\n    MyInt27 a_val = PipeIn1::read();\n    MyInt27 b_val = PipeIn2::read();\n    MyInt54 res =(MyInt54)a_val * b_val;\n    PipeOut::write(res);\n  }\n};\n\n// This kernel computes multiplier result by calling RTL function RtlDSPm27x27u\ntemplate <typename PipeIn1, typename PipeIn2, typename PipeOut>\nstruct RtlMult27x27 {\n\n  // use a streaming pipelined invocation interface to minimize hardware\n  // overhead\n  auto get(sycl::ext::oneapi::experimental::properties_tag) {\n    return sycl::ext::oneapi::experimental::properties{\n        sycl::ext::intel::experimental::streaming_interface_accept_downstream_stall, \n        sycl::ext::intel::experimental::pipelined<1>};\n  }\n  \n  void operator()() const {\n    MyInt27 a_val = PipeIn1::read();\n    MyInt27 b_val = PipeIn2::read();\n    MyInt54 res = RtlDSPm27x27u(a_val, b_val);\n    PipeOut::write(res);\n  }\n};\n\nint main() {\n  uint64_t result_rtl = 0;\n  uint64_t result_native = 0;\n  uint32_t kA = 134217727; // 0x7FFFFFF is the largest possible ac_int<27, false>.\n  uint32_t kB = 100;\n\n  // Select the FPGA emulator (CPU), FPGA simulator, or FPGA device\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n    {\n      // write data to host-to-device pipes\n      InputPipeA::write(q, kA);\n      InputPipeB::write(q, kB);\n      // launch kernel that infers a multiplier automatically\n      q.single_task<KernelCompute>(NativeMult27x27<InputPipeA,InputPipeB,OutputPipeC>{}).wait();\n      // read data from device-to-host pipe\n      result_native = OutputPipeC::read(q);\n    }\n    {\n      // write data to host-to-device pipes\n      InputPipeD::write(q, kA);\n      InputPipeE::write(q, kB);\n      // launch a kernel to that uses a multiplier defined in RTL\n      q.single_task<KernelComputeRTL>(RtlMult27x27<InputPipeD,InputPipeE,OutputPipeF>{}).wait();\n      // read data from device-to-host pipe\n      result_rtl = OutputPipeF::read(q);\n    }\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  // Check the results\n  uint64_t expected_result = (uint64_t ) kA * kB;\n  if (result_native != expected_result) {\n    std::cout << \"FAILED: result native (\" << result_native << \") is incorrect! Expected \" << expected_result << \"\\n\";\n    return -1;\n  }\n  if (result_rtl != expected_result) {\n    std::cout << \"FAILED: result RTL (\" << result_rtl << \") is incorrect! Expected \" << expected_result << \"\\n\";\n    return -1;\n  }\n  std::cout << \"PASSED: result is correct!\\n\";\n  return 0;\n}\n\n"
    },
    {
        "label": "lib_rtl_model.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include \"lib_rtl.hpp\"\n\n// This C++ model is only used during emulation, so it should functionally\n// match the RTL in lib_rtl.v.\n\nSYCL_EXTERNAL extern \"C\" MyInt54 RtlDSPm27x27u (MyInt27 x, MyInt27 y) {\n  return (x * y);\n}\n\n"
    },
    {
        "label": "optimization_targets.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include \"exception_handler.hpp\"\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n#include <vector>\n\nclass Kernel;\n\n#if defined(FPGA_SIMULATOR)\nconstexpr int kInputSize = 10;\n#else\nconstexpr int kInputSize = 1000;\n#endif\n\ntypedef int RGBType;\ntypedef std::vector<RGBType> RGBVec;\ntypedef float GreyType;\ntypedef std::vector<GreyType> GreyVec;\n\n// Return the execution time of the event, in seconds\ndouble GetExecutionTime(const sycl::event &e) {\n  double start_k =\n      e.get_profiling_info<sycl::info::event_profiling::command_start>();\n  double end_k =\n      e.get_profiling_info<sycl::info::event_profiling::command_end>();\n  double kernel_time = (end_k - start_k) * 1e-9; // ns to s\n  return kernel_time;\n}\n\nGreyType Compute(RGBType r, RGBType g, RGBType b) {\n  GreyType output =\n      (GreyType)r * 0.3f + (GreyType)g * 0.59f + (GreyType)b * 0.11f;\n  return output;\n}\n\nvoid RunKernel(const RGBVec &r, const RGBVec &g, const RGBVec &b,\n               GreyVec &out) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    // create the SYCL device queue\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    sycl::device device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    sycl::buffer r_buf(r);\n    sycl::buffer g_buf(g);\n    sycl::buffer b_buf(b);\n    sycl::buffer out_buf(out);\n\n    // submit the kernel\n    auto e = q.submit([&](sycl::handler &h) {\n      sycl::accessor r_acc(r_buf, h, sycl::read_only);\n      sycl::accessor g_acc(g_buf, h, sycl::read_only);\n      sycl::accessor b_acc(b_buf, h, sycl::read_only);\n      sycl::accessor out_acc(out_buf, h, sycl::write_only, sycl::no_init);\n\n      // FPGA-optimized kernel\n      // Using kernel_args_restrict tells the compiler that the input\n      // and output buffers won't alias.\n      h.single_task<Kernel>([=]() [[intel::kernel_args_restrict]] {\n        for (size_t i = 0; i < kInputSize; i++) {\n          out_acc[i] = Compute(r_acc[i], g_acc[i], b_acc[i]);\n        }\n      });\n    });\n\n    double exec_time = GetExecutionTime(e);\n    double inputMB = (kInputSize * sizeof(RGBType)) / (double)(1024 * 1024);\n\n    std::cout << \"Kernel Throughput: \" << (inputMB / exec_time) << \"MB/s\\n\";\n    std::cout << \"Exec Time: \" << exec_time << \"s, InputMB: \" << inputMB\n              << \"MB\\n\";\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}\n\nint main() {\n  // input/output data\n  RGBVec r(kInputSize);\n  RGBVec g(kInputSize);\n  RGBVec b(kInputSize);\n  GreyVec out(kInputSize);\n\n  // generate random input data\n  srand(0);\n  for (size_t i = 0; i < kInputSize; i++) {\n    r[i] = static_cast<RGBType>(rand() % 256);\n    g[i] = static_cast<RGBType>(rand() % 256);\n    b[i] = static_cast<RGBType>(rand() % 256);\n  }\n\n  RunKernel(r, g, b, out);\n\n  bool passed = true;\n\n  // validate results\n  for (size_t i = 0; i < kInputSize; i++) {\n    GreyType golden = Compute(r[i], g[i], b[i]);\n    if (sycl::fabs(out[i] - golden) > 1e-4) {\n      std::cout << \"Result mismatch:\\n\"\n                << \"out[\" << i << \"] = \" << out[i] << \"; golden = \" << golden\n                << '\\n';\n      passed = false;\n    }\n  }\n\n  if (passed) {\n    std::cout << \"PASSED: all kernel results are correct\\n\";\n  } else {\n    std::cout << \"FAILED\\n\";\n  }\n  return passed ? 0 : 1;\n}\n"
    },
    {
        "label": "stall_enable.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <iomanip>\n#include <iostream>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass KernelComputeStallFree;\nclass KernelComputeStallEnable;\n\nconstexpr int kSeed = 0;\nconstexpr int kWork = 25;\nconstexpr int kNumElements = 1000;\nconstexpr int kTotalOps = kNumElements * kWork;\n\ntypedef long WorkType;\ntypedef std::vector<WorkType> WorkVec;\n\nstatic WorkType RealWork(WorkType a, WorkType b) {\n  // This will create a large cluster, which will exaggerate\n  // the effect of the stall-enable cluster.\n#pragma unroll\n  for (size_t j = 0; j < kWork; j++) {\n    if (j & 1)\n      a -= b;\n    else\n      a *= b;\n  }\n  return a;\n}\n\nusing ReadAccessor =\n  accessor<WorkType, 1, access::mode::read, access::target::device>;\nusing WriteAccessor =\n  accessor<WorkType, 1, access::mode::write, access::target::device>;\n\nstatic void Work(const ReadAccessor &vec_a, const ReadAccessor &vec_b,\n                 const WriteAccessor &vec_res) {\n  for (size_t idx = 0; idx < kNumElements; idx += 2) {\n    auto a = vec_a[idx];\n    auto b = vec_b[idx];\n    vec_res[idx] = RealWork(a, b);\n    vec_res[idx+1] = RealWork(b, a);\n  }\n}\n\nvoid DoSomeWork(const WorkVec &vec_a, const WorkVec &vec_b, WorkVec &res) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  double kernel_time = 0.0;\n  try {\n    auto prop_list = property_list{property::queue::enable_profiling()};\n\n    queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    buffer buffer_in_a(vec_a);\n    buffer buffer_in_b(vec_b);\n    buffer buffer_out(res);\n\n    event e = q.submit([&](handler &h) {\n      accessor accessor_vec_a(buffer_in_a, h, read_only);\n      accessor accessor_vec_b(buffer_in_b, h, read_only);\n      accessor accessor_res(buffer_out, h, write_only, no_init);\n\n      // The kernel_args_restrict promises the compiler that this kernel's\n      // accessor arguments won't alias (i.e. non-overlapping memory regions).\n#ifdef STALL_FREE\n        h.single_task<class KernelComputeStallFree>(\n            [=]() [[intel::kernel_args_restrict]] {\n          // Run using a function with stall free clusters\n          Work(accessor_vec_a, accessor_vec_b, accessor_res);\n        });\n#else // STALL_FREE\n        h.single_task<class KernelComputeStallEnable>(\n            [=]() [[intel::kernel_args_restrict,\n                    intel::use_stall_enable_clusters]] {\n          // Run using a function with stall enable clusters\n          Work(accessor_vec_a, accessor_vec_b, accessor_res);\n        });\n#endif // STALL_FREE\n      });\n\n    // Kernel profiling data\n    double start = e.get_profiling_info<info::event_profiling::command_start>();\n    double end = e.get_profiling_info<info::event_profiling::command_end>();\n    // convert nanoseconds to microseconds\n    kernel_time = (double)(end - start) * 1e-3;\n\n  } catch (exception const &exc) {\n    std::cerr << \"Caught synchronous SYCL exception:\\n\" << exc.what() << '\\n';\n    if (exc.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n#ifdef STALL_FREE\n  std::cout << \"Stall free\"\n#else\n  std::cout << \"Stall enable\"\n#endif\n            << \" Kernel -- kernel time : \" << kernel_time << \" microseconds\\n\";\n  std::cout << \"Throughput for kernel: \";\n  std::cout << std::fixed << std::setprecision(0)\n            << (((double)kTotalOps * sizeof(WorkType) * 1e-3f) /\n                (kernel_time * 1e-6f)) << \"KB/s\\n\";\n}\n\nint main() {\n  WorkVec vec_a(kNumElements);\n  WorkVec vec_b(kNumElements);\n  WorkVec vec_output(kNumElements);\n  WorkVec vec_expected(kNumElements);\n\n  // Populate the vectors\n  srand(kSeed);\n  for (size_t i = 0; i < kNumElements; i += 2) {\n    vec_a[i] = static_cast<WorkType>(rand());\n    vec_b[i] = static_cast<WorkType>(rand());\n    vec_expected[i] = RealWork(vec_a[i], vec_b[i]);\n    vec_expected[i+1] = RealWork(vec_b[i], vec_a[i]);\n  }\n\n  DoSomeWork(vec_a, vec_b, vec_output);\n\n  // Correctness check\n  bool passed = true;\n  for (size_t i = 0; i < kNumElements; i++) {\n    auto val = vec_output[i];\n    if (val != vec_expected[i]) {\n      std::cout << \"FAILED: The results are incorrect\\n\"\n                << \"Index \" << i << \": expected: \"\n                << vec_expected[i] << \", result: \" << val\n                << '\\n';\n      passed = false;\n    }\n  }\n\n  if (passed) {\n    std::cout << \"PASSED: The results are correct\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return -1;\n  }\n}\n"
    },
    {
        "label": "annotated_coding.cpp",
        "data": "#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"annotated_class_util.hpp\"\n#include \"exception_handler.hpp\"\n\nconstexpr int kBL1 = 1;\nconstexpr int kAlignment = 32;\nconstexpr int kWidth = 256;\n\n// This type alias groups together all the properties used by the `a` pointer,\n// and can be re-used in the annotated memory allocation in the host code.\n// This syntax works if you have added the `-std=c++20` flag to your compiler\n// command.\nusing annotated_arg_t = sycl::ext::oneapi::experimental::annotated_arg<\n    int *, fpga_tools::properties_t<\n               sycl::ext::intel::experimental::buffer_location<kBL1>,\n               sycl::ext::intel::experimental::dwidth<kWidth>,\n               sycl::ext::oneapi::experimental::alignment<kAlignment>>>;\n\nstruct MyIP {\n  annotated_arg_t a;\n  int size;\n\n  void operator()() const {\n#pragma unroll 8\n    for (int i = 0; i < size; i++) {\n      a[i] *= 2;\n    }\n  }\n};\n\nbool CheckResult(int *arr, int size) {\n  bool passed = true;\n  for (int i = 0; i < size; i++) {\n    int golden = 2 * i;\n    if (arr[i] != golden) {\n      std::cout << \"ERROR! At index: \" << i << \" , expected: \" << golden\n                << \" , found: \" << arr[i] << \"\\n\";\n      passed = false;\n    }\n  }\n  return passed;\n}\n\nbool RunWithUsmMalloc(sycl::queue &q) {\n  // Create and initialize the host arrays\n  constexpr int kN = 8;\n  std::cout\n      << \"using aligned_alloc_shared to allocate a block of shared memory\\n\";\n\n  // The SYCL USM allocation API requires us to explicitly specify\n  // buffer_location and alignment when allocating the host array. Unless you\n  // explicitly define these as named constants in your device code (which is\n  // not very tidy), you may accidentally mis-match these properties between\n  // your host code and device code.\n  int *array_a = sycl::aligned_alloc_shared<int>(\n      kAlignment, kN, q,\n      sycl::ext::intel::experimental::property::usm::buffer_location(kBL1));\n\n  for (int i = 0; i < kN; i++) {\n    array_a[i] = i;\n  }\n\n  q.single_task(MyIP{array_a, kN}).wait();\n  bool passed = CheckResult(array_a, kN);\n  sycl::free(array_a, q);\n  return passed;\n}\n\nbool RunWithAnnotatedAlloc(sycl::queue &q) {\n  // Create and initialize the host arrays\n  constexpr int kN = 8;\n  std::cout << \"using fpga_tools::alloc_annotated to allocate a block of \"\n               \"shared memory\\n\";\n\n  // The \"alloc_annotated\" function extracts the buffer location and alignment\n  // properties from the type alias annotated_arg_t, rather than forcing you to\n  // explicitly define them in your code. This ensures the properties of the\n  // returned pointer match with the annotations on the kernel arguments.\n  annotated_arg_t array_a = fpga_tools::alloc_annotated<annotated_arg_t>(kN, q);\n\n  for (int i = 0; i < kN; i++) {\n    array_a[i] = i;\n  }\n\n  q.single_task(MyIP{array_a, kN}).wait();\n  bool passed = CheckResult(array_a, kN);\n  sycl::free(array_a, q);\n  return passed;\n}\n\nint main(void) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = false;\n  try {\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    // Print out the device information.\n    sycl::device device = q.get_device();\n    std::cout << \"Running on device: \"\n              << q.get_device().get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    passed = RunWithUsmMalloc(q);\n    passed &= RunWithAnnotatedAlloc(q);\n\n    if (passed) {\n      std::cout << \"PASSED: all kernel results are correct\\n\";\n    } else {\n      std::cout << \"FAILED\\n\";\n    }\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"
    },
    {
        "label": "hostpipes.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/ext/intel/experimental/pipes.hpp>\n\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n#include <numeric>\n#include <vector>\n\n// dpc_common.hpp can be found in the dev-utilities include folder.\n// e.g., $ONEAPI_ROOT/dev-utilities//include/dpc_common.hpp\n#include \"exception_handler.hpp\"\n\n// forward declare kernel and pipe names to reduce name mangling\nclass LoopBackKernelID;\nclass H2DPipeID;\nclass D2HPipeID;\n\n// the host pipes\nusing ValueT = int;\nconstexpr size_t kPipeMinCapacity = 8;\n\nusing H2DPipe = sycl::ext::intel::experimental::pipe<\n    // Usual pipe parameters\n    H2DPipeID,         // An identifier for the pipe\n    ValueT,            // The type of data in the pipe\n    kPipeMinCapacity   // The capacity of the pipe\n    >;\n\nusing D2HPipe = sycl::ext::intel::experimental::pipe<\n    // Usual pipe parameters\n    D2HPipeID,         // An identifier for the pipe\n    ValueT,            // The type of data in the pipe\n    kPipeMinCapacity   // The capacity of the pipe\n    >;\n\n// forward declare the test functions\nvoid AlternatingTest(sycl::queue&, ValueT*, ValueT*, size_t, size_t);\nvoid LaunchCollectTest(sycl::queue&, ValueT*, ValueT*, size_t, size_t);\n\n// offloaded computation\nValueT SomethingComplicated(ValueT val) {\n  return (ValueT)(val * sycl::sqrt(float(val)));\n}\n\n/////////////////////////////////////////\n\nint main(int argc, char* argv[]) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = true;\n\n  size_t count = 16;\n  if (argc > 1) count = atoi(argv[1]);\n\n  if (count <= 0) {\n    std::cerr << \"ERROR: 'count' must be positive\" << std::endl;\n    return 1;\n  }\n  if (count < kPipeMinCapacity) {\n    std::cerr\n        << \"ERROR: 'count' must be greater than the minimum pipe capacity (\"\n        << kPipeMinCapacity << \")\" << std::endl;\n    return 1;\n  }\n\n  try {\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n\n    // create input and golden output data\n    std::vector<ValueT> in(count), out(count), golden(count);\n    std::generate(in.begin(), in.end(), [] { return ValueT(rand() % 77); });\n    for (int i = 0; i < count; i++) {\n      golden[i] = SomethingComplicated(in[i]);\n    }\n\n    // validation lambda\n    auto validate = [](auto& in, auto& out, size_t size) {\n      for (int i = 0; i < size; i++) {\n        if (out[i] != in[i]) {\n          std::cout << \"out[\" << i << \"] != in[\" << i << \"]\"\n                    << \" (\" << out[i] << \" != \" << in[i] << \")\" << std::endl;\n          return false;\n        }\n      }\n      return true;\n    };\n\n    // Alternating write-and-read\n    std::cout << \"Running Alternating write-and-read\" << std::endl;\n    std::fill(out.begin(), out.end(), 0);\n    AlternatingTest(q, in.data(), out.data(), count, 3);\n    passed &= validate(golden, out, count);\n    std::cout << std::endl;\n\n    // Launch and Collect\n    std::cout << \"Running Launch and Collect\" << std::endl;\n    std::fill(out.begin(), out.end(), 0);\n    LaunchCollectTest(q, in.data(), out.data(), kPipeMinCapacity, 3);\n    passed &= validate(out, golden, kPipeMinCapacity);\n    std::cout << std::endl;\n\n  } catch (sycl::exception const& e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    std::terminate();\n  }\n\n  if (passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n\n// This kernel reads a data element from InHostPipe, processes it,\n// and writes the result to OutHostPipe\ntemplate <typename KernelId,    // type identifier for kernel\n          typename InHostPipe,  // host-to-device pipe\n          typename OutHostPipe  // device-to-host pipe\n          >\nsycl::event SubmitLoopBackKernel(sycl::queue& q, size_t count) {\n  return q.single_task<KernelId>([=] {\n    for (size_t i = 0; i < count; i++) {\n      auto d = InHostPipe::read();\n      auto r = SomethingComplicated(d);\n      OutHostPipe::write(r);\n    }\n  });\n}\n\n// This test launches SubmitLoopBackKernel, then alternates writes\n// and reads to and from the H2DPipe and D2HPipe hostpipes respectively\nvoid AlternatingTest(sycl::queue& q, ValueT* in, ValueT* out, size_t count,\n                     size_t repeats) {\n  std::cout << \"\\t Run Loopback Kernel on FPGA\" << std::endl;\n  auto e = SubmitLoopBackKernel<LoopBackKernelID, H2DPipe, D2HPipe>(\n      q, count * repeats);\n\n  for (size_t r = 0; r < repeats; r++) {\n    std::cout << \"\\t \" << r << \": \"\n              << \"Doing \" << count << \" writes & reads\" << std::endl;\n    for (size_t i = 0; i < count; i++) {\n      // write data in host-to-device hostpipe\n      H2DPipe::write(q, in[i]);\n      // read data from device-to-host hostpipe\n      out[i] = D2HPipe::read(q);\n    }\n  }\n\n  // No need to wait on kernel to finish as the pipe reads are blocking\n\n  std::cout << \"\\t Done\" << std::endl;\n}\n\n// This test launches SubmitLoopBackKernel, writes 'count'\n// elements to H2DPipe, and then reads 'count' elements from\n// D2HPipe\nvoid LaunchCollectTest(sycl::queue& q, ValueT* in, ValueT* out, size_t count,\n                       size_t repeats) {\n  std::cout << \"\\t Run Loopback Kernel on FPGA\" << std::endl;\n\n  for (size_t r = 0; r < repeats; r++) {\n    std::cout << \"\\t \" << r << \": \"\n              << \"Doing \" << count << \" writes\" << std::endl;\n    for (size_t i = 0; i < count; i++) {\n      // write data in host-to-device hostpipe\n      H2DPipe::write(q, in[i]);\n    }\n  }\n\n  auto e = SubmitLoopBackKernel<LoopBackKernelID, H2DPipe, D2HPipe>(\n      q, count * repeats);\n\n  for (size_t r = 0; r < repeats; r++) {\n    std::cout << \"\\t \" << r << \": \"\n              << \"Doing \" << count << \" reads\" << std::endl;\n    for (size_t i = 0; i < count; i++) {\n      // read data from device-to-host hostpipe\n      out[i] = D2HPipe::read(q);\n    }\n  }\n\n  // No need to wait on kernel to finish as the pipe reads are blocking\n\n  std::cout << \"\\t Done\" << std::endl;\n}\n"
    },
    {
        "label": "latency_control.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <numeric>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\nusing BurstCoalescedLSU = sycl::ext::intel::experimental::lsu<\n    sycl::ext::intel::experimental::burst_coalesce<true>,\n    sycl::ext::intel::experimental::statically_coalesce<false>>;\n\nint Operation(int a) { return a * 3 + 2; } // Arbitrary operations.\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass LatencyControl;\n\n// Runs the Kernel.\nvoid KernelRun(const std::vector<int> &in_data, std::vector<int> &out_data,\n               const size_t &size) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    // Create the SYCL device queue.\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    sycl::buffer in_buffer(in_data);\n    sycl::buffer out_buffer(out_data);\n\n    q.submit([&](sycl::handler &h) {\n      sycl::accessor in_accessor(in_buffer, h, sycl::read_only);\n      sycl::accessor out_accessor(out_buffer, h, sycl::write_only,\n                                  sycl::no_init);\n\n      h.single_task<LatencyControl>([=]() [[intel::kernel_args_restrict]] {\n        auto in_ptr =\n            in_accessor.template get_multi_ptr<sycl::access::decorated::no>();\n        auto out_ptr =\n            out_accessor.template get_multi_ptr<sycl::access::decorated::no>();\n\n        for (size_t i = 0; i < size; i++) {\n          // The following load has a label 0.\n          int value = BurstCoalescedLSU::load(\n              in_ptr + i,\n              sycl::ext::oneapi::experimental::properties(\n                  sycl::ext::intel::experimental::latency_anchor_id<0>));\n\n          value = Operation(value);\n\n          // The following store occurs exactly 5 cycles after the label-0\n          // function, i.e., the load above.\n          BurstCoalescedLSU::store(\n              out_ptr + i, value,\n              sycl::ext::oneapi::experimental::properties(\n                  sycl::ext::intel::experimental::latency_constraint<\n                      0,\n                      sycl::ext::intel::experimental::latency_control_type::\n                          exact,\n                      5>));\n        }\n      });\n    });\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}\n\nvoid GoldenRun(const std::vector<int> &in_data, std::vector<int> &out_data,\n               const size_t &size) {\n  for (size_t i = 0; i < size; i++) {\n    out_data[i] = Operation(in_data[i]);\n  }\n}\n\nint main() {\n  const size_t size = 5;\n  std::vector<int> input_data(size);\n  std::vector<int> result_kernel(size);\n  std::vector<int> result_golden(size);\n\n  // Populate in_data with incrementing values starting with 0\n  std::iota(input_data.begin(), input_data.end(), 0);\n\n  KernelRun(input_data, result_kernel, size);\n  GoldenRun(input_data, result_golden, size);\n\n  bool passed = true;\n\n  for (int i = 0; i < size; i++) {\n    if (result_kernel[i] != result_golden[i]) {\n      std::cout << \"Output Mismatch: \\n\"\n                << \"result_kernel[\" << i << \"] = \" << result_kernel[i]\n                << \", result_golden[\" << i << \"] = \" << result_golden[i]\n                << \" \\n\";\n      passed = false;\n    }\n  }\n\n  if (passed) {\n    std::cout << \"PASSED: all kernel results are correct.\\n\";\n  } else {\n    std::cout << \"FAILED\\n\";\n  }\n  return passed ? 0 : 1;\n}\n"
    },
    {
        "label": "annotated_ptr.cpp",
        "data": "#include <iomanip>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nusing Pipe2DotProductIP =\n    sycl::ext::intel::experimental::pipe<class MyPipeName1, float *>;\nusing Pipe2AnnotatedPtrIP =\n    sycl::ext::intel::experimental::pipe<class MyPipeName2, float *>;\n\nconstexpr int kBL1 = 1;\nconstexpr int kBL2 = 2;\n\nconstexpr int kRows = 2;\nconstexpr int kCols = 5;\n\n// The kernel 'DotProductIP' computes a weighted sum over a matrix and a vector:\n// out_vec[0] = mat[0][0] * in_vec[0] + mat[0][1] * in_vec[1] + ... +\n// out_vec[1] = mat[1][0] * in_vec[0] + mat[1][1] * in_vec[1] + ... +\n//          ...\nstruct DotProductIP {\n  sycl::ext::oneapi::experimental::annotated_arg<\n      float *, decltype(sycl::ext::oneapi::experimental::properties{\n                   sycl::ext::intel::experimental::buffer_location<kBL2>})>\n      in_vec;\n  sycl::ext::oneapi::experimental::annotated_arg<\n      float *, decltype(sycl::ext::oneapi::experimental::properties{\n                   sycl::ext::intel::experimental::buffer_location<kBL1>})>\n      out_vec;\n\n  void operator()() const {\n    for (int i = 0; i < kRows; i++) {\n      // read the starting pointer of the i-th row of the weight matrix\n      float *p = Pipe2DotProductIP::read();\n\n      float sum = 0.0f;\n#pragma unroll kCols\n      for (int j = 0; j < kCols; j++) sum += p[j] * in_vec[j];\n\n      out_vec[i] = sum;\n    }\n  }\n};\n\n// The kernel 'AnnotatedPtrIP' computes the same function, but with\n// `annotated_ptr` specifying the buffer location of pointers read from the host\n// pipe.\nstruct AnnotatedPtrIP {\n  sycl::ext::oneapi::experimental::annotated_arg<\n      float *, decltype(sycl::ext::oneapi::experimental::properties{\n                   sycl::ext::intel::experimental::buffer_location<kBL2>})>\n      in_vec;\n  sycl::ext::oneapi::experimental::annotated_arg<\n      float *, decltype(sycl::ext::oneapi::experimental::properties{\n                   sycl::ext::intel::experimental::buffer_location<kBL1>})>\n      out_vec;\n\n  void operator()() const {\n    for (int i = 0; i < kRows; i++) {\n      // read the starting pointer of the i-th row of the weight matrix\n      float *p = Pipe2AnnotatedPtrIP::read();\n\n      // set buffer location on p with annotated_ptr\n      sycl::ext::oneapi::experimental::annotated_ptr<\n          float, decltype(sycl::ext::oneapi::experimental::properties{\n                     sycl::ext::intel::experimental::buffer_location<kBL1>})>\n          mat{p};\n\n      float sum = 0.0f;\n#pragma unroll kCols\n      for (int j = 0; j < kCols; j++) sum += mat[j] * in_vec[j];\n\n      out_vec[i] = sum;\n    }\n  }\n};\n\n// verify results\nbool CheckResult(float *result, float *expected, int size) {\n  bool passed = true;\n  for (int i = 0; i < size; i++) {\n    if (result[i] != expected[i]) {\n      std::cout << std::setprecision(10) << \"result error! expected \"\n                << expected[i] << \". Received \" << result[i] << \"\\n\";\n      passed = false;\n    }\n  }\n  return passed;\n}\n\nint main() {\n  bool success = true;\n  try {\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // allocate memory for the flattened weight matrix. The pointers to each row\n    // will be written to each kernel through a pipe.\n    float *weight = sycl::malloc_shared<float>(\n        kRows * kCols, q,\n        sycl::ext::intel::experimental::property::usm::buffer_location(kBL1));\n    assert(weight);\n    for (int i = 0; i < kRows * kCols; i++) {\n      weight[i] = rand() % 10;\n    }\n\n    // allocate memory and initialize for input vector\n    float *input_vec = sycl::malloc_shared<float>(\n        kCols, q,\n        sycl::ext::intel::experimental::property::usm::buffer_location(kBL2));\n    assert(input_vec);\n    for (int j = 0; j < kCols; j++) input_vec[j] = rand() % 10;\n\n    // allocate memory and initialize for output vector\n    float *output_vec = sycl::malloc_shared<float>(\n        kRows, q,\n        sycl::ext::intel::experimental::property::usm::buffer_location(kBL1));\n    assert(output_vec);\n    for (int i = 0; i < kRows; i++) output_vec[i] = 0.0f;\n\n    // Compute expected result\n    float expected[kRows];\n    for (int i = 0; i < kRows; i++) {\n      expected[i] = 0.0f;\n      for (int j = 0; j < kCols; j++) {\n        expected[i] += weight[i * kCols + j] * input_vec[j];\n      }\n    }\n\n    // run kernel DotProductIP\n    auto event1 = q.single_task(DotProductIP{input_vec, output_vec});\n    // write pointers to each row to the kernels via host pipe\n    for (int i = 0; i < kRows; i++) {\n      Pipe2DotProductIP::write(q, weight + i * kCols);\n    }\n    event1.wait();\n    // verify the result\n    success = CheckResult(output_vec, expected, kRows);\n\n    // reinitialize the output vector and run kernel AnnotatedPtrIP\n    for (int j = 0; j < kCols; j++) output_vec[j] = 0.0f;\n    auto event2 = q.single_task(AnnotatedPtrIP{input_vec, output_vec});\n    // write pointers to each row to the kernels via host pipe\n    for (int i = 0; i < kRows; i++) {\n      Pipe2AnnotatedPtrIP::write(q, weight + i * kCols);\n    }\n    event2.wait();\n    // verify the result\n    success &= CheckResult(output_vec, expected, kRows);\n\n    sycl::free(input_vec, q);\n    sycl::free(output_vec, q);\n    sycl::free(weight, q);\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  if (success) {\n    std::cout << \"PASSED: The results are correct\\n\";\n    return 0;\n  }\n\n  return 1;\n}\n"
    },
    {
        "label": "device_global.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <iostream>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nconstexpr size_t kNumIterations = 4;\nconstexpr unsigned kNumWeightIncrements = 3;\nconstexpr unsigned kVectorSize = 4;\n\nnamespace syclexp = sycl::ext::oneapi::experimental;\n\nusing WeightsDeviceGlobalProperties = decltype(syclexp::properties(\n    syclexp::device_image_scope, syclexp::host_access_write));\n\n// globally declared weights for the calculation\nsyclexp::device_global<int[kVectorSize], WeightsDeviceGlobalProperties> weights;\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass Kernel;\n\n// Launch a kernel that does a weighted vector add\n// result = a + (weights * b)\nvoid WeightedVectorAdd(sycl::queue q, int *a, int *b, int *result) {\n  q.single_task<Kernel>([=]() [[intel::kernel_args_restrict]] {\n    for (auto i = 0; i < kVectorSize; i++) {\n      result[i] = a[i] + (weights[i] * b[i]);\n    }\n  });\n  q.wait();\n}\n\nint main() {\n  bool success = true;\n\n  try {\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    std::array<int, kVectorSize> host_weights;\n    int *a = sycl::malloc_host<int>(kVectorSize, q);\n    int *b = sycl::malloc_host<int>(kVectorSize, q);\n    int *result = sycl::malloc_host<int>(kVectorSize, q);\n\n    // Run the kernel with different sets of weights\n    for (auto weight = 0; weight <= kNumWeightIncrements; weight++) {\n      host_weights.fill(weight);\n      // Transfer data from the host to the device_global\n      q.copy(host_weights.data(), weights).wait();\n\n      // Update the input to the kernel and launch it\n      for (auto index = 0; index < kNumIterations; index++) {\n        std::fill(a, a + kVectorSize, index);\n        std::fill(b, b + kVectorSize, index);\n        WeightedVectorAdd(q, a, b, result);\n\n        // verify the results are correct\n        int expected_result = index + (weight * index);\n        for (auto element = 0; element < kVectorSize; element++) {\n          if (result[element] != expected_result) {\n            std::cerr << \"Error: for expession {\" << index << \" + (\" << weight\n                      << \" x \" << index << \")} expected all \" << kVectorSize\n                      << \" indicies to be \" << expected_result << \" but got \"\n                      << result[element] << \" at index \" << element << \"\\n\";\n            success = false;\n          }\n        }\n      }\n    }\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  if (success) {\n    std::cout << \"PASSED: The results are correct\\n\";\n    return 0;\n  }\n\n  return 1;\n}"
    },
    {
        "label": "max_reinvocation_delay.cpp",
        "data": "#include <iostream>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nconstexpr int kFactors = 5;\n\n// Forward declare the kernel and pipe names\n// (This prevents unwanted name mangling in the optimization report.)\nclass ArithmeticSequence;\nclass ResultsPipe;\n\n// Results pipe from device back to host\nusing PipeResults = sycl::ext::intel::experimental::pipe<ResultsPipe, int>;\n\n// Computes and outputs the first \"sequence_length\" terms of the arithmetic\n// sequences with first term \"first_term\" and factors 1 through kFactors.\nstruct ArithmeticSequenceKernel {\n  int first_term;\n  int sequence_length;\n\n  void operator()() const {\n    for (int factor = 1; factor <= kFactors; factor++) {\n      [[intel::max_reinvocation_delay(1)]] // NO-FORMAT: Attribute\n      for (int i = 0; i < sequence_length; i++) {\n        PipeResults::write(first_term + i * factor);\n      }\n    }\n  }\n};\n\nint main() {\n\n  try {\n\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n    sycl::queue q(selector, fpga_tools::exception_handler);\n    auto device = q.get_device();\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    int first_term = 0;\n    int sequence_length = 10;\n\n    q.single_task<ArithmeticSequence>(\n        ArithmeticSequenceKernel{first_term, sequence_length});\n\n    // Verify functional correctness\n    bool passed = true;\n    for (int factor = 1; factor <= kFactors; factor++) {\n      std::cout << \"Calculating arithmetic sequence with factor = \" << factor\n                << std::endl;\n      for (int i = 0; i < sequence_length; i++) {\n        int val_device = PipeResults::read(q);\n        int val_host = first_term + i * factor;\n        passed &= (val_device == val_host);\n        if (val_device != val_host) {\n          std::cout << \"Error: expected \" << val_host << \", got \" << val_device\n                    << std::endl;\n        }\n      }\n    }\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n    \n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::cerr << \"   If you are targeting an FPGA hardware, \"\n                 \"ensure that your system is plugged to an FPGA board that is \"\n                 \"set up correctly\"\n              << std::endl;\n    std::cerr << \"   If you are targeting the FPGA emulator, compile with \"\n                 \"-DFPGA_EMULATOR\"\n              << std::endl;\n    std::terminate();\n  }\n}"
    },
    {
        "label": "loop_fusion.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <iomanip>\n#include <iostream>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n#if defined(FPGA_SIMULATOR)\nconstexpr size_t kTripCount{100};\n#else\nconstexpr size_t kTripCount{10000000};\n#endif\nconstexpr size_t kDifferentTripCount{kTripCount + 1};\nconstexpr size_t kArraySize{100};\n\nusing FixedArray = std::array<int, kArraySize>;\n\nusing namespace sycl;\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass DefaultFusionKernel;\nclass NoFusionKernel;\nclass DefaultNoFusionKernel;\nclass FusionFunctionKernel;\n\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n// Handles error reporting\nvoid ErrorReport(sycl::exception const &e) {\n  // Catches exceptions in the host code\n  std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n  // Most likely the runtime couldn't find FPGA hardware!\n  if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n    std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                 \"system has a correctly configured FPGA board.\\n\";\n    std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n    std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                 \"-DFPGA_EMULATOR.\\n\";\n  }\n  std::terminate();\n}\n\n// Returns kernel runtime in ns\nauto KernelRuntime(event e) {\n  auto start{e.get_profiling_info<info::event_profiling::command_start>()};\n  auto end{e.get_profiling_info<info::event_profiling::command_end>()};\n\n  return (end - start);\n}\n\n// Fuses inner loops by default, since the trip counts are equal, and there are\n// no dependencies between loops\nvoid DefaultFusion(FixedArray &m_array_1, FixedArray &m_array_2) {\n  try {\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    buffer buff_1(m_array_1);\n    buffer buff_2(m_array_2);\n\n    event e = q.submit([&](handler &h) {\n      accessor a_1(buff_1, h, write_only, no_init);\n      accessor a_2(buff_2, h, write_only, no_init);\n\n      h.single_task<DefaultFusionKernel>([=\n      ]() [[intel::kernel_args_restrict]] {  // NO-FORMAT: Attribute\n        for (size_t i = 0; i < kTripCount; i++) {\n          a_1[i % kArraySize] = i % kArraySize;\n        }\n        for (size_t i = 0; i < kTripCount; i++) {\n          a_2[i % kArraySize] = i % kArraySize;\n        }\n      });\n    });\n\n    auto kernel_time = KernelRuntime(e);\n\n    // Kernel consists of two loops with one array assignment and two modulos in\n    // each.\n    int num_ops_per_kernel = 6 * kTripCount;\n    std::cout << \"Throughput for kernel with default loop fusion and with \"\n                 \"equally-sized loops: \"\n              << ((double)num_ops_per_kernel / kernel_time) << \" Ops/ns\\n\";\n\n  } catch (sycl::exception const &e) {\n    ErrorReport(e);\n  }\n}\n\n// Does not fuse inner loops because of the [[intel::nofusion]] attribute. Were\n// this attribute not present, the loops would fuse by default.\nvoid NoFusion(FixedArray &m_array_1, FixedArray &m_array_2) {\n  try {\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    buffer buff_1(m_array_1);\n    buffer buff_2(m_array_2);\n\n    event e = q.submit([&](handler &h) {\n      accessor a_1(buff_1, h, write_only, no_init);\n      accessor a_2(buff_2, h, write_only, no_init);\n\n      h.single_task<NoFusionKernel>([=\n      ]() [[intel::kernel_args_restrict]] {  // NO-FORMAT: Attribute\n        [[intel::nofusion]]                  // NO-FORMAT: Attribute\n        for (size_t i = 0; i < kTripCount; i++) {\n          a_1[i % kArraySize] = i % kArraySize;\n        }\n        for (size_t i = 0; i < kTripCount; i++) {\n          a_2[i % kArraySize] = i % kArraySize;\n        }\n\n      });\n    });\n\n    auto kernel_time = KernelRuntime(e);\n\n    // Kernel consists of two loops with one array assignment and two modulos in\n    // each.\n    int num_ops_per_kernel = 6 * kTripCount;\n    std::cout << \"Throughput for kernel with the nofusion attribute and with \"\n                 \"equally-sized loops: \"\n              << ((double)num_ops_per_kernel / kernel_time) << \" Ops/ns\\n\";\n\n  } catch (sycl::exception const &e) {\n    ErrorReport(e);\n  }\n}\n\n// Does not fuse inner loops by default, since the trip counts are different.\nvoid DefaultNoFusion(FixedArray &m_array_1, FixedArray &m_array_2) {\n  try {\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    buffer buff_1(m_array_1);\n    buffer buff_2(m_array_2);\n\n    event e = q.submit([&](handler &h) {\n      accessor a_1(buff_1, h, write_only, no_init);\n      accessor a_2(buff_2, h, write_only, no_init);\n\n      h.single_task<DefaultNoFusionKernel>([=\n      ]() [[intel::kernel_args_restrict]] {  // NO-FORMAT: Attribute\n        // Different tripcounts, does not fuse by default\n        for (size_t i = 0; i < kDifferentTripCount + 1; i++) {\n          a_1[i % kArraySize] = i % kArraySize;\n        }\n        for (size_t i = 0; i < kTripCount; i++) {\n          a_2[i % kArraySize] = i % kArraySize;\n        }\n\n      });\n    });\n\n    auto kernel_time = KernelRuntime(e);\n\n    // Kernel consists of two loops different trip counts, each with one array\n    // assignment and two modulos.\n    int num_ops_per_kernel = 3 * kDifferentTripCount + 3 * kTripCount;\n    std::cout << \"Throughput for kernel without fusion by default with \"\n                 \"unequally-sized loops: \"\n              << ((double)num_ops_per_kernel / kernel_time) << \" Ops/ns\\n\";\n\n  } catch (sycl::exception const &e) {\n    ErrorReport(e);\n  }\n}\n\n// The compiler is explicitly told to fuse the inner loops using the\n// fpga_loop_fuse<>() function. Were this function not used, the loops would not\n// fuse by default, since the trip counts of the loops are different.\nvoid FusionFunction(FixedArray &m_array_1, FixedArray &m_array_2) {\n  try {\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    buffer buff_1(m_array_1);\n    buffer buff_2(m_array_2);\n\n    event e = q.submit([&](handler &h) {\n      accessor a_1(buff_1, h, write_only, no_init);\n      accessor a_2(buff_2, h, write_only, no_init);\n\n      h.single_task<FusionFunctionKernel>([=\n      ]() [[intel::kernel_args_restrict]] {  // NO-FORMAT: Attribute\n        sycl::ext::intel::fpga_loop_fuse([&] {\n          // Different tripcounts, does not fuse by default\n          for (size_t i = 0; i < kDifferentTripCount; i++) {\n            a_1[i % kArraySize] = i % kArraySize;\n          }\n          for (size_t i = 0; i < kTripCount; i++) {\n            a_2[i % kArraySize] = i % kArraySize;\n          }\n        });\n      });\n    });\n\n    auto kernel_time = KernelRuntime(e);\n    // Kernel consists of two loops different trip counts, each with one array\n    // assignment and two modulos.\n    int num_ops_per_kernel = 3 * kDifferentTripCount + 3 * kTripCount;\n    std::cout << \"Throughput for kernel with a loop fusion function with \"\n                 \"unequally-sized loops: \"\n              << ((double)num_ops_per_kernel / kernel_time) << \" Ops/ns\\n\";\n\n  } catch (sycl::exception const &e) {\n    ErrorReport(e);\n  }\n}\n\nint main() {\n  // Arrays will be populated in kernel loops\n  FixedArray default_fusion_1;\n  FixedArray default_fusion_2;\n\n  FixedArray no_fusion_1;\n  FixedArray no_fusion_2;\n\n  FixedArray default_nofusion_1;\n  FixedArray default_nofusion_2;\n\n  FixedArray fusion_function_1;\n  FixedArray fusion_function_2;\n\n  // Instantiate kernel logic with and without loop fusion to compare\n  // performance\n  DefaultFusion(default_fusion_1, default_fusion_2);\n  NoFusion(no_fusion_1, no_fusion_2);\n  DefaultNoFusion(default_nofusion_1, default_nofusion_2);\n  FusionFunction(fusion_function_1, fusion_function_2);\n\n  // Verify results: arrays should be equal, and the i^th element shoul equal i\n  for (size_t i = 0; i < kArraySize; i++) {\n    if (default_fusion_1[i] != default_fusion_2[i] ||\n        default_fusion_1[i] != i) {\n      std::cout << \"FAILED: The DefaultFusionKernel results are incorrect\"\n                << '\\n';\n      return 1;\n    }\n  }\n  for (size_t i = 0; i < kArraySize; i++) {\n    if (no_fusion_1[i] != no_fusion_2[i] || no_fusion_1[i] != i) {\n      std::cout << \"FAILED: The NoFusionKernel results are incorrect\" << '\\n';\n      return 1;\n    }\n  }\n\n  for (size_t i = 0; i < kArraySize; i++) {\n    if (default_nofusion_1[i] != default_nofusion_2[i] ||\n        default_nofusion_1[i] != i) {\n      std::cout << \"FAILED: The DefaultNoFusionKernel results are incorrect\"\n                << '\\n';\n      return 1;\n    }\n  }\n\n  for (size_t i = 0; i < kArraySize; i++) {\n    if (fusion_function_1[i] != fusion_function_2[i] ||\n        fusion_function_1[i] != i) {\n      std::cout << \"FAILED: The FusionFunctionKernel results are incorrect\"\n                << '\\n';\n      return 1;\n    }\n  }\n  std::cout << \"PASSED: The results are correct\" << '\\n';\n  return 0;\n}\n"
    },
    {
        "label": "ac_int.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/ac_types/ac_int.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include <bitset>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass BasicOpsInt;\nclass BasicOpsAcInt;\nclass ShiftOps;\nclass EfficientShiftOps;\nclass BitAccess;\n\nusing MyUInt2 = ac_int<2, false>;\nusing MyInt7 = ac_int<7, true>;\nusing MyInt14 = ac_int<14, true>;\nusing MyInt15 = ac_int<15, true>;\nusing MyInt28 = ac_int<28, true>;\n\nvoid TestBasicOpsInt(queue &q, const int &a, const int &b, int &c, int &d,\n                     int &e) {\n  buffer<int, 1> c_buf(&c, 1);\n  buffer<int, 1> d_buf(&d, 1);\n  buffer<int, 1> e_buf(&e, 1);\n\n  q.submit([&](handler &h) {\n    accessor c_acc(c_buf, h, write_only, no_init);\n    accessor d_acc(d_buf, h, write_only, no_init);\n    accessor e_acc(e_buf, h, write_only, no_init);\n    h.single_task<BasicOpsInt>([=]() [[intel::kernel_args_restrict]] {\n      c_acc[0] = a + b;\n      d_acc[0] = a * b;\n      e_acc[0] = a / b;\n    });\n  });\n}\n\n// Kernel `BasicOpsAcInt` consumes fewer resources than kernel `BasicOpsInt`.\nvoid TestBasicOpsAcInt(queue &q, const MyInt14 &a, const MyInt14 &b, MyInt15 &c,\n                       MyInt28 &d, MyInt15 &e) {\n  buffer<MyInt15, 1> c_buf(&c, 1);\n  buffer<MyInt28, 1> d_buf(&d, 1);\n  buffer<MyInt15, 1> e_buf(&e, 1);\n\n  q.submit([&](handler &h) {\n    accessor c_acc(c_buf, h, write_only, no_init);\n    accessor d_acc(d_buf, h, write_only, no_init);\n    accessor e_acc(e_buf, h, write_only, no_init);\n    h.single_task<BasicOpsAcInt>([=]() [[intel::kernel_args_restrict]] {\n      c_acc[0] = a + b;\n      d_acc[0] = a * b;\n      e_acc[0] = a / b;\n    });\n  });\n}\n\nvoid TestShiftOps(queue &q, const MyInt14 &a, const MyInt14 &b, MyInt14 &c) {\n  buffer<MyInt14, 1> c_buf(&c, 1);\n\n  q.submit([&](handler &h) {\n    accessor c_acc(c_buf, h, write_only, no_init);\n    h.single_task<ShiftOps>([=]() {\n      MyInt14 temp = a << b;\n      c_acc[0] = temp >> b;\n    });\n  });\n}\n\n// Kernel `EfficientShiftOps` consumes fewer resources than kernel `ShiftOps`.\nvoid TestEfficientShiftOps(queue &q, const MyInt14 &a, const MyUInt2 &b,\n                           MyInt14 &c) {\n  buffer<MyInt14, 1> c_buf(&c, 1);\n\n  q.submit([&](handler &h) {\n    accessor c_acc(c_buf, h, write_only, no_init);\n    h.single_task<EfficientShiftOps>([=]() {\n      MyInt14 temp = a << b;\n      c_acc[0] = temp >> b;\n    });\n  });\n}\n\nMyInt14 TestBitAccess(queue &q, const MyInt14 &a) {\n  MyInt14 res;\n  buffer<MyInt14, 1> res_buf(&res, 1);\n\n  q.submit([&](handler &h) {\n    accessor res_acc(res_buf, h, write_only, no_init);\n    h.single_task<BitAccess>([=]() {\n      // 0b1111101\n      MyInt7 temp = a.slc<7>(3);\n\n      res_acc[0] = 0; // Must be initialized before being accessed by the bit\n                      // select operator `[]`. Using the `[]` operator on an\n                      // uninitialized `ac_int` variable is undefined behavior\n                      // and can give you unexpected results.\n\n      // 0 -> 0b1111101000\n      res_acc[0].set_slc(3, temp);\n\n      // 0b1111101000 -> 0b1111101111\n      res_acc[0][2] = 1;\n      res_acc[0][1] = 1;\n      res_acc[0][0] = 1;\n    });\n  });\n  return res;\n}\n\nint main() {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = true;\n\n  try {\n    queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    constexpr int kVal1 = 1000, kVal2 = 2;\n\n    {\n      MyInt14 input_a = kVal1, input_b = kVal2;\n      MyInt15 output_c;\n      MyInt28 output_d;\n      MyInt15 output_e;\n      TestBasicOpsAcInt(q, input_a, input_b, output_c, output_d, output_e);\n\n      int golden_c, golden_d, golden_e;\n      TestBasicOpsInt(q, input_a, input_b, golden_c, golden_d, golden_e);\n\n      if (output_c != golden_c || output_d != golden_d ||\n          output_e != golden_e) {\n        std::cout << \"Result mismatch!\\n\"\n                  << \"Kernel BasicOpsInt:   addition = \" << golden_c\n                  << \", multiplication = \" << golden_d\n                  << \", division = \" << golden_e << \"\\n\"\n                  << \"Kernel BasicOpsAcInt: addition = \" << output_c\n                  << \", multiplication = \" << output_d\n                  << \", division = \" << output_e << \"\\n\\n\";\n        passed = false;\n      }\n    }\n\n    {\n      MyInt14 input_a = kVal1, input_b = kVal2;\n      MyUInt2 input_efficient_b = kVal2;\n      MyInt14 output_c, output_efficient_c;\n      TestShiftOps(q, input_a, input_b, output_c);\n      TestEfficientShiftOps(q, input_a, input_efficient_b, output_efficient_c);\n\n      if (output_c != output_efficient_c) {\n        std::cout << \"Result mismatch!\\n\"\n                  << \"Kernel ShiftOps: result = \" << output_c << \"\\n\"\n                  << \"Kernel EfficientShiftOps: result = \" << output_efficient_c\n                  << \"\\n\\n\";\n        passed = false;\n      }\n    }\n\n    {\n      MyInt14 input = kVal1;\n      MyInt14 output = TestBitAccess(q, input);\n\n      constexpr int kGolden = 0b001111101111;\n\n      if (output != kGolden) {\n        std::cout << \"Kernel BitAccess result mismatch!\\n\"\n                  << \"result = 0b\" << std::bitset<14>(output) << \"\\n\"\n                  << \"golden = 0b\" << std::bitset<14>(kGolden) << \"\\n\\n\";\n        passed = false;\n      }\n    }\n  } catch (exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  if (passed) {\n    std::cout << \"PASSED: all kernel results are correct.\\n\";\n  } else {\n    std::cout << \"FAILED\\n\";\n  }\n  return passed ? 0 : 1;\n}\n"
    },
    {
        "label": "memory_attributes.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// constants for this tutorial\nconstexpr size_t kRows = 8;\n#if defined(FPGA_SIMULATOR)\n// Use a smaller unroll factor when running simulation\nconstexpr size_t kVec = 1;\n#else\nconstexpr size_t kVec = 4;\n#endif\nconstexpr size_t kMaxVal = 512;\n#if defined (FPGA_SIMULATOR)\nconstexpr size_t kNumTests = 2;\n#else\nconstexpr size_t kNumTests = 64;\n#endif\nconstexpr size_t kMaxIter = 8;\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\n// Templating allows us to easily instantiate different versions of the kernel.\ntemplate<int AttrType>\nclass Kernel;\n\n// The shared compute function for host and device code\nsize_t Compute(unsigned init, unsigned dict_offset[][kVec]) {\n  // We do not provide any attributes for compare_offset and hash;\n  // we let the compiler decide what's best based on the access pattern\n  // and their size.\n  unsigned compare_offset[kVec][kVec];\n  unsigned hash[kVec];\n\n  #pragma unroll\n  for (size_t i = 0; i < kVec; i++) {\n    hash[i] = (++init) & (kRows - 1);\n  }\n\n  size_t count = 0, iter = 0;\n  do {\n    // After unrolling both loops, we have kVec*kVec reads from dict_offset\n    #pragma unroll\n    for (size_t i = 0; i < kVec; i++) {\n      #pragma unroll\n      for (size_t k = 0; k < kVec; ++k) {\n        compare_offset[k][i] = dict_offset[hash[i]][k];\n      }\n    }\n\n    // After unrolling, we have kVec writes to dict_offset\n    #pragma unroll\n    for (size_t k = 0; k < kVec; ++k) {\n      dict_offset[hash[k]][k] = (init << k);\n    }\n    init++;\n\n    #pragma unroll\n    for (size_t i = 0; i < kVec; i++) {\n      #pragma unroll\n      for (size_t k = 0; k < kVec; ++k) {\n        count += compare_offset[i][k];\n      }\n    }\n  } while (++iter < kMaxIter);\n  return count;\n}\n\n// We use partial template specialization to apply different attributes to the\n// 'dict_offset' variable in the kernel.\n// This serves as a baseline implementation where no attributes are applied\n// to the variable. The compiler uses heuristics to try and find the best\n// configuration\ntemplate<int AttrType>\nevent submitKernel(queue& q, unsigned init, buffer<unsigned, 1>& d_buf,\n                      buffer<unsigned, 1>& r_buf) {\n  auto e = q.submit([&](handler &h) {\n    accessor d_accessor(d_buf, h, read_only);\n    accessor r_accessor(r_buf, h, write_only, no_init);\n\n    h.single_task<Kernel<AttrType>>([=]() [[intel::kernel_args_restrict]] {\n      // Declare 'dict_offset' whose attributes are applied based on AttrType\n      unsigned dict_offset[kRows][kVec];\n\n      // Initialize 'dict_offset' with values from global memory.\n      for (size_t i = 0; i < kRows; ++i) {\n        #pragma unroll\n        for (size_t k = 0; k < kVec; ++k) {\n          // After unrolling, we end up with kVec writes to dict_offset.\n          dict_offset[i][k] = d_accessor[i * kVec + k];\n        }\n      }\n\n      // compute the result\n      r_accessor[0] = Compute(init, dict_offset);\n    });\n  });\n\n  return e;\n}\n\n// Define version 1 of the kernel - using a single pumped memory \ntemplate<>\nevent submitKernel<1>(queue& q, unsigned init, buffer<unsigned, 1>& d_buf,\n                      buffer<unsigned, 1>& r_buf) {\n  auto e = q.submit([&](handler &h) {\n    accessor d_accessor(d_buf, h, read_only);\n    accessor r_accessor(r_buf, h, write_only, no_init);\n\n    h.single_task<Kernel<1>>([=]() [[intel::kernel_args_restrict]] {\n      // Declare 'dict_offset' whose attributes are applied based on AttrType\n      [[intel::singlepump,\n        intel::fpga_memory(\"MLAB\"),\n        intel::numbanks(kVec),\n        intel::max_replicates(kVec)]]\n      unsigned dict_offset[kRows][kVec];\n\n      // Initialize 'dict_offset' with values from global memory.\n      for (size_t i = 0; i < kRows; ++i) {\n        #pragma unroll\n        for (size_t k = 0; k < kVec; ++k) {\n          // After unrolling, we end up with kVec writes to dict_offset.\n          dict_offset[i][k] = d_accessor[i * kVec + k];\n        }\n      }\n\n      // compute the result\n      r_accessor[0] = Compute(init, dict_offset);\n    });\n  });\n\n  return e;\n}\n\n// Define version 2 of the kernel - using a double pumped memory \ntemplate<>\nevent submitKernel<2>(queue& q, unsigned init, buffer<unsigned, 1>& d_buf,\n                      buffer<unsigned, 1>& r_buf) {\n  auto e = q.submit([&](handler &h) {\n    accessor d_accessor(d_buf, h, read_only);\n    accessor r_accessor(r_buf, h, write_only, no_init);\n\n    h.single_task<Kernel<2>>([=]() [[intel::kernel_args_restrict]] {\n      // Declare 'dict_offset' whose attributes are applied based on AttrType\n      [[intel::doublepump,\n        intel::fpga_memory(\"MLAB\"),\n        intel::numbanks(kVec),\n        intel::max_replicates(kVec)]]\n      unsigned dict_offset[kRows][kVec];\n\n      // Initialize 'dict_offset' with values from global memory.\n      for (size_t i = 0; i < kRows; ++i) {\n        #pragma unroll\n        for (size_t k = 0; k < kVec; ++k) {\n          // After unrolling, we end up with kVec writes to dict_offset.\n          dict_offset[i][k] = d_accessor[i * kVec + k];\n        }\n      }\n\n      // compute the result\n      r_accessor[0] = Compute(init, dict_offset);\n    });\n  });\n\n  return e;\n}\n\ntemplate <int AttrType>\nunsigned RunKernel(unsigned init, const unsigned dict_offset_init[],\n                   bool first_run = false) {\n  unsigned result = 0;\n\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    queue q(selector, fpga_tools::exception_handler);\n\n    if (first_run){\n      auto device = q.get_device();\n\n      std::cout << \"Running on device: \"\n                << device.get_info<sycl::info::device::name>().c_str()\n                << std::endl;\n    }\n\n    // Flatten the 2D array to a 1D buffer, because the\n    // buffer constructor requires a pointer to input data\n    // that is contiguous in memory.\n    buffer<unsigned, 1> d_buf(dict_offset_init, range<1>(kRows * kVec));\n    buffer<unsigned, 1> r_buf(&result, 1);\n\n    // submit the kernel\n    auto e = submitKernel<AttrType>(q, init, d_buf, r_buf);\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return result;\n}\n\n// This host side function performs the same computation as the device side\n// kernel, and is used to verify functional correctness.\nunsigned GoldenRun(unsigned init, unsigned const dict_offset_init[]) {\n  unsigned dict_offset[kRows][kVec];\n  for (size_t i = 0; i < kRows; ++i) {\n    for (size_t k = 0; k < kVec; ++k) {\n      dict_offset[i][k] = dict_offset_init[i * kVec + k];\n    }\n  }\n  return Compute(init, dict_offset);\n}\n\nint main() {\n  srand(0);\n\n  bool passed = true;\n\n  for (size_t j = 0; j < kNumTests; j++) {\n    unsigned init = rand() % kMaxVal;\n    unsigned int dict_offset_init[kRows * kVec];\n\n    // initialize input data with random values\n    for (size_t i = 0; i < kRows; ++i) {\n      for (size_t k = 0; k < kVec; ++k) {\n        dict_offset_init[i * kVec + k] = rand() % kMaxVal;\n      }\n    }\n\n    // compute the golden result\n    unsigned golden_result = GoldenRun(init, dict_offset_init);\n\n    // run the kernel with 'singlepump' memory attribute\n    bool first_run = j==0;\n    unsigned result_sp = RunKernel<1>(init, dict_offset_init, first_run);\n\n    if (!(result_sp == golden_result)) {\n      passed = false;\n      std::cout << \"  Test#\" << j\n                << \": mismatch: \" << result_sp << \" != \" << golden_result\n                << \" (result_sp != golden_result)\\n\";\n    }\n\n    // run the kernel with 'doublepump' memory attribute\n    unsigned result_dp = RunKernel<2>(init, dict_offset_init);\n\n    if (!(result_dp == golden_result)) {\n      passed = false;\n      std::cout << \"  Test#\" << j\n                << \": mismatch: \" << result_dp << \" != \" << golden_result\n                << \" (result_dp != golden_result)\\n\";\n    }\n\n    // run the kernel with no memory attributes\n    unsigned result_na = RunKernel<0>(init, dict_offset_init);\n\n    if (!(result_na == golden_result)) {\n      passed = false;\n      std::cout << \"  Test#\" << j\n                << \": mismatch: \" << result_na << \" != \" << golden_result\n                << \" (result_na != golden_result)\\n\";\n    }\n  }\n\n  if (passed) {\n    std::cout << \"PASSED: all kernel results are correct.\\n\";\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n\n  return 0;\n}\n"
    },
    {
        "label": "max_interleaving.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <array>\n#include <cmath>\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <iomanip>\n#include <iostream>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n#if defined(FPGA_SIMULATOR) || defined(FPGA_EMULATOR)\n// Simulator runs too slowly for large array sizes\n// Emulator has stack issues for large array sizes -\n// (malloc can be used but is out of scope of this tutorial)\nconstexpr size_t kSize = 32;\n#else\nconstexpr size_t kSize = 128;\n#endif\nconstexpr float kErrorThreshold = 0.5;\nconstexpr int kTotalOps = 4 * kSize * kSize;\n\nusing FloatArray = std::array<float, kSize>;\nusing TwoDimFloatArray = std::array<float, kSize*kSize>;\nusing FloatScalar = std::array<float, 1>;\n\n// an example complicated operation that creates a long critical path of\n// combinational logic from the use of the parameter values to the result\nfloat SomethingComplicated(float x, float y) { return sycl::sqrt(x) * sycl::sqrt(y); }\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\ntemplate <int interleaving>\nclass KernelCompute;\n\n// Launch a kernel on the device specified by selector.\n// The kernel's functionality is designed to show the\n// performance impact of the max_interleaving attribute.\ntemplate <int interleaving>\nvoid Transform(const TwoDimFloatArray &array_a, FloatArray &array_r) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  double kernel_time = 0.0;\n\n  try {\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    buffer array_a_buffer(array_a);\n    buffer array_r_buffer(array_r);\n\n    event e = q.submit([&](handler &h) {\n      accessor array_a_accessor(array_a_buffer, h, read_only);\n      accessor accessor_array_r(array_r_buffer, h, write_only, no_init);\n\n      h.single_task<KernelCompute<interleaving>>([=]() \n                                                 [[intel::kernel_args_restrict]] {\n        float temp_a[kSize*kSize];\n        float temp_r[kSize];\n\n        for (size_t i = 0; i < kSize; i++) {\n          for (size_t j = 0; j < kSize; j++) {\n            temp_a[i*kSize+j] = array_a_accessor[i*kSize+j];\n          }\n          temp_r[i] = 1.0;\n        }\n\n        // A simple row reduction where row i of temp_a is summed and \n        // stored in temp_r[i].\n        // Notice how temp_r[i] is a loop carried dependency in the inner loop as it is updated \n        // every iteration. As a result, the *inner loop II is very high* as a new iteration from \n        // the *same* outer loop invocation must wait for the previous iteration to finish updating\n        // temp_r[i].\n        // However, notice how *no* loop carried memory dependency exists with respect to \n        // the outer loop - for different i-iterations, the temp_r array is read and written to\n        // in different locations. \n        // The lack of outer loop carried memory dependencies and a high inner loop II is what \n        // allows interleaving to happen - where multiple invocations of the inner loop\n        // concurrently execute on the same inner loop hardware. This is like pipelining, \n        // but each iteration executing in the inner loop is from *different* invocations.\n        outer: \n        for (int i = kSize - 1; i >= 0; i--) {\n          // You can explicitly disable interleaving with this attribute by providing `1` as \n          // a parameter. `0` keeps it enabled, so long as interleaving is possible.\n          // This may result in area savings at the cost of throughput, which could \n          // be useful for non-critical data paths in low-area settings. \n          inner: \n          [[intel::max_interleaving(interleaving)]]\n          for (int j = kSize - 1; j >= 0; j--) {\n            temp_r[i] +=\n                SomethingComplicated(temp_a[i * kSize + j], temp_r[i]);\n          }\n          // One final note - the loop induction variables decrease (i--) instead of increase (i++)\n          // in these two loops to prevent loop fusion optimizations, which makes it harder to \n          // keep track of loops in the optimization reports. Interleaving will still occur if  \n          // `i` and `j` were instead incremented.\n        }\n\n        for (size_t i = 0; i < kSize; i++) {\n          accessor_array_r[i] = temp_r[i];\n        }\n      });\n    });\n\n    // SYCL event profiling allows the kernel execution to be timed\n    double start = e.get_profiling_info<info::event_profiling::command_start>();\n    double end = e.get_profiling_info<info::event_profiling::command_end>();\n    kernel_time = (double)(end - start) * 1e-6f;\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\" << '\\n' << e.what() << '\\n';\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  // The performance of the kernel is measured in GFlops, based on:\n  // 1) the number of floating-point operations performed by the kernel.\n  //    This can be calculated easily for the simple example kernel.\n  // 2) the kernel execution time reported by SYCL event profiling.\n  std::cout << \"Max interleaving \" << interleaving << \" \"\n            << \"kernel time : \" << kernel_time << \" ms\\n\";\n  std::cout << \"Throughput for kernel with max_interleaving \" << interleaving\n            << \": \";\n  std::cout << std::fixed << std::setprecision(3)\n#if defined(FPGA_SIMULATOR)\n            << ((double)(kTotalOps) / kernel_time) << \" KFlops\\n\";\n#else\n            << ((double)(kTotalOps) / kernel_time) / 1e6f << \" GFlops\\n\";\n#endif\n}\n\n// Calculates the expected results. Used to verify that the kernel\n// is functionally correct.\nvoid GoldenResult(const TwoDimFloatArray &A, FloatArray &R) {\n  outer: for (int i = kSize - 1; i >= 0; i--) {\n    inner: for (int j = kSize - 1; j >= 0; j--) {\n      R[i] +=\n          SomethingComplicated(A[i * kSize + j], R[i]);\n    }\n  }\n}\n\nint main() {\n\n  TwoDimFloatArray indata_A;\n  FloatArray outdata_R_compute_0;\n  FloatArray outdata_R_compute_1;\n  FloatArray outdata_R_golden;\n\n  // initialize the input data\n  srand(7);\n  for (size_t i = 0; i < kSize; i++) {\n    for (size_t j = 0; j < kSize; j++) {\n      indata_A[i*kSize+j] = (float)(rand() % 32);\n    }\n    outdata_R_golden[i] = 1.0;\n  }\n\n  // Run the kernel with two different values of the max_interleaving\n  // attribute: \n  //   Enabled - max_interleaving = 0\n  //   Disabled - max_interleaving = 1\n  // When interleaving is disabled, runtime performance may decrease while\n  // hardware resources may increase (see README.md for details\n  // on confirming this difference in hardware resource usage in\n  // the reports).\n  Transform<0>(indata_A, outdata_R_compute_0);\n  Transform<1>(indata_A, outdata_R_compute_1);\n\n  // compute the actual result here\n  GoldenResult(indata_A, outdata_R_golden);\n\n  // error check for Transform<0>\n  bool failed = false;\n  for (unsigned i = 0; i < kSize; i++) {\n    if (std::abs(outdata_R_compute_0[i] - outdata_R_golden[i]) >\n        kErrorThreshold) {\n      std::cout << \"error at [\" << i << \"]: \" << outdata_R_compute_0[i]\n                << \" != \" << outdata_R_golden[i] << '\\n';\n      failed = true;\n    }\n  }\n\n  // error check for Transform<1>\n  for (unsigned i = 0; i < kSize; i++) {\n    if (std::abs(outdata_R_compute_1[i] - outdata_R_golden[i]) >\n        kErrorThreshold) {\n      std::cout << \"error at [\" << i << \"]: \" << outdata_R_compute_1[i]\n                << \" != \" << outdata_R_golden[i] << '\\n';\n      failed = true;\n    }\n  }\n\n  if (failed) {\n    std::cout << \"FAILED: The results are incorrect\\n\";\n    return 1;\n  } else {\n    std::cout << \"PASSED: The results are correct\\n\";\n    return 0;\n  }\n}\n"
    },
    {
        "label": "reg_map_functor.cpp",
        "data": "// oneAPI headers\n#include <sycl/ext/intel/ac_types/ac_int.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nusing MyUInt5 = ac_int<5, false>;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass FunctorRegMap;\n\n/////////////////////////////////////////\n\nstruct FunctorRegMapIP {\n  // Use an annotated_arg with the 'register_map' property to explicitly specify\n  // it to be a register-mapped kernel argument.\n  sycl::ext::oneapi::experimental::annotated_arg<\n      int *, decltype(sycl::ext::oneapi::experimental::properties{\n                 sycl::ext::intel::experimental::register_map})>\n      input;\n\n  // Without the annotation, kernel argument will be inferred to be\n  // register-mapped kernel arguments if the kernel invocation interface is\n  // register-mapped, and vice-versa.\n  int *output;\n\n  // A kernel with a register map invocation interface can also independently\n  // have streaming kernel arguments, when annotated by 'conduit' property.\n  sycl::ext::oneapi::experimental::annotated_arg<\n      MyUInt5, decltype(sycl::ext::oneapi::experimental::properties{\n                   sycl::ext::intel::experimental::conduit})>\n      n;\n\n  // Without a kernel argument definition, the compiler will infer a\n  // register-mapped invocation interface.\n  void operator()() const {\n    // For annotated_arg of ac_int type, explicitly cast away the annotated_arg\n    // to prevent compiler error when using methods or accessing members.\n    for (MyUInt5 i = 0; i < ((MyUInt5)n).slc<5>(0); i++) {\n      output[i] = input[i] * (input[i] + 1);\n    }\n  }\n};\n\nint main(int argc, char *argv[]) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = true;\n\n  MyUInt5 count = 16;\n  if (argc > 1) count = atoi(argv[1]);\n\n  if (count <= 0) {\n    std::cerr << \"ERROR: 'count' must be positive\" << std::endl;\n    return 1;\n  }\n\n  try {\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    // make sure the device supports USM host allocations\n    sycl::device d = q.get_device();\n\n    // Print out the device information.\n    std::cout << \"Running on device: \"\n              << q.get_device().get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    if (!d.has(sycl::aspect::usm_host_allocations)) {\n      std::cerr << \"ERROR: The selected device does not support USM host\"\n                << \" allocations\" << std::endl;\n      return 1;\n    }\n\n    int *input = sycl::malloc_host<int>(count, q);\n    int *functor_register_map_out = sycl::malloc_host<int>(count, q);\n    int *golden_out = sycl::malloc_host<int>(count, q);\n\n    // test that mallocs did not return nullptr\n    assert(input);\n    assert(functor_register_map_out);\n    assert(golden_out);\n\n    // create input and golden output data\n    for (MyUInt5 i = 0; i < count; i++) {\n      input[i] = rand() % 77;\n      golden_out[i] = (int)(input[i] * (input[i] + 1));\n      functor_register_map_out[i] = 0;\n    }\n\n    // validation lambda\n    auto validate = [](int *golden_out, int *functor_register_map_out,\n                       MyUInt5 count) {\n      for (MyUInt5 i = 0; i < count; i++) {\n        if (functor_register_map_out[i] != golden_out[i]) {\n          std::cout << \"functor_register_map_out[\" << i << \"] != golden_out[\"\n                    << i << \"]\"\n                    << \" (\" << functor_register_map_out[i]\n                    << \" != \" << golden_out[i] << \")\" << std::endl;\n          return false;\n        }\n      }\n      return true;\n    };\n\n    // Launch the kernel with a register map invocation interface implemented in\n    // the functor programming model\n    std::cout << \"Running the kernel with register map invocation interface \"\n                 \"implemented in the functor programming model\"\n              << std::endl;\n    q.single_task<FunctorRegMap>(\n         FunctorRegMapIP{input, functor_register_map_out, count})\n        .wait();\n    std::cout << \"\\t Done\" << std::endl;\n\n    passed &= validate(golden_out, functor_register_map_out, count);\n    std::cout << std::endl;\n\n    sycl::free(input, q);\n    sycl::free(functor_register_map_out, q);\n    sycl::free(golden_out, q);\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    std::terminate();\n  }\n\n  if (passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n"
    },
    {
        "label": "reg_map_lambda.cpp",
        "data": "// oneAPI headers\n#include <sycl/ext/intel/ac_types/ac_int.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nusing MyUInt5 = ac_int<5, false>;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass LambdaRegMap;\n\n/////////////////////////////////////////\n\nvoid LambdaRegMapKernel(sycl::queue &q, int *input, int *output, MyUInt5 n) {\n  // A kernel with a register map invocation interface can also independently\n  // have streaming kernel arguments, when annotated by 'conduit' property.\n  sycl::ext::oneapi::experimental::annotated_arg<\n      MyUInt5, decltype(sycl::ext::oneapi::experimental::properties{\n                   sycl::ext::intel::experimental::conduit})>\n      n_annotated = n;\n\n  // Without passing a properties object argument, the compiler will infer a\n  // register-mapped invocation interface.\n  q.single_task<LambdaRegMap>([=] {\n     // For annotated_arg of ac_int type, explicitly cast away the annotated_arg\n     // to prevent compiler error when using methods or accessing members.\n     for (MyUInt5 i = 0; i < ((MyUInt5)n_annotated).slc<5>(0); i++) {\n       output[i] = input[i] * (input[i] + 1);\n     }\n   }).wait();\n\n  std::cout << \"\\t Done\" << std::endl;\n}\n\nint main(int argc, char *argv[]) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = true;\n\n  MyUInt5 count = 16;\n  if (argc > 1) count = atoi(argv[1]);\n\n  if (count <= 0) {\n    std::cerr << \"ERROR: 'count' must be positive\" << std::endl;\n    return 1;\n  }\n\n  try {\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    // make sure the device supports USM host allocations\n    sycl::device d = q.get_device();\n\n    // Print out the device information.\n    std::cout << \"Running on device: \"\n              << q.get_device().get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    if (!d.has(sycl::aspect::usm_host_allocations)) {\n      std::cerr << \"ERROR: The selected device does not support USM host\"\n                << \" allocations\" << std::endl;\n      return 1;\n    }\n\n    int *input = sycl::malloc_host<int>(count, q);\n    int *lambda_register_map_out = sycl::malloc_host<int>(count, q);\n    int *golden_out = sycl::malloc_host<int>(count, q);\n\n    // test that mallocs did not return nullptr\n    assert(input);\n    assert(lambda_register_map_out);\n    assert(golden_out);\n\n    // create input and golden output data\n    for (MyUInt5 i = 0; i < count; i++) {\n      input[i] = rand() % 77;\n      golden_out[i] = (int)(input[i] * (input[i] + 1));\n      lambda_register_map_out[i] = 0;\n    }\n\n    // validation lambda\n    auto validate = [](int *golden_out, int *lambda_register_map_out,\n                       MyUInt5 count) {\n      for (MyUInt5 i = 0; i < count; i++) {\n        if (lambda_register_map_out[i] != golden_out[i]) {\n          std::cout << \"lambda_register_map_out[\" << i << \"] != golden_out[\"\n                    << i << \"]\"\n                    << \" (\" << lambda_register_map_out[i]\n                    << \" != \" << golden_out[i] << \")\" << std::endl;\n          return false;\n        }\n      }\n      return true;\n    };\n\n    // Launch the kernel with a register map invocation interface implemented in\n    // the lambda programming model\n    std::cout << \"Running the kernel with register map invocation interface \"\n                 \"implemented in the lambda programming model\"\n              << std::endl;\n    LambdaRegMapKernel(q, input, lambda_register_map_out, count);\n    passed &= validate(golden_out, lambda_register_map_out, count);\n    std::cout << std::endl;\n\n    sycl::free(input, q);\n    sycl::free(lambda_register_map_out, q);\n    sycl::free(golden_out, q);\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    std::terminate();\n  }\n\n  if (passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n"
    },
    {
        "label": "stream_pipelined.cpp",
        "data": "// oneAPI headers\n#include <sycl/ext/intel/ac_types/ac_int.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass StreamPipelined;\n\nstruct StreamPipelinedIP {\n  // Kernel arguments will be passed as conduits since the invocation interface\n  // is configured to be 'streaming', and no annotated_arg wrapper is used.\n  int *input;\n  int *output;\n\n  // Kernel properties method to configure the kernel to be a kernel with\n  // streaming pipelined invocation interface.\n  // The property `sycl::ext::intel::experimental::pipelined` takes an optional\n  // template parameter that controls whether to pipeline the kernel. Valid\n  // parameters are: -1: Pipeline the kernel, and automatically infer lowest\n  // possible II at target fMAX. 0: Do not pipeline the kernel. N (N> 0):\n  // Pipeline the kernel, and force the II of the kernel to be N. If a parameter\n  // is not specified, the default behaviour of -1 will be inferred.\n  auto get(sycl::ext::oneapi::experimental::properties_tag) {\n    return sycl::ext::oneapi::experimental::properties{\n        sycl::ext::intel::experimental::streaming_interface<>,\n        sycl::ext::intel::experimental::pipelined<>};\n  }\n\n  void operator()() const {\n    int val = *input;\n    *output = (int)(val * (val + 1));\n  }\n};\n\nint main(int argc, char *argv[]) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = true;\n  int count = 16;\n  if (argc > 1) count = atoi(argv[1]);\n\n  if (count <= 0) {\n    std::cerr << \"ERROR: 'count' must be positive\" << std::endl;\n    return 1;\n  }\n\n  try {\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    // make sure the device supports USM host allocations\n    sycl::device d = q.get_device();\n\n    // Print out the device information.\n    std::cout << \"Running on device: \"\n              << q.get_device().get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    if (!d.has(sycl::aspect::usm_host_allocations)) {\n      std::cerr << \"ERROR: The selected device does not support USM host\"\n                << \" allocations\" << std::endl;\n      return 1;\n    }\n\n    int *input = sycl::malloc_host<int>(count, q);\n    int *functor_streaming_pipelined_out = sycl::malloc_host<int>(count, q);\n    int *golden_out = sycl::malloc_host<int>(count, q);\n\n    // test that mallocs did not return nullptr\n    assert(input);\n    assert(functor_streaming_pipelined_out);\n    assert(golden_out);\n\n    // create input and golden output data\n    for (int i = 0; i < count; i++) {\n      input[i] = rand() % 77;\n      golden_out[i] = (int)(input[i] * (input[i] + 1));\n      functor_streaming_pipelined_out[i] = 0;\n    }\n\n    // validation lambda\n    auto validate = [](auto *golden_out, auto *functor_streaming_pipelined_out,\n                       int count) {\n      for (int i = 0; i < count; i++) {\n        if (functor_streaming_pipelined_out[i] != golden_out[i]) {\n          std::cout << \"functor_streaming_pipelined_out[\" << i\n                    << \"] != golden_out[\" << i << \"]\"\n                    << \" (\" << functor_streaming_pipelined_out[i]\n                    << \" != \" << golden_out[i] << \")\" << std::endl;\n          return false;\n        }\n      }\n      return true;\n    };\n\n    std::cout << \"Launching streaming pipelined kernels consecutively\"\n              << std::endl;\n    for (int i = 0; i < count; i++) {\n      q.single_task<StreamPipelined>(\n          StreamPipelinedIP{&input[i], &functor_streaming_pipelined_out[i]});\n    }\n    q.wait();\n    std::cout << \"\\t Done\" << std::endl;\n\n    passed &= validate(golden_out, functor_streaming_pipelined_out, count);\n    std::cout << std::endl;\n\n    sycl::free(input, q);\n    sycl::free(functor_streaming_pipelined_out, q);\n    sycl::free(golden_out, q);\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    std::terminate();\n  }\n\n  if (passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}"
    },
    {
        "label": "stream_rm_stall.cpp",
        "data": "// oneAPI headers\n#include <sycl/ext/intel/ac_types/ac_int.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass StreamRmStall;\n\n/////////////////////////////////////////\n\nstruct StreamRmStallIP {\n  // Annotate kernel argument with 'conduit' property\n  // to specify it to be a streaming kernel argument.\n  sycl::ext::oneapi::experimental::annotated_arg<\n      int *, decltype(sycl::ext::oneapi::experimental::properties{\n                 sycl::ext::intel::experimental::conduit})>\n      input;\n\n  // A kernel with a streaming invocation interface can also independently have\n  // register-mapped kernel arguments, when annotated by 'register_map'\n  // property.\n  sycl::ext::oneapi::experimental::annotated_arg<\n      int *, decltype(sycl::ext::oneapi::experimental::properties{\n                 sycl::ext::intel::experimental::register_map})>\n      output;\n\n  // Without the annotation, kernel argument will be inferred to be streaming\n  // kernel arguments if the kernel invocation interface is streaming, and\n  // vice-versa.\n  int n;\n\n  // Kernel properties method to configure the kernel to be a kernel with\n  // streaming invocation interface without downstream 'ready_in' interface.\n  auto get(sycl::ext::oneapi::experimental::properties_tag) {\n    return sycl::ext::oneapi::experimental::properties{\n        sycl::ext::intel::experimental::\n            streaming_interface_remove_downstream_stall};\n  }\n\n  void operator()() const {\n    for (int i = 0; i < n; i++) {\n      output[i] = (int)(input[i] * (input[i] + 1));\n    }\n  }\n};\n\nint main(int argc, char *argv[]) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = true;\n\n  int count = 16;\n  if (argc > 1) count = atoi(argv[1]);\n\n  if (count <= 0) {\n    std::cerr << \"ERROR: 'count' must be positive\" << std::endl;\n    return 1;\n  }\n\n  try {\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    // make sure the device supports USM host allocations\n    sycl::device d = q.get_device();\n\n    // Print out the device information.\n    std::cout << \"Running on device: \"\n              << q.get_device().get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    if (!d.has(sycl::aspect::usm_host_allocations)) {\n      std::cerr << \"ERROR: The selected device does not support USM host\"\n                << \" allocations\" << std::endl;\n      return 1;\n    }\n\n    int *input = sycl::malloc_host<int>(count, q);\n    int *stream_rm_stall_out = sycl::malloc_host<int>(count, q);\n    int *golden_out = sycl::malloc_host<int>(count, q);\n\n    // test that mallocs did not return nullptr\n    assert(input);\n    assert(stream_rm_stall_out);\n    assert(golden_out);\n\n    // create input and golden output data\n    for (int i = 0; i < count; i++) {\n      input[i] = rand() % 77;\n      golden_out[i] = (int)(input[i] * (input[i] + 1));\n      stream_rm_stall_out[i] = 0;\n    }\n\n    // validation lambda\n    auto validate = [](auto *golden_out, auto *stream_rm_stall_out, int count) {\n      for (int i = 0; i < count; i++) {\n        if (stream_rm_stall_out[i] != golden_out[i]) {\n          std::cout << \"stream_rm_stall_out[\" << i << \"] != golden_out[\" << i\n                    << \"]\"\n                    << \" (\" << stream_rm_stall_out[i] << \" != \" << golden_out[i]\n                    << \")\" << std::endl;\n          return false;\n        }\n      }\n      return true;\n    };\n\n    // Launch the kernel with a streaming invocation interface implemented in\n    // the functor programming model\n    std::cout << \"Running the kernel with streaming invocation interface \"\n                 \"implemented in the \"\n                 \"functor programming model\"\n              << std::endl;\n    q.single_task<StreamRmStall>(\n         StreamRmStallIP{input, stream_rm_stall_out, count})\n        .wait();\n    std::cout << \"\\t Done\" << std::endl;\n\n    passed &= validate(golden_out, stream_rm_stall_out, count);\n    std::cout << std::endl;\n\n    sycl::free(input, q);\n    sycl::free(stream_rm_stall_out, q);\n    sycl::free(golden_out, q);\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    std::terminate();\n  }\n\n  if (passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n"
    },
    {
        "label": "stream_functor.cpp",
        "data": "// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass FunctorStream;\n\nstruct Point {\n  int x;\n  char y;\n};\n\n/////////////////////////////////////////\n\nstruct FunctorStreamIP {\n  // Annotate kernel argument with 'conduit' property\n  // to specify it to be a streaming kernel argument.\n  sycl::ext::oneapi::experimental::annotated_arg<\n      Point, decltype(sycl::ext::oneapi::experimental::properties{\n                 sycl::ext::intel::experimental::conduit})>\n      input;\n\n  // A kernel with a streaming invocation interface can also independently\n  // have register-mapped kernel arguments, when annotated by 'register_map'\n  // property.\n  sycl::ext::oneapi::experimental::annotated_arg<\n      Point *, decltype(sycl::ext::oneapi::experimental::properties{\n                   sycl::ext::intel::experimental::register_map})>\n      output;\n\n  // Without the annotation, kernel argument will be inferred to be streaming\n  // kernel arguments if the kernel invocation interface is streaming, and\n  // vice-versa.\n  int n;\n\n  // Kernel properties method to configure the kernel to be a kernel with\n  // streaming invocation interface.\n  auto get(sycl::ext::oneapi::experimental::properties_tag) {\n    return sycl::ext::oneapi::experimental::properties{\n        sycl::ext::intel::experimental::\n            streaming_interface_accept_downstream_stall};\n  }\n\n  void operator()() const {\n    // For annotated_arg of struct type, explicitly cast away the annotated_arg\n    // to prevent compiler error.\n    struct Point ret;\n    ret.x = 0;\n    ret.y = ((Point)input).y;\n\n    for (int i = 0; i < n; i++) {\n      ret.x += ((Point)input).x;\n      ret.y += 1;\n    }\n    *output = ret;\n  }\n};\n\nint main(int argc, char *argv[]) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = true;\n\n  int count = 16;\n  if (argc > 1) count = atoi(argv[1]);\n\n  if (count <= 0) {\n    std::cerr << \"ERROR: 'count' must be positive\" << std::endl;\n    return 1;\n  }\n\n  try {\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    // make sure the device supports USM host allocations\n    sycl::device d = q.get_device();\n\n    // Print out the device information.\n    std::cout << \"Running on device: \"\n              << q.get_device().get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    if (!d.has(sycl::aspect::usm_host_allocations)) {\n      std::cerr << \"ERROR: The selected device does not support USM host\"\n                << \" allocations\" << std::endl;\n      return 1;\n    }\n\n    Point input;\n    input.x = 1;\n    input.y = 'a';\n\n    Point *functor_streaming_out = sycl::malloc_host<Point>(count, q);\n    Point *golden_out = sycl::malloc_host<Point>(count, q);\n\n    // test that mallocs did not return nullptr\n    assert(functor_streaming_out);\n    assert(golden_out);\n\n    // Compute golden output data\n    Point ret;\n    ret.x = 0;\n    ret.y = input.y;\n\n    for (int i = 0; i < (count); i++) {\n      ret.x += input.x;\n      ret.y += 1;\n    }\n    *golden_out = ret;\n\n    // validation lambda\n    auto validate = [](auto *golden_out, auto *functor_streaming_out) {\n      if (functor_streaming_out->x != golden_out->x ||\n          functor_streaming_out->y != golden_out->y) {\n        std::cout << \"Expected: \\n\";\n        std::cout << \"functor_streaming_out->x = \" << golden_out->x << \"\\n\";\n        std::cout << \"functor_streaming_out->y = \" << golden_out->y << \"\\n\";\n        std::cout << \"Got: \\n\";\n        std::cout << \"functor_streaming_out->x = \" << functor_streaming_out->x\n                  << \"\\n\";\n        std::cout << \"functor_streaming_out->y = \" << functor_streaming_out->y\n                  << \"\\n\";\n        std::cout << \"FAILED\\n\";\n        return false;\n      }\n      return true;\n    };\n\n    // Launch the kernel with a streaming invocation interface implemented in\n    // the functor programming model\n    std::cout << \"Running the kernel with streaming invocation interface \"\n                 \"implemented in the \"\n                 \"functor programming model\"\n              << std::endl;\n    q.single_task<FunctorStream>(\n         FunctorStreamIP{input, functor_streaming_out, count})\n        .wait();\n    std::cout << \"\\t Done\" << std::endl;\n\n    passed &= validate(golden_out, functor_streaming_out);\n    std::cout << std::endl;\n\n    sycl::free(functor_streaming_out, q);\n    sycl::free(golden_out, q);\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    std::terminate();\n  }\n\n  if (passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n"
    },
    {
        "label": "stream_lambda.cpp",
        "data": "// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass LambdaStream;\n\n/////////////////////////////////////////\n\nvoid LambdaStreamKernel(sycl::queue &q, int *input, int *output, int n) {\n  // Create a properties object containing the kernel invocation interface\n  // property 'streaming_interface_remove_downstream_stall'.\n  sycl::ext::oneapi::experimental::properties kernel_properties{\n      sycl::ext::intel::experimental::\n          streaming_interface_remove_downstream_stall};\n\n  // In the Lambda programming model, pass a properties object argument to\n  // configure the kernel invocation interface. All kernel arguments will have\n  // the same interface as the kernel invocation interface.\n  q.single_task<LambdaStream>(kernel_properties, [=] {\n     for (int i = 0; i < n; i++) {\n       output[i] = input[i] * (input[i] + 1);\n     }\n   }).wait();\n\n  std::cout << \"\\t Done\" << std::endl;\n}\n\nint main(int argc, char *argv[]) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = true;\n\n  int count = 16;\n  if (argc > 1) count = atoi(argv[1]);\n\n  if (count <= 0) {\n    std::cerr << \"ERROR: 'count' must be positive\" << std::endl;\n    return 1;\n  }\n\n  try {\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    // make sure the device supports USM host allocations\n    sycl::device d = q.get_device();\n\n    // Print out the device information.\n    std::cout << \"Running on device: \"\n              << q.get_device().get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    if (!d.has(sycl::aspect::usm_host_allocations)) {\n      std::cerr << \"ERROR: The selected device does not support USM host\"\n                << \" allocations\" << std::endl;\n      return 1;\n    }\n\n    int *input = sycl::malloc_host<int>(count, q);\n    int *lambda_streaming_out = sycl::malloc_host<int>(count, q);\n    int *golden_out = sycl::malloc_host<int>(count, q);\n\n    // test that mallocs did not return nullptr\n    assert(input);\n    assert(lambda_streaming_out);\n    assert(golden_out);\n\n    // create input and golden output data\n    for (int i = 0; i < count; i++) {\n      input[i] = rand() % 77;\n      golden_out[i] = (int)(input[i] * (input[i] + 1));\n      lambda_streaming_out[i] = 0;\n    }\n\n    // validation lambda\n    auto validate = [](int *golden_out, int *lambda_streaming_out, int count) {\n      for (int i = 0; i < count; i++) {\n        if (lambda_streaming_out[i] != golden_out[i]) {\n          std::cout << \"lambda_streaming_out[\" << i << \"] != golden_out[\" << i\n                    << \"]\"\n                    << \" (\" << lambda_streaming_out[i]\n                    << \" != \" << golden_out[i] << \")\" << std::endl;\n          return false;\n        }\n      }\n      return true;\n    };\n\n    // Launch the kernel with a streaming invocation interface implemented in\n    // the lambda programming model\n    std::cout << \"Running the kernel with streaming invocation interface \"\n                 \"implemented in the \"\n                 \"lambda programming model\"\n              << std::endl;\n    LambdaStreamKernel(q, input, lambda_streaming_out, count);\n    passed &= validate(golden_out, lambda_streaming_out, count);\n    std::cout << std::endl;\n\n    sycl::free(input, q);\n    sycl::free(lambda_streaming_out, q);\n    sycl::free(golden_out, q);\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    std::terminate();\n  }\n\n  if (passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n"
    },
    {
        "label": "streaming_data_interfaces.cpp",
        "data": "#include <iostream>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/ext/intel/prototype/pipes_ext.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// limit pixel values to this value, or less\nconstexpr int kThreshold = 200;\n\n// Forward declare the kernel and pipe names\n// (this prevents unwanted name mangling in the optimization report)\nclass InStream;\nclass OutStream;\nclass Threshold;\n\n// StreamingBeat struct enables sideband signals in Avalon streaming interface\nusing StreamingBeatT = sycl::ext::intel::experimental::StreamingBeat<\n    unsigned char,  // type carried over this Avalon streaming interface's data\n                    // signal\n    true,           // enable startofpacket and endofpacket signals\n    false>;         // disable the empty signal\n\n// Pipe properties\nusing PipePropertiesT = decltype(sycl::ext::oneapi::experimental::properties(\n    sycl::ext::intel::experimental::ready_latency<0>,\n    sycl::ext::intel::experimental::bits_per_symbol<8>,\n    sycl::ext::intel::experimental::uses_valid<true>,\n    sycl::ext::intel::experimental::first_symbol_in_high_order_bits<true>,\n    sycl::ext::intel::experimental::protocol_avalon_streaming_uses_ready));\n\n// Image streams\nusing InPixelPipe = sycl::ext::intel::experimental::pipe<\n    InStream,        // An identifier for the pipe\n    StreamingBeatT,  // The type of data in the pipe\n    0,               // The capacity of the pipe\n    PipePropertiesT  // Customizable pipe properties\n    >;\nusing OutPixelPipe = sycl::ext::intel::experimental::pipe<\n    OutStream,       // An identifier for the pipe\n    StreamingBeatT,  // The type of data in the pipe\n    0,               // The capacity of the pipe\n    PipePropertiesT  // Customizable pipe properties\n    >;\n\n// A kernel that thresholds pixel values in an image over a stream. Uses start\n// of packet and end of packet signals on the streams to determine the beginning\n// and end of the image.\nstruct ThresholdKernel {\n  void operator()() const {\n    bool start_of_packet = false;\n    bool end_of_packet = false;\n\n    while (!end_of_packet) {\n      // Read in next pixel\n      StreamingBeatT in_beat = InPixelPipe::read();\n      auto pixel = in_beat.data;\n      start_of_packet = in_beat.sop;\n      end_of_packet = in_beat.eop;\n\n      // Threshold\n      if (pixel > kThreshold) pixel = kThreshold;\n\n      // Write out result\n      StreamingBeatT out_beat(pixel, start_of_packet, end_of_packet);\n      OutPixelPipe::write(out_beat);\n    }\n  }\n};\n\nint main() {\n  try {\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Test image dimensions\n    unsigned int width = 16;\n    unsigned int height = 16;\n\n    // Generate pixel data\n    for (int i = 0; i < (width * height); ++i) {\n      bool start_of_packet = (i == 0);\n      bool end_of_packet = (i == ((width * height) - 1));\n      StreamingBeatT in_beat(i, start_of_packet, end_of_packet);\n      InPixelPipe::write(q, in_beat);\n    }\n\n    // Call the kernel\n    q.single_task<Threshold>(ThresholdKernel{});\n\n    // Check that output pixels are below the threshold\n    bool passed = true;\n    for (int i = 0; i < (width * height); ++i) {\n      StreamingBeatT out_beat = OutPixelPipe::read(q);\n      passed &= (out_beat.data <= kThreshold);\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    std::terminate();\n  }\n}"
    },
    {
        "label": "vector_add.cpp",
        "data": "#include <iostream>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass IDSimpleVAdd;\n\nstruct SimpleVAddKernel {\n  int *a_in;\n  int *b_in;\n  int *c_out;\n  int len;\n\n  void operator()() const {\n    for (int idx = 0; idx < len; idx++) {\n      int a_val = a_in[idx];\n      int b_val = b_in[idx];\n      int sum = a_val + b_val;\n      c_out[idx] = sum;\n    }\n  }\n};\n\nconstexpr int kVectorSize = 256;\n\nint main() {\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Vector size is a constant here, but it could be a run-time variable too.\n    int count = kVectorSize;\n\n    // Create USM shared allocations in the specified buffer_location.\n    // You can also use host allocations with malloc_host(...) API\n    int *a = sycl::malloc_shared<int>(count, q);\n    int *b = sycl::malloc_shared<int>(count, q);\n    int *c = sycl::malloc_shared<int>(count, q);\n    for (int i = 0; i < count; i++) {\n      a[i] = i;\n      b[i] = (count - i);\n    }\n\n    std::cout << \"Add two vectors of size \" << count << std::endl;\n\n    sycl::event e = q.single_task<IDSimpleVAdd>(SimpleVAddKernel{a, b, c, count});\n\n    // Verify that outputs are correct, after the kernel has finished running.\n    e.wait();\n    bool passed = true;\n    for (int i = 0; i < count; i++) {\n      int expected = a[i] + b[i];\n      if (c[i] != expected) {\n        std::cout << \"idx=\" << i << \": result \" << c[i] << \", expected (\"\n                  << expected << \") A=\" << a[i] << \" + B=\" << b[i] << std::endl;\n        passed = false;\n      }\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    sycl::free(a, q);\n    sycl::free(b, q);\n    sycl::free(c, q);\n\n    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::cerr << \"   If you are targeting an FPGA hardware, \"\n                 \"ensure that your system is plugged to an FPGA board that is \"\n                 \"set up correctly\"\n              << std::endl;\n    std::terminate();\n  }\n}"
    },
    {
        "label": "vector_add.cpp",
        "data": "#include <iostream>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass IDSimpleVAdd;\n\n// Forward declare pipe names to reduce name mangling\nclass IDPipeA;\nclass IDPipeB;\nclass IDPipeC;\n\nusing PipeProps = decltype(sycl::ext::oneapi::experimental::properties(\n    sycl::ext::intel::experimental::ready_latency<0>));\n\nusing InputPipeA =\n    sycl::ext::intel::experimental::pipe<IDPipeA, int, 0, PipeProps>;\nusing InputPipeB =\n    sycl::ext::intel::experimental::pipe<IDPipeB, int, 0, PipeProps>;\nusing OutputPipeC =\n    sycl::ext::intel::experimental::pipe<IDPipeC, int, 0, PipeProps>;\n\nstruct SimpleVAddKernel {\n  int len;\n\n  void operator()() const {\n    for (int idx = 0; idx < len; idx++) {\n      int a_val = InputPipeA::read();\n      int b_val = InputPipeB::read();\n      int sum = a_val + b_val;\n      OutputPipeC::write(sum);\n    }\n  }\n};\n\nconstexpr int kVectorSize = 256;\n\nint main() {\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Vector size is a constant here, but it could be a run-time variable too.\n    int count = kVectorSize;\n\n    // Push data into pipes before invoking kernel\n    int *a = new int[count];\n    int *b = new int[count];\n    for (int i = 0; i < count; i++) {\n      a[i] = i;\n      b[i] = (count - i);\n      // When writing to a host pipe in non kernel code,\n      // you must pass the sycl::queue as the first argument\n      InputPipeA::write(q, a[i]);\n      InputPipeB::write(q, b[i]);\n    }\n\n    std::cout << \"Add two vectors of size \" << count << std::endl;\n\n    q.single_task<IDSimpleVAdd>(SimpleVAddKernel{count});\n\n    // Verify that outputs are correct. Do not wait for the kernel to complete,\n    // because the pipe reads are blocking. Therefore, waiting would cause\n    // deadlock.\n    bool passed = true;\n    for (int i = 0; i < count; i++) {\n      int expected = a[i] + b[i];\n      int calc = OutputPipeC::read(q);\n      if (calc != expected) {\n        std::cout << \"idx=\" << i << \": result \" << calc << \", expected (\"\n                  << expected << \") A=\" << a[i] << \" + B=\" << b[i] << std::endl;\n        passed = false;\n      }\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    delete[] a;\n    delete[] b;\n\n    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::cerr << \"   If you are targeting an FPGA hardware, \"\n                 \"ensure that your system is plugged to an FPGA board that is \"\n                 \"set up correctly\"\n              << std::endl;\n    std::terminate();\n  }\n}"
    },
    {
        "label": "vector_add.cpp",
        "data": "#include <iostream>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass IDSimpleVAdd;\n\nstruct SimpleVAddKernel {\n  sycl::ext::oneapi::experimental::annotated_arg<\n      int *, decltype(sycl::ext::oneapi::experimental::properties{\n                 sycl::ext::intel::experimental::conduit})>\n      a_in;\n\n  sycl::ext::oneapi::experimental::annotated_arg<\n      int *, decltype(sycl::ext::oneapi::experimental::properties{\n                 sycl::ext::intel::experimental::conduit})>\n      b_in;\n\n  sycl::ext::oneapi::experimental::annotated_arg<\n      int *, decltype(sycl::ext::oneapi::experimental::properties{\n                 sycl::ext::intel::experimental::conduit})>\n      c_out;\n\n  sycl::ext::oneapi::experimental::annotated_arg<\n      int, decltype(sycl::ext::oneapi::experimental::properties{\n               sycl::ext::intel::experimental::conduit})>\n      len;\n\n  // kernel property method to config invocation interface\n  auto get(sycl::ext::oneapi::experimental::properties_tag) {\n    return sycl::ext::oneapi::experimental::properties{\n        sycl::ext::intel::experimental::streaming_interface<>};\n  }\n\n  void operator()() const {\n    for (int idx = 0; idx < len; idx++) {\n      int a_val = a_in[idx];\n      int b_val = b_in[idx];\n      int sum = a_val + b_val;\n      c_out[idx] = sum;\n    }\n  }\n};\n\nconstexpr int kVectorSize = 256;\n\nint main() {\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Vector size is a constant here, but it could be a run-time variable too.\n    int count = kVectorSize;\n\n    // Create USM shared allocations in the specified buffer_location.\n    // You can also use host allocations with malloc_host(...) API\n    int *a = sycl::malloc_shared<int>(count, q);\n    int *b = sycl::malloc_shared<int>(count, q);\n    int *c = sycl::malloc_shared<int>(count, q);\n    for (int i = 0; i < count; i++) {\n      a[i] = i;\n      b[i] = (count - i);\n    }\n\n    std::cout << \"Add two vectors of size \" << count << std::endl;\n\n    sycl::event e = q.single_task<IDSimpleVAdd>(SimpleVAddKernel{a, b, c, count});\n\n    // Verify that outputs are correct, after the kernel has finished running.\n    e.wait();\n    bool passed = true;\n    for (int i = 0; i < count; i++) {\n      int expected = a[i] + b[i];\n      if (c[i] != expected) {\n        std::cout << \"idx=\" << i << \": result \" << c[i] << \", expected (\"\n                  << expected << \") A=\" << a[i] << \" + B=\" << b[i] << std::endl;\n        passed = false;\n      }\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    sycl::free(a, q);\n    sycl::free(b, q);\n    sycl::free(c, q);\n\n    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::cerr << \"   If you are targeting an FPGA hardware, \"\n                 \"ensure that your system is plugged to an FPGA board that is \"\n                 \"set up correctly\"\n              << std::endl;\n    std::terminate();\n  }\n}"
    },
    {
        "label": "vector_add.cpp",
        "data": "#include <iostream>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass IDSimpleVAdd;\n\n// Forward declare pipe names to reduce name mangling\nclass IDPipeA;\nclass IDPipeB;\nclass IDPipeC;\n\nusing PipeProps = decltype(sycl::ext::oneapi::experimental::properties(\n    sycl::ext::intel::experimental::ready_latency<0>));\n\nusing InputPipeA =\n    sycl::ext::intel::experimental::pipe<IDPipeA, int, 0, PipeProps>;\nusing InputPipeB =\n    sycl::ext::intel::experimental::pipe<IDPipeB, int, 0, PipeProps>;\n\nusing CsrOutProperties = decltype(sycl::ext::oneapi::experimental::properties(\n    sycl::ext::intel::experimental::protocol<\n        // Host doesn't care about possibly missing an update, so no need for\n        // protocol_name::avalon_mm_uses_ready\n        sycl::ext::intel::experimental::protocol_name::avalon_mm>));\n\nusing OutputPipeC =\n    sycl::ext::intel::experimental::pipe<IDPipeC, int, 0, CsrOutProperties>;\n\nstruct SimpleVAddKernel {\n  int len;\n\n  void operator()() const {\n    int sum_total = 0;\n    for (int idx = 0; idx < len; idx++) {\n      int a_val = InputPipeA::read();\n      int b_val = InputPipeB::read();\n      int sum = a_val + b_val;\n\n      sum_total += sum;\n    }\n\n    // Write to OutputPipeC only once per kernel invocation. Since we requested\n    // protcol_avalon_mm instead of protocol_avalon_mm_uses_ready, this write is\n    // effectively non-blocking.\n    OutputPipeC::write(sum_total);\n  }\n};\n\nconstexpr int kVectorSize = 256;\n\nint main() {\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Vector size is a constant here, but it could be a run-time variable too.\n    int count = kVectorSize;\n\n    int expected_sum = 0;\n\n    // push data into pipes before invoking kernel\n    int *a = new int[count];\n    int *b = new int[count];\n    for (int i = 0; i < count; i++) {\n      a[i] = i;\n      b[i] = (count - i);\n\n      expected_sum += (a[i] + b[i]);\n      // When writing to a host pipe in non kernel code,\n      // you must pass the sycl::queue as the first argument\n      InputPipeA::write(q, a[i]);\n      InputPipeB::write(q, b[i]);\n    }\n\n    std::cout << \"Add two vectors of size \" << count << std::endl;\n\n    sycl::event e = q.single_task<IDSimpleVAdd>(SimpleVAddKernel{count});\n\n    // Verify that outputs are correct, after the kernel has finished running.\n    // Since the write to OutputPipeC is non-blocking, no need to worry about\n    // deadlock.\n    e.wait();\n    bool passed = true;\n\n    // Only read from OutputPipeC once, since the kernel only wrote to it once\n    int calc = OutputPipeC::read(q);\n    if (calc != expected_sum) {\n      std::cout << \"result \" << calc << \", expected (\" << expected_sum << \")\"\n                << std::endl;\n      passed = false;\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    delete[] a;\n    delete[] b;\n\n    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::cerr << \"   If you are targeting an FPGA hardware, \"\n                 \"ensure that your system is plugged to an FPGA board that is \"\n                 \"set up correctly\"\n              << std::endl;\n    std::terminate();\n  }\n}"
    },
    {
        "label": "vector_add.cpp",
        "data": "#include <iostream>\n\n// oneAPI headers\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include \"exception_handler.hpp\"\n\n// Buffer locations for MM Host interfaces\nconstexpr int kBL1 = 1;\nconstexpr int kBL2 = 2;\nconstexpr int kBL3 = 3;\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass IDSimpleVAdd;\n\nstruct SimpleVAddKernel {\n  sycl::ext::oneapi::experimental::annotated_arg<\n      int *, decltype(sycl::ext::oneapi::experimental::properties{\n                 sycl::ext::intel::experimental::buffer_location<kBL1>,\n                 sycl::ext::intel::experimental::dwidth<32>,\n                 sycl::ext::intel::experimental::latency<0>,\n                 sycl::ext::intel::experimental::read_write_mode_read,\n                 sycl::ext::oneapi::experimental::alignment<4>})>\n      a_in;\n\n  sycl::ext::oneapi::experimental::annotated_arg<\n      int *, decltype(sycl::ext::oneapi::experimental::properties{\n                 sycl::ext::intel::experimental::buffer_location<kBL2>,\n                 sycl::ext::intel::experimental::dwidth<32>,\n                 sycl::ext::intel::experimental::latency<0>,\n                 sycl::ext::intel::experimental::read_write_mode_read,\n                 sycl::ext::oneapi::experimental::alignment<4>})>\n                 \n      b_in;\n\n  sycl::ext::oneapi::experimental::annotated_arg<\n      int *, decltype(sycl::ext::oneapi::experimental::properties{\n                 sycl::ext::intel::experimental::buffer_location<kBL3>,\n                 sycl::ext::intel::experimental::dwidth<32>,\n                 sycl::ext::intel::experimental::latency<0>,\n                 sycl::ext::intel::experimental::read_write_mode_write,\n                 sycl::ext::oneapi::experimental::alignment<4>})>\n      c_out;\n\n  int len;\n\n  void operator()() const {\n    for (int idx = 0; idx < len; idx++) {\n      int a_val = a_in[idx];\n      int b_val = b_in[idx];\n      int sum = a_val + b_val;\n      c_out[idx] = sum;\n    }\n  }\n};\n\nconstexpr int kVectorSize = 256;\n\nint main() {\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    int count = kVectorSize;  // pass array size by value\n\n    // declare arrays and fill them\n    // Create USM shared allocations in the specified buffer_location. \n    // You can also use host allocations with malloc_host(...) API\n    int *a = sycl::malloc_shared<int>(\n        count, q,\n        sycl::property_list{\n            sycl::ext::intel::experimental::property::usm::buffer_location(\n                kBL1)});\n    int *b = sycl::malloc_shared<int>(\n        count, q,\n        sycl::property_list{\n            sycl::ext::intel::experimental::property::usm::buffer_location(\n                kBL2)});\n    int *c = sycl::malloc_shared<int>(\n        count, q,\n        sycl::property_list{\n            sycl::ext::intel::experimental::property::usm::buffer_location(\n                kBL3)});\n\n    for (int i = 0; i < count; i++) {\n      a[i] = i;\n      b[i] = (count - i);\n    }\n\n    std::cout << \"Add two vectors of size \" << count << std::endl;\n\n    q.single_task<IDSimpleVAdd>(SimpleVAddKernel{a, b, c, count}).wait();\n\n    // verify that VC is correct\n    bool passed = true;\n    for (int i = 0; i < count; i++) {\n      int expected = a[i] + b[i];\n      if (c[i] != expected) {\n        std::cout << \"idx=\" << i << \": result \" << c[i] << \", expected (\"\n                  << expected << \") A=\" << a[i] << \" + B=\" << b[i] << std::endl;\n        passed = false;\n      }\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    sycl::free(a, q);\n    sycl::free(b, q);\n    sycl::free(c, q);\n\n    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n\n  } catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::cerr << \"   If you are targeting an FPGA hardware, \"\n                 \"ensure that your system is plugged to an FPGA board that is \"\n                 \"set up correctly\"\n              << std::endl;\n    std::terminate();\n  }\n}"
    },
    {
        "label": "mmhost.cpp",
        "data": "#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nconstexpr int kBL1 = 1;\nconstexpr int kBL2 = 2;\nconstexpr int kAlignment = 32;\n\nstruct DDRIP {\n  using ParamsBl1 = decltype(sycl::ext::oneapi::experimental::properties{\n      sycl::ext::intel::experimental::buffer_location<kBL1>,\n      sycl::ext::intel::experimental::maxburst<8>,\n      sycl::ext::intel::experimental::dwidth<256>,\n      sycl::ext::oneapi::experimental::alignment<kAlignment>,\n      sycl::ext::intel::experimental::awidth<32>,\n      sycl::ext::intel::experimental::latency<0>});\n\n  using ParamsBl2 = decltype(sycl::ext::oneapi::experimental::properties{\n      sycl::ext::intel::experimental::buffer_location<kBL2>,\n      sycl::ext::intel::experimental::maxburst<8>,\n      sycl::ext::intel::experimental::dwidth<256>,\n      sycl::ext::oneapi::experimental::alignment<kAlignment>,\n      sycl::ext::intel::experimental::awidth<32>,\n      sycl::ext::intel::experimental::latency<0>});\n\n  sycl::ext::oneapi::experimental::annotated_arg<int *, ParamsBl1> x;\n  sycl::ext::oneapi::experimental::annotated_arg<int *, ParamsBl1> y;\n  sycl::ext::oneapi::experimental::annotated_arg<int *, ParamsBl2> z;\n  int size;\n\n  void operator()() const {\n#pragma unroll 8\n    for (int i = 0; i < size; ++i) {\n      z[i] = x[i] + y[i];\n    }\n  }\n};\n\nint main(void) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = true;\n\n  try {\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    // Print out the device information.\n    sycl::device device = q.get_device();\n    std::cout << \"Running on device: \"\n              << q.get_device().get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Create and initialize the host arrays\n    constexpr int kN = 8;\n    std::cout << \"Elements in vector : \" << kN << \"\\n\";\n\n    // Host array must share the same buffer location property as defined in the\n    // kernel. Since we are specifying alignment on the kernel argument, we\n    // need to also specify that to the allocation call by using\n    // aligned_alloc_shared API\n    int *array_a = sycl::aligned_alloc_shared<int>(\n        kAlignment, kN, q,\n        sycl::ext::intel::experimental::property::usm::buffer_location(kBL1));\n    int *array_b = sycl::aligned_alloc_shared<int>(\n        kAlignment, kN, q,\n        sycl::ext::intel::experimental::property::usm::buffer_location(kBL1));\n    int *array_c = sycl::aligned_alloc_shared<int>(\n        kAlignment, kN, q,\n        sycl::ext::intel::experimental::property::usm::buffer_location(kBL2));\n\n    assert(array_a);\n    assert(array_b);\n    assert(array_c);\n\n    for (int i = 0; i < kN; i++) {\n      array_a[i] = i;\n      array_b[i] = 2 * i;\n    }\n\n    q.single_task(DDRIP{array_a, array_b, array_c, kN}).wait();\n    for (int i = 0; i < kN; i++) {\n      auto golden = 3 * i;\n      if (array_c[i] != golden) {\n        std::cout << \"ERROR! At index: \" << i << \" , expected: \" << golden\n                  << \" , found: \" << array_c[i] << \"\\n\";\n        passed = false;\n      }\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    free(array_a, q);\n    free(array_b, q);\n    free(array_c, q);\n\n    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}"
    },
    {
        "label": "mmhost.cpp",
        "data": "#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nstruct PointerIP {\n  // Pointer kernel arguments will be passed through the component's CSR. They\n  // will refer to data accessible through a shared Avalon memory-mapped host\n  // interface.\n  int *x;\n  int *y;\n  int *z;\n  int size;\n\n  void operator()() const {\n    for (int i = 0; i < size; ++i) {\n      z[i] = x[i] + y[i];\n    }\n  }\n};\n\nint main(void) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = true;\n\n  try {\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    // Print out the device information.\n    sycl::device device = q.get_device();\n    std::cout << \"Running on device: \"\n              << q.get_device().get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Create and initialize the host arrays\n    constexpr int kN = 8;\n    std::cout << \"Elements in vector : \" << kN << \"\\n\";\n\n    int *array_a = sycl::malloc_shared<int>(kN, q);\n    int *array_b = sycl::malloc_shared<int>(kN, q);\n    int *array_c = sycl::malloc_shared<int>(kN, q);\n\n    assert(array_a);\n    assert(array_b);\n    assert(array_c);\n\n    for (int i = 0; i < kN; i++) {\n      array_a[i] = i;\n      array_b[i] = 2 * i;\n    }\n\n    q.single_task(PointerIP{array_a, array_b, array_c, kN}).wait();\n    for (int i = 0; i < kN; i++) {\n      auto golden = 3 * i;\n      if (array_c[i] != golden) {\n        std::cout << \"ERROR! At index: \" << i << \" , expected: \" << golden\n                  << \" , found: \" << array_c[i] << \"\\n\";\n        passed = false;\n      }\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    free(array_a, q);\n    free(array_b, q);\n    free(array_c, q);\n\n    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}"
    },
    {
        "label": "mmhost.cpp",
        "data": "#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nstruct SingleMMIP {\n  // This kernel has 3 annotated pointers, but since they have no properties\n  // specified, this kernel will result in the same IP component as Example 1.\n  sycl::ext::oneapi::experimental::annotated_arg<int *> x;\n  sycl::ext::oneapi::experimental::annotated_arg<int *> y;\n  sycl::ext::oneapi::experimental::annotated_arg<int *> z;\n  int size;\n\n  void operator()() const {\n    for (int i = 0; i < size; ++i) {\n      z[i] = x[i] + y[i];\n    }\n  }\n};\n\nint main(void) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = true;\n\n  try {\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    // Print out the device information.\n    sycl::device device = q.get_device();\n    std::cout << \"Running on device: \"\n              << q.get_device().get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Create and initialize the host arrays\n    constexpr int kN = 8;\n    std::cout << \"Elements in vector : \" << kN << \"\\n\";\n\n    int *array_a = sycl::malloc_shared<int>(kN, q);\n    int *array_b = sycl::malloc_shared<int>(kN, q);\n    int *array_c = sycl::malloc_shared<int>(kN, q);\n\n    assert(array_a);\n    assert(array_b);\n    assert(array_c);\n\n    for (int i = 0; i < kN; i++) {\n      array_a[i] = i;\n      array_b[i] = 2 * i;\n    }\n\n    q.single_task(SingleMMIP{array_a, array_b, array_c, kN}).wait();\n    for (int i = 0; i < kN; i++) {\n      auto golden = 3 * i;\n      if (array_c[i] != golden) {\n        std::cout << \"ERROR! At index: \" << i << \" , expected: \" << golden\n                  << \" , found: \" << array_c[i] << \"\\n\";\n        passed = false;\n      }\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    free(array_a, q);\n    free(array_b, q);\n    free(array_c, q);\n\n    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}"
    },
    {
        "label": "mmhost.cpp",
        "data": "#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nconstexpr int kBL1 = 1;\nconstexpr int kBL2 = 2;\nconstexpr int kBL3 = 3;\nconstexpr int kAlignment = 4;\n\nstruct MultiMMIP {\n  // Each annotated pointer is configured with a unique `buffer_location`,\n  // resulting in three unique Avalon memory-mapped host interfaces.\n  using XProps = decltype(sycl::ext::oneapi::experimental::properties{\n      sycl::ext::intel::experimental::buffer_location<kBL1>,\n      sycl::ext::intel::experimental::awidth<32>,\n      sycl::ext::intel::experimental::dwidth<32>,\n      sycl::ext::intel::experimental::latency<1>,\n      sycl::ext::oneapi::experimental::alignment<kAlignment>,\n      sycl::ext::intel::experimental::read_write_mode_read});\n  using YProps = decltype(sycl::ext::oneapi::experimental::properties{\n      sycl::ext::intel::experimental::buffer_location<kBL2>,\n      sycl::ext::intel::experimental::awidth<32>,\n      sycl::ext::intel::experimental::dwidth<32>,\n      sycl::ext::intel::experimental::latency<1>,\n      sycl::ext::oneapi::experimental::alignment<kAlignment>,\n      sycl::ext::intel::experimental::read_write_mode_read});\n  using ZProps = decltype(sycl::ext::oneapi::experimental::properties{\n      sycl::ext::intel::experimental::buffer_location<kBL3>,\n      sycl::ext::intel::experimental::awidth<32>,\n      sycl::ext::intel::experimental::dwidth<32>,\n      sycl::ext::intel::experimental::latency<1>,\n      sycl::ext::oneapi::experimental::alignment<kAlignment>,\n      sycl::ext::intel::experimental::read_write_mode_write});\n\n  sycl::ext::oneapi::experimental::annotated_arg<int *, XProps> x;\n  sycl::ext::oneapi::experimental::annotated_arg<int *, YProps> y;\n  sycl::ext::oneapi::experimental::annotated_arg<int *, ZProps> z;\n\n  int size;\n\n  void operator()() const {\n    for (int i = 0; i < size; i++) {\n      z[i] = x[i] + y[i];\n    }\n  }\n};\n\nint main(void) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  bool passed = true;\n\n  try {\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler);\n\n    // Print out the device information.\n    sycl::device device = q.get_device();\n    std::cout << \"Running on device: \"\n              << q.get_device().get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Create and initialize the host arrays\n    constexpr int kN = 8;\n    std::cout << \"Elements in vector : \" << kN << \"\\n\";\n\n    // Host array must share the same buffer location property as defined in the\n    // kernel. Since we are specifying alignment on the kernel argument, we\n    // need to also specify that to the allocation call by using\n    // aligned_alloc_shared API\n    int *array_a = sycl::aligned_alloc_shared<int>(\n        kAlignment, kN, q,\n        sycl::ext::intel::experimental::property::usm::buffer_location(kBL1));\n    int *array_b = sycl::aligned_alloc_shared<int>(\n        kAlignment, kN, q,\n        sycl::ext::intel::experimental::property::usm::buffer_location(kBL2));\n    int *array_c = sycl::aligned_alloc_shared<int>(\n        kAlignment, kN, q,\n        sycl::ext::intel::experimental::property::usm::buffer_location(kBL3));\n\n    assert(array_a);\n    assert(array_b);\n    assert(array_c);\n\n    for (int i = 0; i < kN; i++) {\n      array_a[i] = i;\n      array_b[i] = 2 * i;\n    }\n\n    q.single_task(MultiMMIP{array_a, array_b, array_c, kN}).wait();\n    for (int i = 0; i < kN; i++) {\n      auto golden = 3 * i;\n      if (array_c[i] != golden) {\n        std::cout << \"ERROR! At index: \" << i << \" , expected: \" << golden\n                  << \" , found: \" << array_c[i] << \"\\n\";\n        passed = false;\n      }\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    free(array_a, q);\n    free(array_b, q);\n    free(array_c, q);\n\n    return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}"
    },
    {
        "label": "scheduler_target_fmax.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\nconstexpr unsigned kSeed = 1313;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass Default;\nclass ForcedHighFmax;\nclass ForcedDefaultFmax;\nclass ForcedDefaultFmaxII;\n\n#if defined(A10)\nconstexpr int kHighFmax = 480;\nconstexpr int kDefaultFmax = 240;\n#elif defined(CycloneV)\nconstexpr int kHighFmax = 280;\nconstexpr int kDefaultFmax = 200;\n#elif defined(S10)\nconstexpr int kHighFmax = 540;\nconstexpr int kDefaultFmax = 480;\n#elif defined(Agilex7)\nconstexpr int kHighFmax = 540;\nconstexpr int kDefaultFmax = 480;\n#else\n  std::static_assert(false, \"Invalid FPGA board macro\");\n#endif\n\n\n// Runs the Kernel\nvoid KernelRun(size_t size, const std::vector<char> &input_data,\n               std::vector<unsigned> &output_data) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    // create the SYCL device queue\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    buffer input_buffer(input_data);\n    buffer output_buffer(output_data);\n\n    q.submit([&](handler &h) {\n      accessor input_a(input_buffer, h, read_only);\n      accessor output_a(output_buffer, h, write_only, no_init);\n\n      h.single_task<Default>([=]() [[intel::kernel_args_restrict]] {\n        unsigned hash = 0;\n        for (size_t i = 0; i < size; i++) {\n          hash = (hash * kSeed) + input_a[i];\n        }\n        output_a[0] = hash;\n      });\n    });\n\n    q.submit([&](handler &h) {\n      accessor input_a(input_buffer, h, read_only);\n      accessor output_a(output_buffer, h, write_only, no_init);\n\n      h.single_task<ForcedHighFmax>([=]() [[intel::kernel_args_restrict,\n                                     intel::scheduler_target_fmax_mhz(kHighFmax)]] {\n        unsigned hash = 0;\n        for (size_t i = 0; i < size; i++) {\n          hash = (hash * kSeed) + input_a[i];\n        }\n        output_a[1] = hash;\n      });\n    });\n\n    q.submit([&](handler &h) {\n      accessor input_a(input_buffer, h, read_only);\n      accessor output_a(output_buffer, h, write_only, no_init);\n\n      h.single_task<ForcedDefaultFmax>([=]() [[intel::kernel_args_restrict,\n                                     intel::scheduler_target_fmax_mhz(kDefaultFmax)]] {\n        unsigned hash = 0;\n        for (size_t i = 0; i < size; i++) {\n          hash = (hash * kSeed) + input_a[i];\n        }\n        output_a[2] = hash;\n      });\n    });\n\n    q.submit([&](handler &h) {\n      accessor input_a(input_buffer, h, read_only);\n      accessor output_a(output_buffer, h, write_only, no_init);\n\n      h.single_task<ForcedDefaultFmaxII>([=]() [[intel::kernel_args_restrict,\n                                       intel::scheduler_target_fmax_mhz(kDefaultFmax)]] {\n        unsigned hash = 0;\n        [[intel::initiation_interval(1)]]  // NO-FORMAT: Attribute\n        for (size_t i = 0; i < size; i++) {\n          hash = (hash * kSeed) + input_a[i];\n        }\n        output_a[3] = hash;\n      });\n    });\n\n  } catch (exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}\n\ninline unsigned BKDRHashGolden(std::vector<char> input_data) {\n  unsigned hash = 0;\n  for (int i = 0; i < input_data.size(); ++i) {\n    hash = (hash * kSeed) + input_data[i];\n  }\n  return hash;\n}\n\nint main() {\n  // input string \"qr6KUBBmLtVUlX9\"\n  std::vector<char> input_data = {'q', 'r', '6', 'K', 'U', 'B', 'B', 'm',\n                                  'L', 't', 'V', 'U', 'l', 'X', '9'};\n  std::vector<unsigned> output_data(4);\n\n  KernelRun(input_data.size(), input_data, output_data);\n\n  bool passed = true;\n  unsigned golden = BKDRHashGolden(input_data);\n  if (output_data[0] != golden) {\n    std::cout << \"Kernel Default Output Mismatch: \\n\"\n              << \"output = \" << output_data[0] << \", golden = \" << golden\n              << \"\\n\";\n    passed = false;\n  }\n  if (output_data[1] != golden) {\n    std::cout << \"Kernel ForcedHighFmax Output Mismatch: \\n\"\n              << \"output = \" << output_data[1] << \", golden = \" << golden\n              << \"\\n\";\n    passed = false;\n  }\n  if (output_data[2] != golden) {\n    std::cout << \"Kernel ForcedDefaultFmax Output Mismatch: \\n\"\n              << \"output = \" << output_data[2] << \", golden = \" << golden\n              << \"\\n\";\n    passed = false;\n  }\n  if (output_data[3] != golden) {\n    std::cout << \"Kernel ForcedDefaultFmaxII Output Mismatch: \\n\"\n              << \"output = \" << output_data[3] << \", golden = \" << golden\n              << \"\\n\";\n    passed = false;\n  }\n\n  if (passed) {\n    std::cout << \"PASSED: all kernel results are correct.\\n\";\n  } else {\n    std::cout << \"FAILED\\n\";\n  }\n  return passed ? 0 : 1;\n}\n"
    },
    {
        "label": "read_only_cache.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include <chrono>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\nnamespace ext_oneapi = sycl::ext::oneapi;\n\nconstexpr int kLUTSize = 512;       // Size of the LUT.\nconstexpr int kNumOutputs = 131072; // Number of outputs.\nconstexpr double kNs = 1e9;         // number of nanoseconds in a second\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass SqrtTest;\n\n// Below are three different random number generators that are used to generate\n// arbitrary indices to be used when accessing the LUT. Each generator is\n// implemented using a \"Linear-Feedback Shift Register\" (LFSR).\nuint16_t rand1(uint16_t &index, uint16_t &bits) {\n  bits = ((index >> 0) ^ (index >> 3) ^ (index >> 4) ^ (index >> 5)) & 1u;\n  return index = (index >> 1) | (bits << 15);\n}\n\nuint16_t rand2(uint16_t &index, uint16_t &bits) {\n  bits = ((index >> 0) ^ (index >> 1) ^ (index >> 2) ^ (index >> 3)) & 1u;\n  return index = (index >> 1) | (bits << 15);\n}\n\nuint16_t rand3(uint16_t &index, uint16_t &bits) {\n  bits = ((index >> 0) ^ (index >> 1) ^ (index >> 2) ^ (index >> 5)) & 1u;\n  return index = (index >> 1) | (bits << 15);\n}\n\nevent runSqrtTest(sycl::queue &q, const std::vector<float> &sqrt_lut_vec,\n                  std::vector<float> &output_vec) {\n  buffer sqrt_lut_buf(sqrt_lut_vec);\n  buffer output_buf(output_vec);\n\n  event e = q.submit([&](handler &h) {\n    accessor sqrt_lut(sqrt_lut_buf, h, read_only,\n                      ext_oneapi::accessor_property_list{ext_oneapi::no_alias});\n    accessor output(\n        output_buf, h, write_only,\n        ext_oneapi::accessor_property_list{ext_oneapi::no_alias, no_init});\n\n    h.single_task<SqrtTest>([=]() {\n      uint16_t index = 0xFFFu; // An arbitrary non-zero starting state\n      uint16_t bits = 0;\n\n      for (int i = 0; i < kNumOutputs; i++)\n        output[i] = sqrt_lut[rand1(index, bits) % kLUTSize];\n\n      for (int i = 0; i < kNumOutputs; i++)\n        output[i] += sqrt_lut[rand2(index, bits) % kLUTSize];\n\n      for (int i = 0; i < kNumOutputs; i++)\n        output[i] += sqrt_lut[rand3(index, bits) % kLUTSize];\n    });\n  });\n  return e;\n}\n\nint main() {\n  // Host and kernel profiling\n  event e;\n  unsigned long t1_kernel, t2_kernel;\n  double time_kernel;\n\n  // Create input and output vectors\n  std::vector<float> sqrt_lut_vec(kLUTSize);\n  std::vector<float> output_vec(kNumOutputs);\n  for (int i = 0; i < kLUTSize; ++i) {\n    sqrt_lut_vec[i] = sycl::sqrt((float) i);\n  }\n\n// Create queue, get platform and device\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    auto prop_list =\n        sycl::property_list{sycl::property::queue::enable_profiling()};\n\n    sycl::queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    std::cout << \"\\nSQRT LUT size: \" << kLUTSize << \"\\n\";\n    std::cout << \"Number of outputs: \" << kNumOutputs << \"\\n\";\n\n    e = runSqrtTest(q, sqrt_lut_vec, output_vec);\n    e.wait();\n\n    // Compute kernel execution time\n    t1_kernel = e.get_profiling_info<info::event_profiling::command_start>();\n    t2_kernel = e.get_profiling_info<info::event_profiling::command_end>();\n    time_kernel = (t2_kernel - t1_kernel) / kNs;\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  // Compute the reference solution\n  uint16_t index = 0xFFFu; // An arbitrary non-zero starting state\n  uint16_t bits = 0;\n  float gold[kNumOutputs];\n  for (int i = 0; i < kNumOutputs; ++i)\n    gold[i] = sqrt_lut_vec[rand1(index, bits) % kLUTSize];\n\n  for (int i = 0; i < kNumOutputs; ++i)\n    gold[i] += sqrt_lut_vec[rand2(index, bits) % kLUTSize];\n\n  for (int i = 0; i < kNumOutputs; ++i)\n    gold[i] += sqrt_lut_vec[rand3(index, bits) % kLUTSize];\n\n  // Verify output and print pass/fail\n  bool passed = true;\n  int num_errors = 0;\n  for (int b = 0; b < kNumOutputs; b++) {\n    if (num_errors < 10 && output_vec[b] != gold[b]) {\n      passed = false;\n      std::cerr << \" (mismatch, expected \" << gold[b] << \")\\n\";\n      num_errors++;\n    }\n  }\n\n  if (passed) {\n    std::cout << \"Verification PASSED\\n\\n\";\n\n    // Report host execution time and throughput\n    std::cout.setf(std::ios::fixed);\n\n    // Input size in MB\n    constexpr double num_mb =\n        (static_cast<double>(kNumOutputs * sizeof(uint32_t))) / (1024 * 1024);\n\n    // Report kernel execution time and throughput\n    std::cout << \"Kernel execution time: \" << time_kernel << \" seconds\\n\";\n#if defined(CACHE_ENABLED)\n    std::cout << \"Kernel throughput with the read-only cache: \"\n#else\n    std::cout << \"Kernel throughput: \"\n#endif\n              << (num_mb / time_kernel) << \" MB/s\\n\\n\";\n  } else {\n    std::cerr << \"Verification FAILED\\n\";\n    return 1;\n  }\n  return 0;\n}\n"
    },
    {
        "label": "printf.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <iostream>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include \"exception_handler.hpp\"\n\n// According to the OpenCL C spec, the format string must be in the constant\n// address space. To simplify code when invoking printf, the following macros\n// are defined.\n\n#ifdef __SYCL_DEVICE_ONLY__\n#define CL_CONSTANT __attribute__((opencl_constant))\n#else\n#define CL_CONSTANT\n#endif\n\nusing namespace sycl;\n\n#define PRINTF(format, ...)                                    \\\n  {                                                            \\\n    static const CL_CONSTANT char _format[] = format;          \\\n    ext::oneapi::experimental::printf(_format, ##__VA_ARGS__); \\\n  }\n\nclass BasicKernel;\n\nint main(int argc, char* argv[]) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  queue q(selector);\n\n  auto device = q.get_device();\n\n  std::cout << \"Running on device: \"\n            << device.get_info<sycl::info::device::name>().c_str()\n            << std::endl;\n\n  // Create some kernel arguments for printing.\n  int x = 123;\n  float y = 1.0f;\n  try {\n    q.submit([&](handler& h) {\n       h.single_task<BasicKernel>([=]() {\n         PRINTF(\"Result1: Hello, World!\\n\");\n         PRINTF(\"Result2: %%\\n\");\n         PRINTF(\"Result3: %d\\n\", x);\n         PRINTF(\"Result4: %u\\n\", 123);\n         PRINTF(\"Result5: %.2f\\n\", y);\n         PRINTF(\"Result6: print slash_n \\\\n \\n\");\n         PRINTF(\"Result7: Long: %ld\\n\", 650000L);\n         PRINTF(\"Result8: Preceding with blanks: %10d \\n\", 1977);\n         PRINTF(\"Result9: Preceding with zeros: %010d \\n\", 1977);\n         PRINTF(\"Result10: Some different radices: %d %x %o %#x %#o \\n\", 100,\n                100, 100, 100, 100);\n         PRINTF(\"Result11: ABC%c\\n\", 'D');\n       });\n     })\n        .wait();\n  } catch (sycl::exception const& e) {\n    std::cout << \"Caught a synchronous SYCL exception: \" << e.what() << \"\\n\";\n    std::cout << \"FAILED\\n\";\n    std::terminate();\n  }\n  return 0;\n}"
    },
    {
        "label": "kernel_args_restrict.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <algorithm>\n#include <numeric>\n#include <vector>\n\n#include \"exception_handler.hpp\"\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\nusing namespace sycl;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass IDKernelArgsRestrict_Lambda;\nclass IDConservative_Lambda;\nclass IDKernelArgsRestrict_Functor;\nclass IDConservative_Functor;\n\ntemplate <class InputAcc, class OutputAcc>\nstruct ArgsRestrictFunctor {\n  InputAcc in;\n  OutputAcc out;\n  size_t len;\n\n  [[intel::kernel_args_restrict]]  // NO-FORMAT: Attribute\n  void operator()() const {\n    for (int idx = 0; idx < len; ++idx) {\n      out[idx] = in[idx];\n    }\n  }\n};\n\ntemplate <class InputAcc, class OutputAcc>\nstruct ConservativeFunctor {\n  InputAcc in;\n  OutputAcc out;\n  size_t len;\n\n  void operator()() const {\n    for (int idx = 0; idx < len; ++idx) {\n      out[idx] = in[idx];\n    }\n  }\n};\n\n// Return the execution time of the event, in seconds\ndouble GetExecutionTime(const event &e) {\n  double start_k = e.get_profiling_info<info::event_profiling::command_start>();\n  double end_k = e.get_profiling_info<info::event_profiling::command_end>();\n  double kernel_time = (end_k - start_k) * 1e-9; // ns to s\n  return kernel_time;\n}\n\nvoid RunKernels(size_t size, std::vector<int> &in, std::vector<int> &conservative_lambda_out,\n                std::vector<int> &restrict_lambda_out, std::vector<int> &conservative_functor_out,\n                std::vector<int> &restrict_functor_out) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    // create the SYCL device queue\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n    \n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    buffer in_buf(in);\n\n    // Below, we submit two SYCL kernels defined in lambda coding style.\n    // submit the task that DOES NOT apply the kernel_args_restrict attribute\n    buffer conservative_lambda_out_buf(conservative_lambda_out);\n    auto e_conservative_lambda = q.submit([&](handler &h) {\n      accessor in_acc(in_buf, h, read_only);\n      accessor out_acc(conservative_lambda_out_buf, h, write_only, no_init);\n\n      h.single_task<IDConservative_Lambda>([=]() {\n        for (size_t i = 0; i < size; i++) {\n          out_acc[i] = in_acc[i];\n        }\n      });\n    });\n\n    // submit the task that DOES apply the kernel_args_restrict attribute\n    buffer restrict_lambda_out_buf(restrict_lambda_out);\n    auto e_restrict_lambda = q.submit([&](handler &h) {\n      accessor in_acc(in_buf, h, read_only);\n      accessor out_acc(restrict_lambda_out_buf, h, write_only, no_init);\n\n      h.single_task<IDKernelArgsRestrict_Lambda>([=  // NO-FORMAT: Attribute\n      ]() [[intel::kernel_args_restrict]] {          // NO-FORMAT: Attribute\n        for (size_t i = 0; i < size; i++) {\n          out_acc[i] = in_acc[i];\n        }\n      });\n    });\n\n    // Below, we submit two SYCL kernels defined in functor coding style.\n    // submit the task that DOES NOT apply the kernel_args_restrict attribute\n    buffer conservative_functor_out_buf(conservative_functor_out);\n    auto e_conservative_functor = q.submit([&](handler &h) {\n      accessor in_acc(in_buf, h, read_only);\n      accessor out_acc(conservative_functor_out_buf, h, write_only, no_init);\n\n      h.single_task<IDConservative_Functor>(\n        ConservativeFunctor<decltype(in_acc), decltype(out_acc)>{in_acc, out_acc, size}\n      );\n    });\n\n    // submit the task that DOES apply the kernel_args_restrict attribute\n    buffer restrict_functor_out_buf(restrict_functor_out);\n    auto e_restrict_functor = q.submit([&](handler &h) {\n      accessor in_acc(in_buf, h, read_only);\n      accessor out_acc(restrict_functor_out_buf, h, write_only, no_init);\n\n      h.single_task<IDKernelArgsRestrict_Functor>(\n        ArgsRestrictFunctor<decltype(in_acc), decltype(out_acc)>{in_acc, out_acc, size}\n      );\n    });\n\n    // measure the execution time of each kernel\n    double size_mb = (size * sizeof(int)) / (1024 * 1024);\n    double conservative_lambda_time = GetExecutionTime(e_conservative_lambda);\n    double restrict_lambda_time = GetExecutionTime(e_restrict_lambda);\n    double conservative_functor_time = GetExecutionTime(e_conservative_functor);\n    double restrict_functor_time = GetExecutionTime(e_restrict_functor);\n\n    std::cout << \"Size of vector: \" << size << \" elements\\n\";\n    std::cout << \"Lambda kernel throughput without attribute: \" << (size_mb / conservative_lambda_time)\n              << \" MB/s\\n\";\n    std::cout << \"Lambda kernel throughput with attribute: \" << (size_mb / restrict_lambda_time)\n              << \" MB/s\\n\";\n    std::cout << \"Functor kernel throughput without attribute: \" << (size_mb / conservative_functor_time)\n              << \" MB/s\\n\";\n    std::cout << \"Functor kernel throughput with attribute: \" << (size_mb / restrict_functor_time)\n              << \" MB/s\\n\";\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  // Exiting the 'try' scope above, where the buffers were declared, will cause \n  // the buffer destructors to be called which will wait until the kernels that\n  // use them to finish and copy the data back to the host (if the buffer was\n  // written to).\n  // Therefore, at this point in the code, we know that the kernels have\n  // finished and the data has been transferred back to the host (in the\n  // 'nr_out' and 'r_out' vectors).\n}\n\n// Checks if the content of two vectors are equal up to a specified size.\n// The function prints a message indicating the index at which the mismatch occurred, \n// and the name of the kernel of which the result is checked, specified by `kernel_name`.\nbool IsEqual(std::vector<int> &in, std::vector<int> &out, std::string &&kernel_name, size_t size) {\n  bool equal {true};\n  for (size_t i = 0; i < size; i++) {\n    if (in[i] != out[i]) {\n      std::cout << \"FAILED: mismatch at entry \" << i\n                << \" of \" << kernel_name\n                << \" kernel output\\n\";\n      std::cout << \" (\" << in[i] << \" != \" << out[i]\n                << \", in[i] != out[i])\\n\";\n      equal = false;\n      break;\n    }\n  }\n  return equal;\n}\n\nint main(int argc, char* argv[]) {\n  // size of vectors to copy, allow user to change it from the command line\n#if defined(FPGA_SIMULATOR)\n  size_t size = 5000; // smaller size to keep the default runtime reasonable\n#else\n  size_t size = 5000000;\n#endif\n\n  if (argc > 1) size = atoi(argv[1]);\n\n  // input/output data\n  std::vector<int> in(size);\n  std::vector<int> conservative_lambda_out(size), restrict_lambda_out(size);\n  std::vector<int> conservative_functor_out(size), restrict_functor_out(size);\n\n  // generate some input data\n  std::iota(in.begin(), in.end(), 0);\n\n  // clear the output data\n  std::fill(conservative_lambda_out.begin(), conservative_lambda_out.end(), -1);\n  std::fill(restrict_lambda_out.begin(), restrict_lambda_out.end(), -1);\n  std::fill(conservative_functor_out.begin(), conservative_functor_out.end(), -1);\n  std::fill(restrict_functor_out.begin(), restrict_functor_out.end(), -1);\n\n  // Run the kernels\n  RunKernels(size, in, conservative_lambda_out, restrict_lambda_out, conservative_functor_out, restrict_functor_out);\n\n  // validate the results\n  bool passed = true;\n\n  passed &= IsEqual(in, conservative_lambda_out, \"IDConservative_Lambda\", size);\n  passed &= IsEqual(in, restrict_lambda_out, \"IDKernelArgsRestrict_Lambda\", size);\n  passed &= IsEqual(in, conservative_functor_out, \"IDConservative_Functor\", size);\n  passed &= IsEqual(in, restrict_functor_out, \"IDKernelArgsRestrict_Functor\", size);\n\n  if (passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 0;\n  }\n}\n"
    },
    {
        "label": "pipes.cpp",
        "data": "#include <iomanip>\n#include <iostream>\n#include <numeric>\n#include <vector>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\nusing ProducerToConsumerPipe = ext::intel::pipe< // Defined in the SYCL headers.\n    class ProducerConsumerPipeId,                // An identifier for the pipe.\n    int,                                         // The type of data in the pipe.\n    4>;                                          // The capacity of the pipe.\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass ProducerTutorial;\nclass ConsumerTutorial;\n\n// The Producer kernel reads data from a SYCL buffer and writes it to\n// a pipe. This transfers the input data from the host to the Consumer kernel\n// that is running concurrently.\nevent Producer(queue &q, buffer<int, 1> &input_buffer) {\n  std::cout << \"Enqueuing producer...\\n\";\n\n  auto e = q.submit([&](handler &h) {\n    accessor input_accessor(input_buffer, h, read_only);\n    size_t num_elements = input_buffer.size();\n\n    h.single_task<ProducerTutorial>([=]() {\n      for (size_t i = 0; i < num_elements; ++i) {\n        ProducerToConsumerPipe::write(input_accessor[i]);\n      }\n    });\n  });\n\n  return e;\n}\n\n// An example of some simple work, to be done by the Consumer kernel\n// on the input data\nint ConsumerWork(int i) { return i * i; }\n\n// The Consumer kernel reads data from the pipe, performs some work\n// on the data, and writes the results to an output buffer\nevent Consumer(queue &q, buffer<int, 1> &out_buf) {\n  std::cout << \"Enqueuing consumer...\\n\";\n\n  auto e = q.submit([&](handler &h) {\n    accessor out_accessor(out_buf, h, write_only, no_init);\n    size_t num_elements = out_buf.size();\n\n    h.single_task<ConsumerTutorial>([=]() {\n      for (size_t i = 0; i < num_elements; ++i) {\n        // read the input from the pipe\n        int input = ProducerToConsumerPipe::read();\n\n        // do work on the input\n        int answer = ConsumerWork(input);\n\n        // write the result to the output buffer\n        out_accessor[i] = answer;\n      }\n    });\n  });\n\n  return e;\n}\n\nint main(int argc, char *argv[]) {\n  // Default values for the buffer size is based on a reasonable runtime for \n  // different targets\n#if defined(FPGA_SIMULATOR)\n  size_t array_size = 1 << 7;\n#elif defined(FPGA_EMULATOR)\n  size_t array_size = 1 << 12;\n#else\n  size_t array_size = 1 << 20;\n#endif\n\n  // allow the user to change the buffer size at the command line\n  if (argc > 1) {\n    std::string option(argv[1]);\n    if (option == \"-h\" || option == \"--help\") {\n      std::cout << \"Usage: \\n./pipes <data size>\\n\\nFAILED\\n\";\n      return 1;\n    } else {\n      array_size = atoi(argv[1]);\n    }\n  }\n\n  std::cout << \"Input Array Size: \" << array_size << \"\\n\";\n\n  std::vector<int> producer_input(array_size, -1);\n  std::vector<int> consumer_output(array_size, -1);\n\n  // Initialize the input data with random numbers smaller than 46340.\n  // Any number larger than this will have integer overflow when squared.\n  constexpr int max_val = 46340;\n  for (size_t i = 0; i < array_size; i++) {\n    producer_input[i] = rand() % max_val;\n  }\n\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  event producer_event, consumer_event;\n\n  try {\n    // property list to enable SYCL profiling for the device queue\n    auto props = property_list{property::queue::enable_profiling()};\n\n    // create the device queue with SYCL profiling enabled\n    queue q(selector, fpga_tools::exception_handler, props);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // create the producer and consumer buffers\n    buffer producer_buffer(producer_input);\n    buffer consumer_buffer(consumer_output);\n\n    // Run the two kernels concurrently. The Producer kernel sends\n    // data via a pipe to the Consumer kernel.\n    producer_event = Producer(q, producer_buffer);\n    consumer_event = Consumer(q, consumer_buffer);\n\n  } catch (exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  // At this point, the producer_buffer and consumer_buffer have gone out\n  // of scope. This will cause their destructors to be called, which will in\n  // turn block until the Producer and Consumer kernels are finished and the\n  // output data is copied back to the host. Therefore, at this point it is\n  // safe and correct to access the contents of the consumer_output vector.\n\n  // start and end time of the Producer kernel\n  double p_start =\n      producer_event\n          .get_profiling_info<sycl::info::event_profiling::command_start>();\n  double p_end =\n      producer_event\n          .get_profiling_info<sycl::info::event_profiling::command_end>();\n\n  // start and end time of the Consumer kernel\n  double c_start =\n      consumer_event\n          .get_profiling_info<sycl::info::event_profiling::command_start>();\n  double c_end =\n      consumer_event\n          .get_profiling_info<sycl::info::event_profiling::command_end>();\n\n  // the total application time\n  double total_time_ms = (c_end - p_start) * 1e-6;\n\n  // the input size in MBs\n  double input_size_mb = array_size * sizeof(int) * 1e-6;\n\n  // the total application throughput\n  double throughput_mbs = input_size_mb / (total_time_ms * 1e-3);\n\n  // Print the start times normalized to the start time of the producer.\n  // i.e. the producer starts at 0ms and the other start/end times are\n  // reported as differences to that number (+X ms).\n  std::cout << std::fixed << std::setprecision(3);\n  std::cout << \"\\n\";\n  std::cout << \"Profiling Info\\n\";\n  std::cout << \"\\tProducer:\\n\";\n  std::cout << \"\\t\\tStart time: \" << 0 << \" ms\\n\";\n  std::cout << \"\\t\\tEnd time: +\" << (p_end - p_start) * 1e-6 << \" ms\\n\";\n  std::cout << \"\\t\\tKernel Duration: \" << (p_end - p_start) * 1e-6 << \" ms\\n\";\n  std::cout << \"\\tConsumer:\\n\";\n  std::cout << \"\\t\\tStart time: +\" << (c_start - p_start) * 1e-6 << \" ms\\n\";\n  std::cout << \"\\t\\tEnd time: +\" << (c_end - p_start) * 1e-6 << \" ms\\n\";\n  std::cout << \"\\t\\tKernel Duration: \" << (c_end - c_start) * 1e-6 << \" ms\\n\";\n  std::cout << \"\\tDesign Duration: \" << total_time_ms << \" ms\\n\";\n  std::cout << \"\\tDesign Throughput: \" << throughput_mbs << \" MB/s\\n\";\n  std::cout << \"\\n\";\n\n  // Verify the result\n  for (size_t i = 0; i < array_size; i++) {\n    if (consumer_output[i] != ConsumerWork(producer_input[i])) {\n      std::cout << \"input = \" << producer_input[i]\n                << \" expected: \" << ConsumerWork(producer_input[i])\n                << \" got: \" << consumer_output[i] << \"\\n\";\n      std::cout << \"FAILED: The results are incorrect\\n\";\n      return 1;\n    }\n  }\n  std::cout << \"PASSED: The results are correct\\n\";\n  return 0;\n}\n"
    },
    {
        "label": "ac_fixed.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/ac_types/ac_fixed.hpp>\n#include <sycl/ext/intel/ac_types/ac_fixed_math.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include <iomanip>  // for std::setprecision\n#include <cmath>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// Type aliases for ac_fixed types\nusing fixed_10_3_t = ac_fixed<10, 3, true>;\nusing fixed_9_2_t = ac_fixed<9, 2, true>;\n\n// Quantization mode `AC_RND`: round towards plus infinity\n// Overflow mode `AC_SAT`: saturate to max and min when overflow happens\n// For the other quantization and overflow modes, refer to section 2.1 of\n// \"Algorithmic C (AC) Datatypes\" document.\nusing fixed_20_10_t = ac_fixed<20, 10, true, AC_RND, AC_SAT>;\n\n// Forward declare the kernel name in the global scope.\n// This is a FPGA best practice that reduces name mangling in the reports.\nclass ConstructFromFloat;\nclass ConstructFromACFixed;\nclass CalculateWithFloat;\nclass CalculateWithACFixed;\n\n// Not recommended Usage example:\n// Convert dynamic float value inside the kernel\nvoid TestConstructFromFloat(queue &q, const float &x, fixed_20_10_t &ret) {\n  buffer<float, 1> inp_buffer(&x, 1);\n  buffer<fixed_20_10_t, 1> ret_buffer(&ret, 1);\n\n  q.submit([&](handler &h) {\n    accessor in_acc{inp_buffer, h, read_only};\n    accessor out_acc{ret_buffer, h, write_only, no_init};\n\n    h.single_task<ConstructFromFloat>([=] {\n      fixed_20_10_t t(in_acc[0]);\n      fixed_20_10_t some_offset(0.5f);\n      out_acc[0] = t + some_offset;\n    });\n  });\n}\n\n// Recommended Usage example:\n// Convert dynamic float value outside the kernel\nvoid TestConstructFromACFixed(queue &q, const fixed_20_10_t &x,\n                              fixed_20_10_t &ret) {\n  buffer<fixed_20_10_t, 1> inp_buffer(&x, 1);\n  buffer<fixed_20_10_t, 1> ret_buffer(&ret, 1);\n\n  q.submit([&](handler &h) {\n    accessor in_acc{inp_buffer, h, read_only};\n    accessor out_acc{ret_buffer, h, write_only};\n\n    h.single_task<ConstructFromACFixed>([=] {\n      fixed_20_10_t t(in_acc[0]);\n      fixed_20_10_t some_offset(0.5f);\n      out_acc[0] = t + some_offset;\n    });\n  });\n}\n\nvoid TestCalculateWithFloat(queue &q, const float &x, float &ret) {\n  buffer<float, 1> inp_buffer(&x, 1);\n  buffer<float, 1> ret_buffer(&ret, 1);\n\n  q.submit([&](handler &h) {\n    accessor x{inp_buffer, h, read_only};\n    accessor res{ret_buffer, h, write_only, no_init};\n\n    h.single_task<CalculateWithFloat>([=] {\n      float sin_x = sinf(x[0]);\n      float cos_x = cosf(x[0]);\n      res[0] = sycl::sqrt(sin_x * sin_x + cos_x * cos_x);\n    });\n  });\n}\n\n// Please refer to ac_fixed_math.hpp header file for fixed point math\n// functions' type deduction rule. In this case, following those rules:\n// I, W, S are input type template parameter (ac_fixed<W, I, S>)\n// rI, rW, rS are output type template parameter (ac_fixed<rW, rI, rS>)\n//* Function Name         Type Propagation Rule\n//* sqrt_fixed             rI = I, rW = W, rS = S\n//* sin_fixed              For signed (S == true), rI == 2, rW =  W - I + 2;\n//*                        For unsigned (S == false), I == 1, rW =  W - I + 1\n//* cos_fixed              For signed (S == true), rI == 2, rW =  W - I + 2;\n//*                        For unsigned (S == false), I == 1, rW =  W - I + 1\nvoid TestCalculateWithACFixed(queue &q, const fixed_10_3_t &x,\n                              fixed_9_2_t &ret) {\n  buffer<fixed_10_3_t, 1> inp_buffer(&x, 1);\n  buffer<fixed_9_2_t, 1> ret_buffer(&ret, 1);\n\n  q.submit([&](handler &h) {\n    accessor x{inp_buffer, h, read_only};\n    accessor res{ret_buffer, h, write_only, no_init};\n\n    h.single_task<CalculateWithACFixed>([=] {\n      fixed_9_2_t sin_x = sin_fixed(x[0]);\n      fixed_9_2_t cos_x = cos_fixed(x[0]);\n      // The RHS expression evaluates to a larger `ac_fixed`, which gets\n      // truncated to fit in res[0].\n      res[0] = sqrt_fixed(sin_x * sin_x + cos_x * cos_x);\n    });\n  });\n}\n\nint main() {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    // Create the SYCL device queue\n    queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // I. Constructing `ac_fixed` Numbers\n    std::cout << \"1. Testing Constructing ac_fixed from float or ac_fixed:\\n\";\n\n    fixed_20_10_t a;\n    TestConstructFromFloat(q, 3.1415f, a);\n    std::cout << \"Constructed from float:\\t\\t\" << a << \"\\n\";\n\n    fixed_20_10_t b = 3.1415f;\n    fixed_20_10_t c;\n    TestConstructFromACFixed(q, b, c);\n    std::cout << \"Constructed from ac_fixed:\\t\" << c << \"\\n\\n\";\n\n    // II. Using `ac_fixed` Math Functions\n    std::cout\n        << \"2. Testing calculation with float or ac_fixed math functions:\\n\";\n\n    constexpr int kSize = 5;\n    constexpr float inputs[kSize] = {-0.807991899423f, -2.09982907558f,\n                                     -0.742066235466f, -2.33217071676f,\n                                     1.14324158042f};\n\n    // quantum: the minimum positive value this type can represent\n    // Quantum is 1 / 2 ^ (W - I), where W and I are the total width and the\n    // integer width of the ac_fixed number\n    constexpr fixed_9_2_t quantum = 0.0078125f;\n\n    // for fixed point, the error should be less than 1 quantum of data type\n    // (1 / 2^(W - I))\n    constexpr fixed_9_2_t epsilon_fixed_9_2 = quantum;\n    constexpr float epsilon_float = 1.0f / (1.0f * float(1 << 20));\n\n    std::cout << \"MAX DIFF (quantum) for ac_fixed<10, 3, true>:\\t\"\n              << epsilon_fixed_9_2.to_double()\n              << \"\\nMAX DIFF for float:\\t\\t\\t\\t\" << epsilon_float << \"\\n\\n\";\n\n    bool pass = true;\n    for (int i = 0; i < kSize; i++) {\n      fixed_10_3_t fixed_type_input = inputs[i];\n      float float_type_input = inputs[i];\n\n      // declare output and diff variable\n      fixed_9_2_t fixed_type_result;\n      TestCalculateWithACFixed(q, fixed_type_input, fixed_type_result);\n      float float_type_result;\n      TestCalculateWithFloat(q, float_type_input, float_type_result);\n\n      // expected result is 1.0 = sqrt(sin^2(x) + cos^2(x))\n      double fixed_diff = abs(fixed_type_result.to_double() - 1.0);\n      double float_diff = abs(float_type_result - 1.0);\n\n      std::cout << std::setprecision(8);\n      std::cout << \"Input \" << i << \":\\t\\t\\t\" << inputs[i]\n                << \"\\nresult(fixed point):\\t\\t\" << fixed_type_result.to_double()\n                << \"\\ndifference(fixed point):\\t\" << fixed_diff\n                << \"\\nresult(float):\\t\\t\\t\" << float_type_result\n                << \"\\ndifference(float):\\t\\t\" << float_diff << \"\\n\\n\";\n\n      // check differences\n      if (fixed_diff > epsilon_fixed_9_2 || float_diff > epsilon_float) {\n        pass = false;\n      }\n    }\n\n    if (pass) {\n      std::cout << \"PASSED: all kernel results are correct.\\n\";\n    } else {\n      std::cout << \"ERROR\\n\";\n    }\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return 0;\n}\n"
    },
    {
        "label": "mem_channel.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include <chrono>\n#include <numeric>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n#if defined(FPGA_SIMULATOR)\nconstexpr size_t vector_size = 10000; // size of input vectors\n#else\nconstexpr size_t vector_size = 1000000; // size of input vectors\n#endif\nconstexpr double kNs = 1e9;             // number of nanoseconds in a second\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass VecAdd;\n\nevent runVecAdd(sycl::queue &q, const std::vector<int> &a_vec,\n                const std::vector<int> &b_vec, const std::vector<int> &c_vec,\n                std::vector<int> &sum_vec) {\n#if defined(NO_INTERLEAVING) && defined(TWO_CHANNELS)\n  buffer a_buf(a_vec, {property::buffer::mem_channel{1}});\n  buffer b_buf(b_vec, {property::buffer::mem_channel{2}});\n  buffer c_buf(c_vec, {property::buffer::mem_channel{1}});\n  buffer sum_buf(sum_vec, {property::buffer::mem_channel{2}});\n#elif defined(NO_INTERLEAVING) && defined(FOUR_CHANNELS)\n  buffer a_buf(a_vec, {property::buffer::mem_channel{1}});\n  buffer b_buf(b_vec, {property::buffer::mem_channel{2}});\n  buffer c_buf(c_vec, {property::buffer::mem_channel{3}});\n  buffer sum_buf(sum_vec, {property::buffer::mem_channel{4}});\n#else\n  buffer a_buf(a_vec);\n  buffer b_buf(b_vec);\n  buffer c_buf(c_vec);\n  buffer sum_buf(sum_vec);\n#endif\n\n  event e = q.submit([&](handler &h) {\n    accessor a(a_buf, h, read_only);\n    accessor b(b_buf, h, read_only);\n    accessor c(c_buf, h, read_only);\n    accessor sum(sum_buf, h, write_only, no_init);\n\n    h.single_task<VecAdd>([=]() [[intel::kernel_args_restrict]] {\n      for (int i = 0; i < vector_size; i++)\n        sum[i] = a[i] + b[i] + c[i];\n    });\n  });\n  return e;\n}\n\nint main() {\n  // Host and kernel profiling\n  event e;\n  uint64_t t1_kernel, t2_kernel;\n  double time_kernel;\n\n  // Create input and output vectors\n  std::vector<int> a, b, c, sum_fpga, sum_cpu;\n  a.resize(vector_size);\n  b.resize(vector_size);\n  c.resize(vector_size);\n  sum_fpga.resize(vector_size);\n  sum_cpu.resize(vector_size);\n\n  // Initialize input vectors with values from 0 to vector_size - 1\n  std::iota(a.begin(), a.end(), 0);\n  std::iota(b.begin(), b.end(), 0);\n  std::iota(c.begin(), c.end(), 0);\n\n// Create queue, get platform and device\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    auto prop_list =\n        sycl::property_list{sycl::property::queue::enable_profiling()};\n\n    sycl::queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    std::cout << \"\\nVector size: \" << vector_size << \"\\n\";\n\n    e = runVecAdd(q, a, b, c, sum_fpga);\n    e.wait();\n\n    // Compute kernel execution time\n    t1_kernel = e.get_profiling_info<info::event_profiling::command_start>();\n    t2_kernel = e.get_profiling_info<info::event_profiling::command_end>();\n    time_kernel = (t2_kernel - t1_kernel) / kNs;\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  // Compute the reference solution\n  for (int i = 0; i < vector_size; ++i)\n    sum_cpu[i] = a[i] + b[i] + c[i];\n\n  // Verify output and print pass/fail\n  bool passed = true;\n  int num_errors = 0;\n  for (int b = 0; b < vector_size; b++) {\n    if (num_errors < 10 && sum_fpga[b] != sum_cpu[b]) {\n      passed = false;\n      std::cerr << \" (mismatch, expected \" << sum_cpu[b] << \")\\n\";\n      num_errors++;\n    }\n  }\n\n  if (passed) {\n    std::cout << \"Verification PASSED\\n\\n\";\n\n    // Report host execution time and throughput\n    std::cout.setf(std::ios::fixed);\n\n    // Input size in MB\n    constexpr double num_mb = (vector_size * sizeof(uint32_t)) / (1024 * 1024);\n\n    // Report kernel execution time and throughput\n    std::cout << \"Kernel execution time: \" << time_kernel << \" seconds\\n\";\n#if !defined(NO_INTERLEAVING)\n    std::cout << \"Kernel throughput: \" << (num_mb / time_kernel) << \" MB/s\\n\\n\";\n#else\n    std::cout << \"Kernel throughput without burst-interleaving: \"\n              << (num_mb / time_kernel) << \" MB/s\\n\\n\";\n#endif\n  } else {\n    std::cerr << \"Verification FAILED\\n\";\n    return 1;\n  }\n  return 0;\n}\n"
    },
    {
        "label": "fpga_reg.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\nusing namespace std;\n\n// Artificial coefficient and offset data for our math function\n#if defined(FPGA_SIMULATOR)\nconstexpr size_t kSize = 8;\nconstexpr int kCoeff[kSize] = {1,  2,  3,  4,  5,  6,  7,  8};\nconstexpr int kOffset[kSize] = {8,  7,  6,  5,  4,  3,  2,  1};\n#else\nconstexpr size_t kSize = 64;\nconstexpr int kCoeff[kSize] = {\n            1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16,\n            17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\n            33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,\n            49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64};\nconstexpr int kOffset[kSize] = {\n            17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\n            49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,\n            33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,\n            16, 15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1};\n#endif\n\n// The function our kernel will compute\n// The \"golden result\" will be computed on the host to check the kernel result.\nvector<int> GoldenResult(vector<int> vec) {\n\n  // The coefficients will be modified with each iteration of the outer loop.\n  int coeff[kSize];\n  for (size_t i = 0; i < kSize; i++) {\n    coeff[i] = kCoeff[i];\n  }\n\n  for (int &val : vec) {\n    // Do some arithmetic\n    int acc = 0;\n    for (size_t i = 0; i < kSize; i++) {\n      acc += coeff[i] * (val + kOffset[i]);\n    }\n\n    // Update coeff by rotating the values of the array\n    int tmp = coeff[0];\n    for (size_t i = 0; i < kSize - 1; i++) {\n      coeff[i] = coeff[i + 1];\n    }\n    coeff[kSize - 1] = tmp;\n\n    // Result\n    val = acc;\n  }\n\n  return vec;\n}\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass SimpleMath;\n\nvoid RunKernel(const std::vector<int> &vec_a,\n               std::vector<int> &vec_r) {\n  // Run the kernel on either the FPGA emulator, or FPGA simulator, or FPGA\n  // hardware\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  size_t input_size = vec_a.size();\n\n  try {\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n              \n    buffer device_a(vec_a);\n    buffer device_r(vec_r);\n\n    event e = q.submit([&](handler &h) {\n      accessor a(device_a, h, read_only);\n      accessor r(device_r, h, write_only, no_init);\n\n      // FPGA-optimized kernel\n      // Using kernel_args_restrict tells the compiler that the input\n      // and output buffers won't alias.\n      h.single_task<class SimpleMath>([=]() [[intel::kernel_args_restrict]] {\n\n        // Force the compiler to implement the coefficient array in FPGA\n        // pipeline registers rather than in on-chip memory.\n        [[intel::fpga_register]] int coeff[kSize];\n        for (size_t i = 0; i < kSize; i++) {\n          coeff[i] = kCoeff[i];\n        }\n\n        // The compiler will pipeline the outer loop.\n        for (size_t i = 0; i < input_size; ++i) {\n          int acc = 0;\n          int val = a[i];\n\n          // Fully unroll the accumulator loop.\n          // All of the unrolled operations can be freely scheduled by the\n          // oneAPI DPC++/C++ Compiler's FPGA backend as part of a common data pipeline.\n          #pragma unroll\n          for (size_t j = 0; j < kSize; j++) {\n#ifdef USE_FPGA_REG\n            // Use fpga_reg to insert a register between the copy of val used\n            // in each unrolled iteration.\n            val = ext::intel::fpga_reg(val);\n            // Since val is held constant across the kSize unrolled iterations,\n            // the FPGA hardware structure of val's distribution changes from a\n            // kSize-way fanout (without fpga_reg) to a chain of of registers\n            // with intermediate tap offs. Refer to the diagram in the README.\n\n            // Use fpga_reg to insert a register between each step in the acc\n            // adder chain.\n            acc = ext::intel::fpga_reg(acc) + (coeff[j] * (val + kOffset[j]));\n            // This transforms a compiler-inferred adder tree into an adder\n            // chain, altering the structure of the pipeline. Refer to the\n            // diagram in the README.\n#else\n            // Without fpga_reg, the compiler schedules the operations here\n            // according to its default optimization heuristics.\n            acc += (coeff[j] * (val + kOffset[j]));\n#endif\n          }\n\n          // Rotate the values of the coefficient array.\n          // The loop is fully unrolled. This is a canonical code structure;\n          // the oneAPI DPC++/C++ Compiler's FPGA backend infers a shift register here.\n          int tmp = coeff[0];\n          #pragma unroll\n          for (size_t j = 0; j < kSize - 1; j++) {\n            coeff[j] = coeff[j + 1];\n          }\n          coeff[kSize - 1] = tmp;\n\n          // Result\n          r[i] = acc;\n        }\n      });\n    });\n\n    // Measure kernel execution time\n    double start = e.get_profiling_info<info::event_profiling::command_start>();\n    double end = e.get_profiling_info<info::event_profiling::command_end>();\n    // Convert from nanoseconds to milliseconds.\n    double kernel_time = (end - start) * 1e-6;\n\n    // Kernel consists of two nested loops with 3 operations in the innermost\n    // loop: 2 additions and 1 multiplication operation.\n    size_t num_ops_per_kernel = input_size * kSize * 3;\n    cout << \"Throughput for kernel with input size \" << input_size\n         << \" and coefficient array size \" << kSize << \": \";\n    cout << std::fixed << std::setprecision(6)\n         << ((double)num_ops_per_kernel / kernel_time) / 1.0e6 << \" GFlops\\n\";\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}\n\nint main(int argc, char *argv[]) {\n#if defined(FPGA_SIMULATOR)\n  size_t input_size = 10;\n#else\n  size_t input_size = 1e6;\n#endif\n\n  // Optional command line override of default input size\n  if (argc > 1) {\n    string option(argv[1]);\n    if (option == \"-h\" || option == \"--help\") {\n      cout << \"Usage: \\n<executable> <input data size>\\n\\nFAILED\\n\";\n      return 1;\n    } else {\n      input_size = stoi(option);\n    }\n  }\n\n  // Initialize input vector\n  constexpr int max_val = 1<<10; // Conservative max to avoid integer overflow\n  vector<int> vec_a(input_size);\n  for (size_t i = 0; i < input_size; i++) {\n    vec_a[i] = rand() % max_val;\n  }\n  // Kernel result vector\n  vector<int> vec_r(input_size);\n\n  RunKernel(vec_a, vec_r);\n\n  // Test the results.\n  vector<int> golden_ref = GoldenResult(vec_a);\n  bool correct = true;\n  for (size_t i = 0; i < input_size; i++) {\n    if (vec_r[i] != golden_ref[i]) {\n      cout << \"Found mismatch at \" << i << \", \"\n           << vec_r[i] << \" != \" << golden_ref[i] << \"\\n\";\n      correct = false;\n    }\n  }\n\n  if (correct) {\n    cout << \"PASSED: Results are correct.\\n\";\n  } else {\n    cout << \"FAILED: Results are incorrect.\\n\";\n    return 1;\n  }\n\n  return 0;\n}\n"
    },
    {
        "label": "loop_coalesce.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <iomanip>\n#include <iostream>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// Matrix dimensions\nconstexpr size_t kNumRows = 4;\nconstexpr size_t kNumCols = 4;\nconstexpr size_t kNumElements = kNumRows * kNumCols;\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\ntemplate <int N> class KernelCompute;\n\n// The kernel implements a matrix multiplication.\n// This is not meant to be a high performance implementation on FPGA!\n// It's just a simple kernel with nested loops to illustrate loop coalescing.\ntemplate <int coalesce_factor>\nvoid MatrixMultiply(const std::vector<float> &matrix_a,\n                    const std::vector<float> &matrix_b,\n                    std::vector<float> &res) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    auto prop_list = property_list{property::queue::enable_profiling()};\n\n    queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    buffer buffer_in_a(matrix_a);\n    buffer buffer_in_b(matrix_b);\n    buffer buffer_out(res);\n\n    event e = q.submit([&](handler &h) {\n      accessor accessor_matrix_a(buffer_in_a, h, read_only);\n      accessor accessor_matrix_b(buffer_in_b, h, read_only);\n      accessor accessor_res(buffer_out, h, write_only, no_init);\n\n      // The kernel_args_restrict promises the compiler that this kernel's\n      // accessor arguments won't alias (i.e. non-overlapping memory regions).\n      h.single_task<class KernelCompute<coalesce_factor>>(\n                                       [=]() [[intel::kernel_args_restrict]] {\n        size_t idx = 0;\n        float a[kNumRows][kNumCols];\n        float b[kNumRows][kNumCols];\n        float tmp[kNumRows][kNumCols];\n\n        // The loop_coalesce instructs the compiler to attempt to \"merge\"\n        // coalesce_factor loop levels of this nested loop together.\n        // For example, a coalesce_factor of 2 turns this into a single loop.\n        [[intel::loop_coalesce(coalesce_factor)]]\n        for (size_t i = 0; i < kNumRows; ++i) {\n          for (size_t j = 0; j < kNumCols; ++j) {\n            a[i][j] = accessor_matrix_a[idx];\n            b[i][j] = accessor_matrix_b[idx];\n            tmp[i][j] = 0.0;\n            idx++;\n          }\n        }\n\n        // Applying loop_coalesce to the outermost loop of a deeply nested\n        // loop results coalescing from the outside in.\n        // For example, a coalesce_factor of 2 coalesces the \"i\" and \"j\" loops,\n        // making a doubly nested loop.\n        [[intel::loop_coalesce(coalesce_factor)]]\n        for (size_t i = 0; i < kNumRows; ++i) {\n          for (size_t j = 0; j < kNumCols; ++j) {\n            float sum = 0.0f;\n            for (size_t k = 0; k < kNumCols; ++k) {\n              sum += a[i][k] * b[k][j];\n            }\n            tmp[i][j] = sum;\n          }\n        }\n\n        idx = 0;\n        [[intel::loop_coalesce(coalesce_factor)]]\n        for (size_t i = 0; i < kNumRows; ++i) {\n          for (size_t j = 0; j < kNumCols; ++j) {\n            accessor_res[idx] = tmp[i][j];\n            idx++;\n          }\n        }\n\n      });\n    });\n\n  } catch (exception const &exc) {\n    std::cerr << \"Caught synchronous SYCL exception:\\n\" << exc.what() << '\\n';\n    if (exc.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}\n\nint main() {\n  std::vector<float> matrix_a(kNumElements);\n  std::vector<float> matrix_b(kNumElements);\n  std::vector<float> matrix_output_no_col(kNumElements);\n  std::vector<float> matrix_output(kNumElements);\n\n  // Specify the matrices to be multiplied\n  for (size_t i = 0; i < kNumRows; i++) {\n    size_t pos = i * kNumCols;\n    // Initialize A as identity matrix\n    matrix_a[i + pos] = 1.0;\n    for (size_t j = 0; j < kNumCols; j++) {\n      matrix_b[pos + j] = i * j + 1;\n    }\n  }\n\n  // Two versions of the simple matrix multiply kernel will be enqueued:\n  //  - with coalesce_factor=1 (i.e. no loop coalescing)\n  //  - with coalesce_factor=2 (coalesce two nested levels)\n  MatrixMultiply<1>(matrix_a, matrix_b, matrix_output_no_col);\n  MatrixMultiply<2>(matrix_a, matrix_b, matrix_output);\n\n  // Correctness check\n  bool passed = true;\n  for (size_t i = 0; i < kNumRows; i++) {\n    size_t pos = i * kNumCols;\n    for (size_t j = 0; j < kNumCols; j++) {\n      float val_noCol = matrix_output_no_col[pos + j];\n      float val = matrix_output[pos + j];\n      if (val_noCol != i * j + 1 || val != i * j + 1) {\n        std::cout << \"FAILED: The results are incorrect\\n\";\n        passed = false;\n      }\n    }\n  }\n\n  if (passed) {\n    std::cout << \"PASSED: The results are correct\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return -1;\n  }\n}\n"
    },
    {
        "label": "private_copies.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n\n#include <array>\n#include <iomanip>\n#include <iostream>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n#if defined(FPGA_SIMULATOR)\n// Smaller size to keep the runtime reasonable\nconstexpr size_t kSize = 512; //2^9\nconstexpr size_t kMaxIter = 100;\n#else\nconstexpr size_t kSize = 8192; //2^13\nconstexpr size_t kMaxIter = 50000;\n#endif\nconstexpr size_t kTotalOps = 2 * kMaxIter * kSize;\nconstexpr size_t kMaxValue = 128;\n\nusing IntArray = std::array<int, kSize>;\nusing IntScalar = std::array<int, 1>;\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\ntemplate <int num_copies> class Kernel;\n\n// Launch a kernel on the device specified by selector.\n// The kernel's functionality is designed to show the\n// performance impact of the private_copies attribute.\ntemplate <int num_copies, bool first_call = false>\nvoid SimpleMathWithShift(const IntArray &array, int shift, IntScalar &result) {\n\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  double kernel_time = 0.0;\n\n  try {\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    if constexpr (first_call){\n      auto device = q.get_device();\n\n      std::cout << \"Running on device: \"\n                << device.get_info<sycl::info::device::name>().c_str()\n                << std::endl;\n    }\n\n    buffer buffer_array(array);\n    buffer<int, 1> buffer_result(result.data(), 1);\n\n    event e = q.submit([&](handler &h) {\n      accessor accessor_array(buffer_array, h, read_only);\n      accessor accessor_result(buffer_result, h, write_only, no_init);\n\n      h.single_task<Kernel<num_copies>>([=]() [[intel::kernel_args_restrict]] {\n        int r = 0;\n\n        for (size_t i = 0; i < kMaxIter; i++) {\n          // Request num_copies private copies for array a. This limits the\n          // concurrency of the outer loop to num_copies and also limits the\n          // memory use of a.\n          [[intel::private_copies(num_copies)]] int a[kSize];\n          for (size_t j = 0; j < kSize; j++) {\n            a[j] = accessor_array[(i * 4 + j) % kSize] * shift;\n          }\n          // The trip count of this loop is different from the loop above to\n          // prevent the compiler optimizing array `a` out.\n          for (size_t j = 0; j < kSize / 2; j++)\n            r += a[j];\n        }\n\n        accessor_result[0] = r;\n      });\n    });\n\n    // SYCL event profiling allows the kernel execution to be timed\n    double start = e.get_profiling_info<info::event_profiling::command_start>();\n    double end = e.get_profiling_info<info::event_profiling::command_end>();\n    kernel_time = (double)(end - start) * 1e-6;\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  // The performance of the kernel is measured in GFlops, based on:\n  // 1) the number of operations performed by the kernel.\n  //    This can be calculated easily for the simple example kernel.\n  // 2) the kernel execution time reported by SYCL event profiling.\n  std::cout << \"Kernel time when private_copies is set to \" << num_copies\n            << \": \" << kernel_time << \" ms\\n\";\n  std::cout << \"Kernel throughput when private_copies is set to \" << num_copies\n            << \": \";\n  std::cout << std::fixed << std::setprecision(3)\n            << ((double)(kTotalOps) / kernel_time) / 1e6f << \" GFlops\\n\";\n}\n\n// Calculates the expected results. Used to verify that the kernel\n// is functionally correct.\nint GoldenResult(const IntArray &input_arr, int shift) {\n  int gr = 0;\n\n  for (size_t i = 0; i < kMaxIter; i++) {\n    int a[kSize];\n    for (size_t j = 0; j < kSize; j++) {\n      a[j] = input_arr[(i * 4 + j) % kSize] * shift;\n    }\n    for (size_t j = 0; j < kSize / 2; j++)\n      gr += a[j];\n  }\n\n  return gr;\n}\n\nint main() {\n  bool success = true;\n\n  IntArray a;\n  IntScalar R0, R1, R2, R3, R4;\n\n  int shift = rand() % kMaxValue;\n\n  // initialize the input data\n  for (size_t i = 0; i < kSize; i++)\n    a[i] = rand() % kMaxValue;\n\n  // Run the kernel with different values of the private_copies\n  // attribute to determine the optimal private_copies number.\n  SimpleMathWithShift<0, true>(a, shift, R0);\n  SimpleMathWithShift<1>(a, shift, R1);\n  SimpleMathWithShift<2>(a, shift, R2);\n  SimpleMathWithShift<3>(a, shift, R3);\n  SimpleMathWithShift<4>(a, shift, R4);\n\n  // compute the actual result here\n  int gr = GoldenResult(a, shift);\n\n  // verify the results are correct\n  if (gr != R0[0]) {\n    std::cout << \"Private copies 0: mismatch: \" << R0[0] << \" != \" << gr\n              << \" (kernel != expected)\" << '\\n';\n    success = false;\n  }\n\n  if (gr != R1[0]) {\n    std::cout << \"Private copies 1: mismatch: \" << R1[0] << \" != \" << gr\n              << \" (kernel != expected)\" << '\\n';\n    success = false;\n  }\n\n  if (gr != R2[0]) {\n    std::cout << \"Private copies 2: mismatch: \" << R2[0] << \" != \" << gr\n              << \" (kernel != expected)\" << '\\n';\n    success = false;\n  }\n\n  if (gr != R3[0]) {\n    std::cout << \"Private copies 3: mismatch: \" << R3[0] << \" != \" << gr\n              << \" (kernel != expected)\" << '\\n';\n    success = false;\n  }\n\n  if (gr != R4[0]) {\n    std::cout << \"Private copies 4: mismatch: \" << R4[0] << \" != \" << gr\n              << \" (kernel != expected)\" << '\\n';\n    success = false;\n  }\n\n  if (success) {\n    std::cout << \"PASSED: The results are correct\\n\";\n    return 0;\n  }\n\n  return 1;\n}\n"
    },
    {
        "label": "loop_unroll.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\ntemplate <int unroll_factor> class VAdd;\n\n// This function instantiates the vector add kernel, which contains\n// a loop that adds up the two summand arrays and stores the result\n// into sum. This loop will be unrolled by the specified unroll_factor.\ntemplate <int unroll_factor>\nvoid VecAdd(const std::vector<float> &summands1,\n            const std::vector<float> &summands2, std::vector<float> &sum,\n            size_t array_size) {\n\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    buffer buffer_summands1(summands1);\n    buffer buffer_summands2(summands2);\n    buffer buffer_sum(sum);\n\n    event e = q.submit([&](handler &h) {\n      accessor acc_summands1(buffer_summands1, h, read_only);\n      accessor acc_summands2(buffer_summands2, h, read_only);\n      accessor acc_sum(buffer_sum, h, write_only, no_init);\n\n      h.single_task<VAdd<unroll_factor>>([=]()\n                                         [[intel::kernel_args_restrict]] {\n        // Unroll the loop fully or partially, depending on unroll_factor\n        #pragma unroll unroll_factor\n        for (size_t i = 0; i < array_size; i++) {\n          acc_sum[i] = acc_summands1[i] + acc_summands2[i];\n        }\n      });\n    });\n\n    double start = e.get_profiling_info<info::event_profiling::command_start>();\n    double end = e.get_profiling_info<info::event_profiling::command_end>();\n    // convert from nanoseconds to ms\n    double kernel_time = (double)(end - start) * 1e-6;\n\n    std::cout << \"unroll_factor \" << unroll_factor\n              << \" kernel time : \" << kernel_time << \" ms\\n\";\n    std::cout << \"Throughput for kernel with unroll_factor \" << unroll_factor\n              << \": \";\n    std::cout << std::fixed << std::setprecision(3)\n#if defined(FPGA_SIMULATOR)\n              << ((double)array_size / kernel_time) / 1e3f << \" MFlops\\n\";\n#else\n              << ((double)array_size / kernel_time) / 1e6f << \" GFlops\\n\";\n#endif\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}\n\nint main(int argc, char *argv[]) {\n#if defined(FPGA_SIMULATOR)\n  size_t array_size = 1 << 4;\n#else\n  size_t array_size = 1 << 26;\n#endif\n\n  if (argc > 1) {\n    std::string option(argv[1]);\n    if (option == \"-h\" || option == \"--help\") {\n      std::cout << \"Usage: \\n<executable> <data size>\\n\\nFAILED\\n\";\n      return 1;\n    } else {\n      array_size = std::stoi(option);\n    }\n  }\n\n  std::vector<float> summands1(array_size);\n  std::vector<float> summands2(array_size);\n\n  std::vector<float> sum_unrollx1(array_size);\n  std::vector<float> sum_unrollx2(array_size);\n  std::vector<float> sum_unrollx4(array_size);\n  std::vector<float> sum_unrollx8(array_size);\n  std::vector<float> sum_unrollx16(array_size);\n\n  // Initialize the two summand arrays (arrays to be added to each other) to\n  // 1:N and N:1, so that the sum of all elements is N + 1\n  for (size_t i = 0; i < array_size; i++) {\n    summands1[i] = static_cast<float>(i + 1);\n    summands2[i] = static_cast<float>(array_size - i);\n  }\n\n  std::cout << \"Input Array Size:  \" << array_size << \"\\n\";\n\n  // Instantiate VecAdd kernel with different unroll factors: 1, 2, 4, 8, 16\n  // The VecAdd kernel contains a loop that adds up the two summand arrays.\n  // This loop will be unrolled by the specified unroll factor.\n  // The sum array is expected to be identical, regardless of the unroll factor.\n  VecAdd<1>(summands1, summands2, sum_unrollx1, array_size);\n  VecAdd<2>(summands1, summands2, sum_unrollx2, array_size);\n  VecAdd<4>(summands1, summands2, sum_unrollx4, array_size);\n  VecAdd<8>(summands1, summands2, sum_unrollx8, array_size);\n  VecAdd<16>(summands1, summands2, sum_unrollx16, array_size);\n\n  // Verify that the output data is the same for every unroll factor\n  for (size_t i = 0; i < array_size; i++) {\n    if (sum_unrollx1[i] != summands1[i] + summands2[i] ||\n        sum_unrollx1[i] != sum_unrollx2[i] ||\n        sum_unrollx1[i] != sum_unrollx4[i] ||\n        sum_unrollx1[i] != sum_unrollx8[i] ||\n        sum_unrollx1[i] != sum_unrollx16[i]) {\n      std::cout << \"FAILED: The results are incorrect\\n\";\n      return 1;\n    }\n  }\n  std::cout << \"PASSED: The results are correct\\n\";\n  return 0;\n}\n"
    },
    {
        "label": "loop_initiation_interval.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <vector>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// short initialization loop trip count\nconstexpr size_t kInitLoopSize = 10;\n// long-running loop trip count\n#if defined(FPGA_SIMULATOR)\nconstexpr size_t kLongLoopSize = 100;\n#else\nconstexpr size_t kLongLoopSize = 10000;\n#endif\n\n// problem input size\n#if defined(FPGA_EMULATOR)\nconstexpr size_t kInputSize = 10000;\n#elif defined(FPGA_SIMULATOR)\nconstexpr size_t kInputSize = 1;\n#else\nconstexpr size_t kInputSize = 1000000;\n#endif\n\n// Forward declare the kernel name in the global scope\n// This FPGA best practice reduces name mangling in the optimization reports\nclass SimpleMath;\n\nint SomethingComplicated(int x) { return (int)sycl::sqrt((float)x); }\n\n// The function the kernel will compute\n// The golden result will be computed on the host to check the kernel result\nint GoldenResult(int num) {\n  for (size_t i = 0; i < kInitLoopSize; i++) {\n    num += 1;\n    num ^= 1;\n    num += 1;\n    num ^= 1;\n    num += 1;\n    num ^= 1;\n    num += 1;\n    num ^= 1;\n    num += 1;\n    num ^= 1;\n  }\n\n  int sum = 0;\n  for (size_t j = 0; j < kLongLoopSize; j++) {\n    sum += SomethingComplicated(num + j);\n  }\n\n  return sum;\n}\n\n// Return the execution time of the event, in seconds\ndouble GetExecutionTime(const event &e) {\n  double start_k = e.get_profiling_info<info::event_profiling::command_start>();\n  double end_k = e.get_profiling_info<info::event_profiling::command_end>();\n  double kernel_time = (end_k - start_k) * 1e-9;  // ns to s\n  return kernel_time;\n}\n\nvoid RunKernel(std::vector<int> &in, std::vector<int> &out) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    // create the SYCL device queue\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    buffer in_buf(in);\n    buffer out_buf(out);\n\n    // submit the kernel\n    auto e = q.submit([&](handler &h) {\n      accessor in_acc(in_buf, h, read_only);\n      accessor out_acc(out_buf, h, write_only, no_init);\n\n      // FPGA-optimized kernel\n      // Using kernel_args_restrict tells the compiler that the input\n      // and output buffers won't alias.\n      h.single_task<SimpleMath>([=]() [[intel::kernel_args_restrict]] {\n        for (size_t i = 0; i < kInputSize; i++) {\n          int num = in_acc[i];\n\n          // All kernels share a common clock domain, thus this design needs to\n          // be compiled twice to showcase the same design with different fMAX\n          // If ENABLE_II is defined, the intel::initiation_interval attribute\n          // will be set for the next loop, the short initialization loop\n          // Explicitly setting the II for a loop will tell the compiler to\n          // schedule the loop while enforcing the set II, overriding the\n          // default heuristic of finding the minimum II * (1/fMAX) Relaxing the\n          // II on a short loop with a long feedback path will remove the\n          // bottleneck the loop had on the maximum achievable fMAX of the\n          // design. The default targeted fMAX is target dependent,\n          // so different IIs need to be specified so the\n          // compiler can schedule the loop such that it does not restrict the\n          // maximum fMAX\n#if defined(ENABLE_II)\n#if defined(A10)\n          [[intel::initiation_interval(3)]]\n#elif defined(S10)\n          [[intel::initiation_interval(5)]]\n#elif defined(CycloneV)\n          [[intel::initiation_interval(5)]]\n#elif defined(Agilex5)\n          [[intel::initiation_interval(5)]]\n#elif defined(Agilex7)\n          [[intel::initiation_interval(5)]]\n#else\n          static_assert(false, \"Unknown FPGA Architecture!\");\n#endif\n#endif\n          // ---------------------------\n          // Short initialization loop\n          // ---------------------------\n          // The variable \"num\" has a loop carried dependency with a long\n          // feedback path: The first operation on \"num\" in a given iteration\n          // depends on the value of \"num\" calculated in the last operation of a\n          // previous iteration. This leads to a classic fMAX-II tradeoff\n          // situation. The compiler can achieve an II of 1 and a low fMAX, or\n          // it can pipeline the arithmetic logic to improve fMAX at the expense\n          // of II. By default the compiler will select an II of 1 after\n          // optimizing for minimum II * (1/fMAX), which is not optimal for\n          // whole design as fMAX is a system-wide constraint and this loop has\n          // few iterations.\n          for (size_t j = 0; j < kInitLoopSize; j++) {\n            num += 1;\n            num ^= 1;\n            num += 1;\n            num ^= 1;\n            num += 1;\n            num ^= 1;\n            num += 1;\n            num ^= 1;\n            num += 1;\n            num ^= 1;\n          }\n\n          int sum = 0;\n\n          // The intel::initiation_interval attribute is added here to \"assert\"\n          // that II=1 for this loop. Even though we fully expect the compiler\n          // to achieve II=1 here by default, some developers find it helpful to\n          // include the attribute to \"document\" this expectation. If a future\n          // code change causes an unexpected II regression, the compiler will\n          // error out. Without the intel::initiation_interval attribute, an II\n          // regression may go unnoticed.\n#if defined(ENABLE_II)\n          [[intel::initiation_interval(1)]]\n#endif\n          // ---------------------------\n          // Long running loop\n          // ---------------------------\n          // The variable \"sum\" has a loop carried dependency with a feedback\n          // path, although not as long as the feedback path of \"num\". The first\n          // operation on \"sum\" in a given iteration depends on the value of\n          // \"sum\" calculated in the last operation of a previous iteration The\n          // compiler is able to achieve an II of 1 and the default targeted\n          // fMAX for Arria\u00ae 10, but falls a little short on Stratix\u00ae 10. The\n          // intel::initiation_interval attribute should not be used to relax\n          // the II of this loop as the drop in occupancy of the long loop is\n          // not worth achieving a slightly higher fMAX\n          for (size_t k = 0; k < kLongLoopSize; k++) {\n            sum += SomethingComplicated(num + k);\n          }\n\n          out_acc[i] = sum;\n        }\n      });\n    });\n\n    double exec_time = GetExecutionTime(e);\n    double inputMB = (kInputSize * sizeof(int)) / (double)(1024 * 1024);\n\n#if defined(ENABLE_II)\n    std::cout << \"Kernel_ENABLE_II Throughput: \" << (inputMB / exec_time)\n              << \"MB/s\\n\";\n#else\n    std::cout << \"Kernel Throughput: \" << (inputMB / exec_time) << \"MB/s\\n\";\n#endif\n    std::cout << \"Exec Time: \" << exec_time << \"s , InputMB: \" << inputMB\n              << \"MB\\n\";\n\n  } catch (exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}\n\nint main() {\n  // seed random number generator\n  srand(0);\n\n  // input/output data\n  std::vector<int> in(kInputSize);\n  std::vector<int> out(kInputSize);\n\n  // Conservative max to avoid addition overflow\n  constexpr int kRandMax = 1 << 10;\n  // generate random input data\n  for (size_t i = 0; i < kInputSize; i++) {\n    in[i] = rand() % kRandMax;\n  }\n\n  // Run kernel once. Since fMAX is a global constraint, we cannot run two\n  // kernels demonstrating the use of the intel::initiation_interval attribute\n  // since the kernel without the intel::initiation_interval attribute would\n  // restrict the global fMAX, thus affecting the design with the\n  // intel::initiation_interval attribute. Rely on the preprocessor defines to\n  // change the kernel behaviour.\n  RunKernel(in, out);\n\n  // validate results\n  for (size_t i = 0; i < kInputSize; i++) {\n    if (out[i] != GoldenResult(in[i])) {\n      std::cout << \"FAILED: mismatch at entry \" << i\n                << \" of 'SimpleMath' kernel output\\n\";\n      return 1;\n    }\n  }\n\n  std::cout << \"PASSED\\n\";\n\n  return 0;\n}\n"
    },
    {
        "label": "loop_ivdep.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <iomanip>\n#include <iostream>\n\n#include \"exception_handler.hpp\"\n\nconstexpr size_t kRowLength = 16;\nconstexpr size_t kMinSafelen = 1;\nconstexpr size_t kMaxSafelen = kRowLength;\nconstexpr size_t kMatrixSize = kRowLength * kRowLength;\n\nusing namespace sycl;\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\ntemplate <size_t safe_len> class KernelCompute;\n\ntemplate <size_t safe_len>\nvoid TransposeAndFold(const std::array<float, kMatrixSize> &m_input,\n                      std::array<float, kMatrixSize> &m_output) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  double kernel_time = 0;\n  try {\n  queue q(selector, fpga_tools::exception_handler,\n          property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    buffer buffer_input(m_input);\n    buffer buffer_output(m_output);\n\n    event e = q.submit([&](handler &h) {\n      accessor accessor_input(buffer_input, h, read_only);\n      accessor accessor_output(buffer_output, h, write_only, no_init);\n\n      h.single_task<KernelCompute<safe_len>>([=]()\n                                             [[intel::kernel_args_restrict]] {\n        float in_buffer[kRowLength][kRowLength];\n        float temp_buffer[kRowLength][kRowLength];\n\n        // Initialize local buffers\n        for (size_t i = 0; i < kMatrixSize; i++) {\n          in_buffer[i / kRowLength][i % kRowLength] = accessor_input[i];\n          temp_buffer[i / kRowLength][i % kRowLength] = 0;\n        }\n\n        // No iterations of the following loop store data into the same memory\n        // location that are less than kRowLength iterations apart.\n        // The ivdep here instructs the compiler that it can safely assume no\n        // loop-carried dependencies over safe_len consecutive iterations.\n        [[intel::ivdep(temp_buffer, safe_len)]]\n        for (size_t j = 0; j < kMatrixSize * kRowLength; j++) {\n          #pragma unroll\n          for (size_t i = 0; i < kRowLength; i++) {\n            temp_buffer[j % kRowLength][i] += in_buffer[i][j % kRowLength];\n          }\n        }\n\n        // Write result to output\n        for (size_t i = 0; i < kMatrixSize; i++) {\n          accessor_output[i] = temp_buffer[i / kRowLength][i % kRowLength];\n        }\n      });\n    });\n\n    double start = e.get_profiling_info<info::event_profiling::command_start>();\n    double end = e.get_profiling_info<info::event_profiling::command_end>();\n\n    // unit is nano second, convert to ms\n    kernel_time = (double)(end - start) * 1e-6;\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  std::cout << \"safe_len: \" << safe_len << \" -- kernel time : \" << kernel_time\n            << \" ms\\n\";\n  std::cout << \"Throughput for kernel with safe_len \" << safe_len << \": \";\n  std::cout << std::fixed << std::setprecision(0)\n            << (((double)kMatrixSize * sizeof(float) * 1e-3f) /\n                (kernel_time * 1e-3f)) << \"KB/s\\n\";\n}\n\nint main() {\n  std::array<float, kMatrixSize> A, B, C;\n\n  // Initialize input with random data\n  for (size_t i = 0; i < kMatrixSize; i++) {\n    A[i] = static_cast<float>(rand()) / static_cast<float>(RAND_MAX);\n  }\n\n  // Instantiate kernel logic with the min and max correct safelen parameter\n  // to compare performance.\n  TransposeAndFold<kMinSafelen>(A, B);\n  TransposeAndFold<kMaxSafelen>(A, C);\n  // You can also try removing the ivdep from the kernel entirely and\n  // recompiling to see what effect this has on performance.\n\n  // Verify result\n  for (size_t i = 0; i < kMatrixSize; i++) {\n    if (B[i] != C[i]) {\n      std::cout << \"FAILED: The results are incorrect\" << '\\n';\n      return 1;\n    }\n  }\n  std::cout << \"PASSED: The results are correct\" << '\\n';\n  return 0;\n}\n"
    },
    {
        "label": "speculated_iterations.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <array>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#include <type_traits>\n#include <cmath>\n\n#include \"exception_handler.hpp\"\n\n// Use smaller values if run on the emulator or simulator to keep the CPU\n// runtime/simulation time reasonable\n// Use the largest possible int values on the FPGA to show the difference in\n// performance with and without speculated_iterations\n#if defined(FPGA_EMULATOR)\nconstexpr float kUpper = 3.0f;\nconstexpr size_t kExpectedIterations = 1e3;\n#elif defined(FPGA_SIMULATOR)\nconstexpr float kUpper = 2.0f;\nconstexpr size_t kExpectedIterations = 1e2;\n#else\nconstexpr float kUpper = 8.0f;\nconstexpr size_t kExpectedIterations = 1e8;\n#endif\n\nusing namespace sycl;\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\ntemplate <int N> class KernelCompute;\n\ntemplate <int spec_iter, bool first_call = false>\nvoid ComplexExit(float bound, int &res) {\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  double kernel_time_ms = 0.0;\n  try {\n    // create the device queue with profiling enabled\n    auto prop_list = property_list{property::queue::enable_profiling()};\n    queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    if constexpr (first_call){\n      auto device = q.get_device();\n\n      std::cout << \"Running on device: \"\n                << device.get_info<sycl::info::device::name>().c_str()\n                << std::endl;\n    }\n\n    // The scalar inputs are passed to the kernel using the lambda capture,\n    // but a SYCL buffer must be used to return a scalar from the kernel.\n    buffer<int, 1> buffer_res(&res, 1);\n\n    event e = q.submit([&](handler &h) {\n      accessor accessor_res(buffer_res, h, write_only, no_init);\n\n      h.single_task<class KernelCompute<spec_iter>>([=]() {\n        int x = 1;\n\n        // Computing the exit condition of this loop is a complex operation.\n        // Since the value of var is not known at compile time, the loop\n        // trip count is variable and the exit condition must be evaluated at\n        // each iteration.\n        [[intel::speculated_iterations(spec_iter)]]\n        while (sycl::log10((float)(x)) < bound) {\n          x++;\n        }\n\n        accessor_res[0] = x;\n      });\n    });\n\n    // get the kernel time in milliseconds\n    // this excludes memory transfer and queuing overhead\n    double startk =\n        e.template get_profiling_info<info::event_profiling::command_start>();\n    double endk =\n        e.template get_profiling_info<info::event_profiling::command_end>();\n    kernel_time_ms = (endk - startk) * 1e-6;\n\n  } catch (exception const &exc) {\n    std::cerr << \"Caught synchronous SYCL exception:\\n\" << exc.what() << \"\\n\";\n    if (exc.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  // MFLOPs = mega floating point operations per second\n  double mflops = (double)(kExpectedIterations) / kernel_time_ms;\n\n  std::cout << \"Speculated Iterations: \" << spec_iter\n            << \" -- kernel time: \" << kernel_time_ms << \" ms\\n\";\n\n  std::cout << std::fixed << std::setprecision(0)\n            << \"Performance for kernel with \" << spec_iter\n            << \" speculated iterations: \" << mflops << \" MFLOPs\\n\";\n}\n\nint main(int argc, char *argv[]) {\n\n  float bound = kUpper;\n\n  // We don't want \"bound\" to be a compile-time known constant value\n  if (argc > 1) {\n    std::string option(argv[1]);\n    bound = std::stoi(option);\n  }\n\n  // result variables\n  int r0, r1, r2;\n\n// Choose the number of speculated iterations based on the FPGA board selected.\n// This reflects compute latency differences on different hardware\n// architectures, and is a low-level optimization.\n#if defined(A10)\n  ComplexExit<0, true>(bound, r0);\n  ComplexExit<10>(bound, r1);\n  ComplexExit<27>(bound, r2);\n#elif defined(CycloneV)\n  ComplexExit<0, true>(bound, r0);\n  ComplexExit<10>(bound, r1);\n  ComplexExit<34>(bound, r2);\n#elif defined(S10)\n  ComplexExit<0, true>(bound, r0);\n  ComplexExit<10>(bound, r1);\n  ComplexExit<54>(bound, r2);\n#elif defined(Agilex5)\n  ComplexExit<0, true>(bound, r0);\n  ComplexExit<10>(bound, r1);\n  ComplexExit<50>(bound, r2);\n#elif defined(Agilex7)\n  ComplexExit<0, true>(bound, r0);\n  ComplexExit<10>(bound, r1);\n  ComplexExit<50>(bound, r2);\n#else\n  std::static_assert(false, \"Invalid FPGA board macro\");\n#endif\n\n  bool passed = true;\n\n  if (std::fabs(std::log10(r0) - bound) > 1e-5) {\n    std::cout << \"Test 0 result mismatch \" << std::log10(r0)\n              << \" not within 0.00001 of \" << bound << \"\\n\";\n    passed = false;\n  }\n\n  if (std::fabs(std::log10(r1) - bound) > 1e-5) {\n    std::cout << \"Test 1 result mismatch \" << std::log10(r1)\n              << \" not within 0.00001 of \" << bound << \"\\n\";\n    passed = false;\n  }\n\n  if (std::fabs(std::log10(r2) - bound) > 1e-5) {\n    std::cout << \"Test 2 result mismatch \" << std::log10(r2)\n              << \" not within 0.00001 of \" << bound << \"\\n\";\n    passed = false;\n  }\n\n  std::cout << (passed ? \"PASSED: The results are correct\" : \"FAILED\") << \"\\n\";\n\n  return passed ? 0 : -1;\n}\n"
    },
    {
        "label": "lsu_control.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <numeric>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass KernelPrefetch;\nclass KernelBurst;\nclass KernelDefault;\n\n// Aliases for LSU Control Extension types\n// Implemented using template arguments such as prefetch & burst_coalesce\n// on the new ext::intel::lsu class to specify LSU style and modifiers\nusing PrefetchingLSU = ext::intel::lsu<ext::intel::prefetch<true>,\n                                  ext::intel::statically_coalesce<false>>;\n\nusing PipelinedLSU = ext::intel::lsu<>;\n\nusing BurstCoalescedLSU = ext::intel::lsu<ext::intel::burst_coalesce<true>,\n                                     ext::intel::statically_coalesce<false>>;\n\n// Input data and output data size constants\nconstexpr size_t kMaxVal = 128;\n#if defined(FPGA_EMULATOR) || defined(FPGA_SIMULATOR)\nconstexpr size_t kBaseVal = 1024;\n#else\nconstexpr size_t kBaseVal = 1048576;\n#endif\nconstexpr size_t kNum = 3;\n\n// Return the execution time of the event, in seconds\ndouble GetExecutionTime(const event &e) {\n  double start_k = e.get_profiling_info<info::event_profiling::command_start>();\n  double end_k = e.get_profiling_info<info::event_profiling::command_end>();\n  double kernel_time = (end_k - start_k) * 1e-9; // ns to s\n  return kernel_time;\n}\n\n// Runs the Kernel\nvoid KernelRun(const std::vector<int> &input_data, const size_t &input_size,\n               const size_t &output_size, std::vector<int> &output_data) {\n  std::fill(output_data.begin(), output_data.end(), -1);\n\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    // create the SYCL device queue\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    buffer output_buffer(output_data);\n    buffer input_buffer(input_data);\n\n    auto e_p = q.submit([&](handler &h) {\n      accessor output_a(output_buffer, h, write_only, no_init);\n      accessor input_a(input_buffer, h, read_only);\n\n      // Kernel that uses the prefetch LSU\n      h.single_task<KernelPrefetch>([=]() [[intel::kernel_args_restrict]] {\n        auto input_ptr =\n            input_a.template get_multi_ptr<access::decorated::no>();\n        auto output_ptr = \n            output_a.template get_multi_ptr<access::decorated::no>();\n\n        int total = 0;\n        for (size_t i = 0; i < input_size; i++) {\n          total += PrefetchingLSU::load(input_ptr + i);\n        }\n        output_ptr[0] = total;\n      });\n    });\n\n    auto e_b = q.submit([&](handler &h) {\n      accessor output_a(output_buffer, h, write_only, no_init);\n      accessor input_a(input_buffer, h, read_only);\n      \n      // Kernel that uses the burst-coalesced LSU\n      h.single_task<KernelBurst>([=]() [[intel::kernel_args_restrict]] {\n        auto input_ptr =\n            input_a.template get_multi_ptr<access::decorated::no>();\n        auto output_ptr = \n            output_a.template get_multi_ptr<access::decorated::no>();\n\n        int total = 0;\n        for (size_t i = 0; i < input_size; i++) {\n          total += BurstCoalescedLSU::load(input_ptr + i);\n        }\n        output_ptr[1] = total;\n      });\n    });\n\n    auto e_d = q.submit([&](handler &h) {\n      accessor output_a(output_buffer, h, write_only, no_init);\n      accessor input_a(input_buffer, h, read_only);\n      \n      // Kernel that uses the default LSUs\n      h.single_task<KernelDefault>([=]() [[intel::kernel_args_restrict]] {\n        auto input_ptr = \n            input_a.template get_multi_ptr<access::decorated::no>();\n        auto output_ptr = \n            output_a.template get_multi_ptr<access::decorated::no>();\n\n        int total = 0;\n        for (size_t i = 0; i < input_size; i++) {\n          total += input_ptr[i];\n        }\n        output_ptr[2] = total;\n      });\n    });\n\n    // Measure the execution time of each kernel \n    double p_time = GetExecutionTime(e_p);\n    double b_time = GetExecutionTime(e_b);\n    double d_time = GetExecutionTime(e_d);\n    double input_size_mb = (input_size * sizeof(int)/(1024*1024));\n    std::cout << \"Kernel throughput with prefetch LSU: \" \n              << (input_size_mb/p_time) << \" MB/s \\n\";\n    std::cout << \"Kernel throughput with burst-coalesced LSU: \" \n              << (input_size_mb/b_time) << \" MB/s \\n\";\n    std::cout << \"Kernel throughput without LSU controls: \" \n              << (input_size_mb/d_time) << \" MB/s \\n\";\n\n  } catch (exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}\n\n// This host side function performs the same computation as the device side\n// kernel, and is used to verify functional correctness.\nvoid GoldenRun(const std::vector<int> &input_data, const size_t &input_size,\n               const size_t &output_size, std::vector<int> &output_data) {\n  std::fill(output_data.begin(), output_data.end(), -1);\n\n  for (size_t i = 0; i < output_size; i++) {\n    int total = 0;\n    for (size_t j = 0; j < input_size; j++) {\n      // Match formulas from kernel above\n      total += input_data[j];\n    }\n    output_data[i] = total;\n  }\n}\n\nint main() {\n  bool passed = true;\n  const size_t input_size = kBaseVal + rand() % kMaxVal;\n  const size_t output_size = kNum;\n\n  std::vector<int> input_data(input_size);\n  std::vector<int> result_golden(output_size);\n  std::vector<int> result_kernel(output_size);\n\n  // Populate input_data with incrementing values starting with 0\n  std::iota(input_data.begin(), input_data.end(), 0);\n\n  GoldenRun(input_data, input_size, output_size, result_golden);\n  KernelRun(input_data, input_size, output_size, result_kernel);\n\n  for (size_t i = 0; i < output_size; i++) {\n    if (result_kernel[i] != result_golden[i]) {\n      std::cout << \"Output Mismatch: \\n\"\n                << \"result_kernel[\" << i << \"] vs result_golden [\" << i\n                << \"] = \" << result_kernel[i] << \",\" << result_golden[i]\n                << \" \\n\";\n      passed = false;\n    }\n  }\n\n  if (passed) {\n    std::cout << \"PASSED: all kernel results are correct.\\n\";\n  } else {\n    std::cout << \"FAILED\\n\";\n  }\n  return passed ? 0 : 1;\n}\n"
    },
    {
        "label": "main.cpp",
        "data": "#include <iostream>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nconstexpr int kVectSize = 128;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass IDNaive;\n\n// Minimum capacity of a pipe.\n// Set to 0 to allow the compiler to save area if possible.\nconstexpr size_t kPipeMinCapacity = 0;\n\n// Pipes\nclass IDPipeIn0;\nusing PipeIn0 = sycl::ext::intel::experimental::pipe<\n    IDPipeIn0,       // An identifier for the pipe\n    int,              // The type of data in the pipe\n    kPipeMinCapacity  // The capacity of the pipe\n    >;\n\nclass IDPipeIn1;\nusing PipeIn1 = sycl::ext::intel::experimental::pipe<\n    IDPipeIn1,       // An identifier for the pipe\n    int,              // The type of data in the pipe\n    kPipeMinCapacity  // The capacity of the pipe\n    >;\n\nclass IDPipeOut;\nusing PipeOut = sycl::ext::intel::experimental::pipe<\n    IDPipeOut,       // An identifier for the pipe\n    int,              // The type of data in the pipe\n    kPipeMinCapacity  // The capacity of the pipe\n    >;\n\n///////////////////////////////////////\n\nstruct NaiveKernel {\n  int len;\n\n  void operator()() const {\n    int array_a_b[kVectSize];\n    int array_b_c[kVectSize];\n    int array_c_d[kVectSize];\n    int array_a_d[kVectSize];\n\n    // loopA\n    [[intel::initiation_interval(1)]]  \n    for (size_t i = 0; i < len; i++) {\n      int in0 = PipeIn0::read();\n      int in1 = PipeIn1::read();\n      array_a_b[i] = in0;\n      array_a_d[i] = in1;\n    }\n\n    // loopB\n    [[intel::initiation_interval(1)]]  \n    for (size_t i = 0; i < len; i++) {\n      int tmp = array_a_b[i];\n      tmp += i;\n      array_b_c[i] = tmp;\n    }\n\n    // loopC\n    [[intel::initiation_interval(1)]]  \n    for (size_t i = 0; i < len; i++) {\n      int tmp = array_b_c[i];\n      tmp += i;\n      array_c_d[i] = tmp;\n    }\n\n    // loopD\n    [[intel::initiation_interval(1)]]  \n    for (size_t i = 0; i < len; i++) {\n      int tmp0 = array_c_d[i];\n      int tmp1 = array_a_d[i];\n      int out = tmp0 + tmp1;\n      PipeOut::write(out);  \n    }\n  }\n};\n\nint main() {\n  bool passed = false;\n\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    int *a = new int[kVectSize];\n    int *b = new int[kVectSize];\n\n    // Generate input data\n    for (int i = 0; i < kVectSize; i++) {\n      a[i] = i;                \n      b[i] = (kVectSize - i); \n\n      PipeIn0::write(q, i);\n      PipeIn1::write(q, kVectSize - i);\n    }\n\n    // Call the kernel\n    auto e = q.single_task<IDNaive>(NaiveKernel{kVectSize});\n\n    // verify that output is correct\n    passed = true;\n    for (int i = 0; i < kVectSize; i++) {\n      int expected = a[i] * 3 + b[i];\n      int result = PipeOut::read(q);\n      if (result != expected) {\n        std::cout << \"idx=\" << i << \": naive result \" << result\n                  << \", expected (\" << expected << \") .\" << std::endl;\n        passed = false;\n      }\n    }\n\n    // Wait for kernel to exit\n    e.wait();\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    delete[] a;\n    delete[] b;\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"
    },
    {
        "label": "main.cpp",
        "data": "#include <iostream>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/experimental/task_sequence.hpp>\n\n#include \"exception_handler.hpp\"\n\nconstexpr int kVectSize = 128;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass IDOptimized;\n\n// Minimum capacity of a pipe.\n// Set to 0 to allow the compiler to save area if possible.\nconstexpr size_t kPipeMinCapacity = 0;\n\n// Pipes \nclass IDPipeIn0;\nusing PipeIn0 = sycl::ext::intel::experimental::pipe<\n    IDPipeIn0,        // An identifier for the pipe\n    int,              // The type of data in the pipe\n    kPipeMinCapacity  // The capacity of the pipe\n    >;   \n    \nclass IDPipeIn1;\nusing PipeIn1 = sycl::ext::intel::experimental::pipe<\n    IDPipeIn1,        // An identifier for the pipe\n    int,              // The type of data in the pipe\n    kPipeMinCapacity  // The capacity of the pipe\n    >;\n\nclass IDPipeAB;\nusing PipeAB = sycl::ext::intel::pipe<\n    IDPipeAB,         // An identifier for the pipe\n    int,              // The type of data in the pipe\n    kPipeMinCapacity  // The capacity of the pipe\n    >;\n\nclass IDPipeBC;\nusing PipeBC = sycl::ext::intel::pipe<\n    IDPipeBC,         // An identifier for the pipe\n    int,              // The type of data in the pipe\n    kPipeMinCapacity  // The capacity of the pipe\n    >;\n\nclass IDPipeCD;\nusing PipeCD = sycl::ext::intel::pipe<\n    IDPipeCD,         // An identifier for the pipe\n    int,              // The type of data in the pipe\n    kPipeMinCapacity  // The capacity of the pipe\n    >;\n\nclass IDPipeAD;\nusing PipeAD = sycl::ext::intel::pipe<\n    IDPipeAD,         // An identifier for the pipe\n    int,              // The type of data in the pipe\n    kPipeMinCapacity  // The capacity of the pipe\n    >;\n\nclass IDPipeOut;\nusing PipeOut = sycl::ext::intel::experimental::pipe<\n    IDPipeOut,        // An identifier for the pipe\n    int,              // The type of data in the pipe\n    kPipeMinCapacity  // The capacity of the pipe\n    >;\n\n// [[intel::use_stall_enable_clusters]] is required to \n// work around a compiler bug that hurts performance\n[[intel::use_stall_enable_clusters]] \nvoid LoopA(int len) {\n  [[intel::initiation_interval(1)]]  \n  for (size_t i = 0; i < len; i++) {\n    int in0 = PipeIn0::read();\n    int in1 = PipeIn1::read();\n\n    PipeAB::write(in0);\n    PipeAD::write(in1);\n  }\n}\n\n// [[intel::use_stall_enable_clusters]] is required to \n// work around a compiler bug that hurts performance\n[[intel::use_stall_enable_clusters]] \nvoid LoopB(int len) {\n  [[intel::initiation_interval(1)]]  \n  for (size_t i = 0; i < len; i++) {\n    int tmp = PipeAB::read();\n    tmp += i;\n    PipeBC::write(tmp);  \n  }\n}\n\n// [[intel::use_stall_enable_clusters]] is required to \n// work around a compiler bug that hurts performance\n[[intel::use_stall_enable_clusters]] \nvoid LoopC(int len) {\n  [[intel::initiation_interval(1)]]  \n  for (size_t i = 0; i < len; i++) {\n    int tmp = PipeBC::read();\n    tmp += i;\n    PipeCD::write(tmp);  \n  }\n}\n\n// [[intel::use_stall_enable_clusters]] is required to \n// work around a compiler bug that hurts performance\n[[intel::use_stall_enable_clusters]] \nvoid LoopD(int len) {\n  [[intel::initiation_interval(1)]]  \n  for (size_t i = 0; i < len; i++) {\n    int tmp0 = PipeCD::read();\n    int tmp1 = PipeAD::read();\n    int out = tmp0 + tmp1;\n    PipeOut::write(out);  \n  }\n}\n\n///////////////////////////////////////\n\nstruct OptimizedKernel {\n  int len;\n\n  void operator()() const {\n    sycl::ext::intel::experimental::task_sequence<LoopA> task_a;\n    sycl::ext::intel::experimental::task_sequence<LoopB> task_b;\n    sycl::ext::intel::experimental::task_sequence<LoopC> task_c;\n    sycl::ext::intel::experimental::task_sequence<LoopD> task_d;\n\n    task_a.async(len);\n    task_b.async(len);\n    task_c.async(len);\n    task_d.async(len);\n  }\n};\n\nint main() {\n  bool passed = false;\n\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    int *a = new int[kVectSize];\n    int *b = new int[kVectSize];\n\n    // Generate input data\n    for (int i = 0; i < kVectSize; i++) {\n      a[i] = i;                \n      b[i] = (kVectSize - i);  \n\n      PipeIn0::write(q, i);\n      PipeIn1::write(q, kVectSize - i);\n    }\n\n    // Call the kernel\n    auto e = q.single_task<IDOptimized>(OptimizedKernel{kVectSize});\n\n    // verify that output is correct\n    passed = true;\n    for (int i = 0; i < kVectSize; i++) {\n      int expected = a[i] * 3 + b[i];\n      int result = PipeOut::read(q);\n      if (result != expected) {\n        std::cout << \"idx=\" << i << \": task_sequences result \" << result\n                  << \", expected (\" << expected << \") .\" << std::endl;\n        passed = false;\n      }\n    }\n\n    // Wait for kernel to exit\n    e.wait();\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    delete[] a;\n    delete[] b;\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}"
    },
    {
        "label": "main.cpp",
        "data": "#include <iostream>\n#include <cmath>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass IDVectorOp;\n\nconstexpr int kSize = 3;\nusing D3Vector = std::array<float, kSize>;\n\n// Minimum capacity of a pipe.\n// Set to 0 to allow the compiler to save area if possible.\nconstexpr size_t kPipeMinCapacity = 0;\n\n// Pipes\nclass IDInputPipeA;\nclass IDOutputPipeZ;\n\nusing InputPipeA = sycl::ext::intel::experimental::pipe<IDInputPipeA, D3Vector,\n                                                        kPipeMinCapacity>;\nusing OutputPipeZ = sycl::ext::intel::experimental::pipe<IDOutputPipeZ, float,\n                                                         kPipeMinCapacity>;\n\n// The square-root of a dot-product is an expensive operation for it consumes a\n// significant amount of area resources.\nfloat OpSqrt(D3Vector val, const D3Vector coef) {\n  float res = sqrt(val[0] * coef[0] + val[1] * coef[1] + val[2] * coef[2]);\n  return res;\n}\n\nstruct VectorOp {\n  void operator()() const {\n    constexpr D3Vector kCoef1 = {0.2, 0.3, 0.4};\n    constexpr D3Vector kCoef2 = {0.6, 0.7, 0.8};\n\n    D3Vector new_item, item;\n    item = InputPipeA::read();\n    new_item[0] = OpSqrt(item, kCoef1);\n    item = InputPipeA::read();\n    new_item[1] = OpSqrt(item, kCoef1);\n    item = InputPipeA::read();\n    new_item[2] = OpSqrt(item, kCoef1);\n\n    OutputPipeZ::write(OpSqrt(new_item, kCoef2));\n  }\n};\n\nint main() {\n  constexpr int kN = 5;\n  bool passed = false;\n\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // initialize input D3Vector\n    constexpr float test_vecs[kSize][kSize] = {\n        {.49, .26, .82}, {.78, .43, .92}, {.17, .72, .34}};\n\n    // input data\n    for (int j = 0; j < kN; j++) {\n      for (int i = 0; i < kSize; i++) {\n        D3Vector data;\n        for (int k = 0; k < kSize; k++) {\n          data[k] = test_vecs[i][k];\n        }\n        InputPipeA::write(q, data);\n      }\n    }\n\n    std::cout << \"Processing vector of size \" << kSize << std::endl;\n\n    float result[kN];\n    sycl::event e;\n    for (int i = 0; i < kN; i++) {\n      e = q.single_task<IDVectorOp>(VectorOp{});\n    }\n\n    // verify that result is correct\n    passed = true;\n    for (int i = 0; i < kN; i++) {\n      result[i] = OutputPipeZ::read(q);\n    }\n    for (int i = 1; i < kN; i++) {\n      if (result[i] != result[i - 1]) {\n        std::cerr << \"idx=\" << i << \", naive result \" << result[i]\n                  << \", previously \" << result[i - 1] << std::endl;\n        passed = false;\n      }\n    }\n    // Wait for kernel to exit\n    e.wait();\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"
    },
    {
        "label": "main.cpp",
        "data": "#include <iostream>\n#include <cmath>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/ext/intel/experimental/task_sequence.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass IDVectorOp;\n\nconstexpr int kSize = 3;\nusing D3Vector = std::array<float, kSize>;\n\n// Minimum capacity of a pipe.\n// Set to 0 to allow the compiler to save area if possible.\nconstexpr size_t kPipeMinCapacity = 0;\n\n// Pipes\nclass IDInputPipeA;\nclass IDOutputPipeZ;\n\nusing InputPipeA = sycl::ext::intel::experimental::pipe<IDInputPipeA, D3Vector,\n                                                        kPipeMinCapacity>;\nusing OutputPipeZ = sycl::ext::intel::experimental::pipe<IDOutputPipeZ, float,\n                                                         kPipeMinCapacity>;\n\n// The square-root of a dot-product is an expensive operation for it consumes a\n// significant amount of area resources.\nfloat OpSqrt(D3Vector val, const D3Vector coef) {\n  float res = sqrt(val[0] * coef[0] + val[1] * coef[1] + val[2] * coef[2]);\n  return res;\n}\n\nstruct VectorOp {\n  void operator()() const {\n    constexpr D3Vector kCoef1 = {0.2, 0.3, 0.4};\n    constexpr D3Vector kCoef2 = {0.6, 0.7, 0.8};\n\n    D3Vector new_item;\n\n    // Object declarations of a parameterized task_sequence class must be local,\n    // which means global declarations and dynamic allocations are not allowed.\n    // Declare the task sequence object outside the for loop so that the\n    // hardware can be shared at the return point.\n    sycl::ext::intel::experimental::task_sequence<OpSqrt> task_a;\n\n    for (int i = 0; i < new_item.size(); i++) {\n      D3Vector item = InputPipeA::read();\n      task_a.async(item, kCoef1);\n      new_item[i] = task_a.get();\n    }\n\n    task_a.async(new_item, kCoef2);\n    OutputPipeZ::write(task_a.get());\n  }\n};\n\nint main() {\n  constexpr int kN = 5;\n  bool passed = false;\n\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // initialize input D3Vector\n    constexpr float test_vecs[kSize][kSize] = {\n        {.49, .26, .82}, {.78, .43, .92}, {.17, .72, .34}};\n\n    // input data\n    for (int j = 0; j < kN; j++) {\n      for (int i = 0; i < kSize; i++) {\n        D3Vector data;\n        for (int k = 0; k < kSize; k++) {\n          data[k] = test_vecs[i][k];\n        }\n        InputPipeA::write(q, data);\n      }\n    }\n\n    std::cout << \"Processing vector of size \" << kSize << std::endl;\n\n    float result[kN];\n    sycl::event e;\n    for (int i = 0; i < kN; i++) {\n      e = q.single_task<IDVectorOp>(VectorOp{});\n    }\n\n    // verify that result is correct\n    passed = true;\n    for (int i = 0; i < kN; i++) {\n      result[i] = OutputPipeZ::read(q);\n    }\n    for (int i = 1; i < kN; i++) {\n      if (result[i] != result[i - 1]) {\n        std::cerr << \"idx=\" << i << \", async result \" << result[i]\n                  << \", previously \" << result[i - 1] << std::endl;\n        passed = false;\n      }\n    }\n    // Wait for kernel to exit\n    e.wait();\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"
    },
    {
        "label": "main.cpp",
        "data": "#include <iostream>\n#include <cmath>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass IDVectorOp;\n\nconstexpr int kSize = 3;\nusing D3Vector = std::array<float, kSize>;\n\n// Minimum capacity of a pipe.\n// Set to 0 to allow the compiler to save area if possible.\nconstexpr size_t kPipeMinCapacity = 0;\n\n// Pipes\nclass IDInputPipeA;\nclass IDOutputPipeZ;\n\nusing InputPipeA = sycl::ext::intel::experimental::pipe<IDInputPipeA, D3Vector,\n                                                        kPipeMinCapacity>;\nusing OutputPipeZ = sycl::ext::intel::experimental::pipe<IDOutputPipeZ, float,\n                                                         kPipeMinCapacity>;\n\n// The square-root of a dot-product is an expensive operation for it consumes a\n// significant amount of area resources.\nfloat OpSqrt(D3Vector val, const D3Vector coef) {\n  float res = sqrt(val[0] * coef[0] + val[1] * coef[1] + val[2] * coef[2]);\n  return res;\n}\n\nstruct VectorOp {\n  void operator()() const {\n    constexpr D3Vector kCoef1 = {0.2, 0.3, 0.4};\n    constexpr D3Vector kCoef2 = {0.6, 0.7, 0.8};\n\n    D3Vector new_item;\n\n    // Calling OpSqrt() in a loop will re-use it\n    for (int i = 0; i < new_item.size(); i++) {\n      D3Vector item = InputPipeA::read();\n      new_item[i] = OpSqrt(item, kCoef1);\n    }\n\n    // Another square root block will be generated for this function call\n    OutputPipeZ::write(OpSqrt(new_item, kCoef2));\n  }\n};\n\nint main() {\n  constexpr int kN = 5;\n  bool passed = false;\n\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // initialize input D3Vector\n    constexpr float test_vecs[kSize][kSize] = {\n        {.49, .26, .82}, {.78, .43, .92}, {.17, .72, .34}};\n\n    // input data\n    for (int j = 0; j < kN; j++) {\n      for (int i = 0; i < kSize; i++) {\n        D3Vector data;\n        for (int k = 0; k < kSize; k++) {\n          data[k] = test_vecs[i][k];\n        }\n        InputPipeA::write(q, data);\n      }\n    }\n\n    std::cout << \"Processing vector of size \" << kSize << std::endl;\n\n    float result[kN];\n    sycl::event e;\n    for (int i = 0; i < kN; i++) {\n      e = q.single_task<IDVectorOp>(VectorOp{});\n    }\n\n    // verify that result is correct\n    passed = true;\n    for (int i = 0; i < kN; i++) {\n      result[i] = OutputPipeZ::read(q);\n    }\n    for (int i = 1; i < kN; i++) {\n      if (result[i] != result[i - 1]) {\n        std::cerr << \"idx=\" << i << \", loop result \" << result[i]\n                  << \", previously \" << result[i - 1] << std::endl;\n        passed = false;\n      }\n    }\n    // Wait for kernel to exit\n    e.wait();\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"
    },
    {
        "label": "dsp_control.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\nfloat subtract(float a, float b) { return a - b; }\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass GlobalControl;\nclass LocalControlPropagateOn;\nclass LocalControlPropagateOff;\n\n// Runs the Kernel.\nvoid KernelRun(const std::vector<float> &input_data,\n               std::vector<float> &output_data_add,\n               std::vector<float> &output_data_sub) {\n\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    // Create the SYCL device queue.\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    buffer input_buffer(input_data);\n    buffer output_add_buffer(output_data_add);\n    buffer output_sub_buffer(output_data_sub);\n\n    q.submit([&](handler &h) {\n      accessor input_a(input_buffer, h, read_only);\n      accessor output_add_a(output_add_buffer, h, write_only, no_init);\n      accessor output_sub_a(output_sub_buffer, h, write_only, no_init);\n\n      // Kernel that demonstrates DSP global control.\n      h.single_task<GlobalControl>([=]() [[intel::kernel_args_restrict]] {\n        // Command-line option `-Xsdsp-mode=prefer-softlogic` controls both\n        // addition and subtraction to be implemented in soft-logic.\n        output_add_a[0] = input_a[0] + input_a[1];\n        output_sub_a[0] = subtract(input_a[0], input_a[1]);\n      });\n    });\n\n    q.submit([&](handler &h) {\n      accessor input_a(input_buffer, h, read_only);\n      accessor output_add_a(output_add_buffer, h, write_only, no_init);\n      accessor output_sub_a(output_sub_buffer, h, write_only, no_init);\n\n      // Kernel that demonstrates DSP local control with Propagate::On.\n      h.single_task<LocalControlPropagateOn>([=\n      ]() [[intel::kernel_args_restrict]] {\n        // The local control library function overrides the global control.\n        // Because the Propagate argument is On, not only the addition directly\n        // in the lambda, but also the subtraction in the subtract() function\n        // call inside the lambda are affected by the local control and will be\n        // implemented in DSP.\n        ext::intel::math_dsp_control<>([&] {\n          output_add_a[1] = input_a[0] + input_a[1];\n          output_sub_a[1] = subtract(input_a[0], input_a[1]);\n        });\n      });\n    });\n\n    q.submit([&](handler &h) {\n      accessor input_a(input_buffer, h, read_only);\n      accessor output_add_a(output_add_buffer, h, write_only, no_init);\n      accessor output_sub_a(output_sub_buffer, h, write_only, no_init);\n\n      // Kernel that demonstrates DSP local control with Propagate::Off.\n      h.single_task<LocalControlPropagateOff>([=\n      ]() [[intel::kernel_args_restrict]] {\n        // The local control library function overrides the global control.\n        // Because the Propagate argument is Off, only the addition directly in\n        // the lambda is affected by the local control and will be implemented\n        // in DSP. The subtraction in the subtract() function call is only\n        // affected by the global control so will be implemented in soft-logic.\n        ext::intel::math_dsp_control<ext::intel::Preference::DSP,\n                                     ext::intel::Propagate::Off>([&] {\n          output_add_a[2] = input_a[0] + input_a[1];\n          output_sub_a[2] = subtract(input_a[0], input_a[1]);\n        });\n      });\n    });\n\n  } catch (exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}\n\nint main() {\n  std::vector<float> input_data = {1.23f, 2.34f};\n  std::vector<float> output_data_add(3);\n  std::vector<float> output_data_sub(3);\n\n  KernelRun(input_data, output_data_add, output_data_sub);\n\n  bool passed = true;\n  float golden_add = input_data[0] + input_data[1];\n  float golden_sub = subtract(input_data[0], input_data[1]);\n\n  std::string kernel_names[] = {\"GlobalControl\", \"LocalControlPropagateOn\",\n                                \"LocalControlPropagateOff\"};\n  for (int i = 0; i <= 2; i++) {\n    if (output_data_add[i] != golden_add) {\n      std::cout << \"Kernel \" << kernel_names[i] << \" add output mismatch: \\n\"\n                << \"output = \" << output_data_add[i]\n                << \", golden = \" << golden_add << \"\\n\";\n      passed = false;\n    }\n    if (output_data_sub[i] != golden_sub) {\n      std::cout << \"Kernel \" << kernel_names[i] << \" sub output mismatch: \\n\"\n                << \"output = \" << output_data_sub[i]\n                << \", golden = \" << golden_sub << \"\\n\";\n      passed = false;\n    }\n  }\n\n  if (passed) {\n    std::cout << \"PASSED: all kernel results are correct.\\n\";\n  } else {\n    std::cout << \"FAILED\\n\";\n  }\n  return passed ? 0 : 1;\n}\n"
    },
    {
        "label": "io_streaming.cpp",
        "data": "#include <algorithm>\n#include <chrono>\n#include <iostream>\n#include <numeric>\n#include <chrono>\n#include <thread>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\n// The type that will stream through the IO pipe. When using real IO pipes,\n// make sure the width of this datatype matches the width of the IO pipe, which\n// you can find in the BSP XML file.\nusing IOPipeType = int;\n\n#include \"LoopbackTest.hpp\"\n#include \"SideChannelTest.hpp\"\n\nusing namespace sycl;\n\n// check is USM host allocations are enabled\n#if defined(USM_HOST_ALLOCATIONS)\nconstexpr bool kUseUSMHostAllocation = true;\n#else\nconstexpr bool kUseUSMHostAllocation = false;\n#endif\n\nint main() {\n  bool passed = true;\n\n#if defined(FPGA_EMULATOR)\n  size_t count = 1 << 12;\n#elif defined(FPGA_SIMULATOR)\n  size_t count = 1 << 5;\n#else\n  size_t count = 1 << 24;\n#endif\n\n  try {\n    // device selector\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // queue properties to enable SYCL profiling of kernels\n    auto prop_list = property_list{property::queue::enable_profiling()};\n\n    // create the device queue\n    queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // run the loopback example system\n    // see 'LoopbackTest.hpp'\n    std::cout << \"Running loopback test\\n\";\n    passed &= \n      RunLoopbackSystem<IOPipeType, kUseUSMHostAllocation>(q, count);\n\n    // run the side channel example system\n    // see 'SideChannelTest.hpp'\n    std::cout << \"Running side channel test\\n\";\n    passed &= \n      RunSideChannelsSystem<IOPipeType, kUseUSMHostAllocation>(q, count);\n\n  } catch (exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  if (passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n\n"
    },
    {
        "label": "double_buffering.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <cmath>\n#include <iomanip>\n#include <random>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// kTimes = # times to execute the kernel. kTimes must be >= 2\n// kSize = # of floats to process on each kernel execution.\n// run less in emulation to avoid high run time\n#if defined(FPGA_EMULATOR)\nconstexpr int kTimes = 20;\nconstexpr int kSize = 4096;\n#elif defined(FPGA_SIMULATOR)\nconstexpr int kTimes = 10;\nconstexpr int kSize = 1024;\n#else\nconstexpr int kTimes = 100;\nconstexpr int kSize = 2621440;\n#endif\n\n// Kernel executes a power function (base^kPow). Must be\n// >= 2. Can increase this to increase kernel execution\n// time, but ProcessOutput() time will also increase.\n#if defined(FPGA_SIMULATOR)\nconstexpr int kPow = 5;\n#else\nconstexpr int kPow = 20;\n#endif\n\n// Number of iterations through the main loop\nconstexpr int kNumRuns = 2;\n\nbool pass = true;\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass SimpleVpow;\n\n/*  Kernel function.\n    Performs buffer_b[i] = buffer_a[i] ** pow\n    Only supports pow >= 2.\n    This kernel is not meant to be an optimal implementation of the power\n   operation -- it's just a sample kernel for this tutorial whose execution time\n   is easily controlled via the pow parameter. SYCL buffers are created\n   externally and passed in by reference to control (external to this function)\n   when the buffers are destructed. The destructor causes a blocking buffer\n   transfer from device to host and double buffering requires us to not block\n   here (because we need to launch another kernel). So we only want this\n   transfer to occur at the end of overall execution, not at the end of each\n   individual kernel execution.\n*/\nvoid SimplePow(sycl::queue &q, buffer<float, 1> &buffer_a,\n               buffer<float, 1> &buffer_b, event &e) {\n  // Submit to the queue and execute the kernel\n  e = q.submit([&](handler &h) {\n    // Get kernel access to the buffers\n    accessor accessor_a(buffer_a, h, read_only);\n    accessor accessor_b(buffer_b, h, read_write, no_init);\n\n    const int num = kSize;\n    assert(kPow >= 2);\n    const int p = kPow - 1;  // Assumes pow >= 2;\n\n    h.single_task<SimpleVpow>([=]() [[intel::kernel_args_restrict]] {\n      for (int j = 0; j < p; j++) {\n        if (j == 0) {\n          for (int i = 0; i < num; i++) {\n            accessor_b[i] = accessor_a[i] * accessor_a[i];\n          }\n        } else {\n          for (int i = 0; i < num; i++) {\n            accessor_b[i] = accessor_b[i] * accessor_a[i];\n          }\n        }\n      }\n    });\n  });\n\n  event update_host_event;\n  update_host_event = q.submit([&](handler &h) {\n    accessor accessor_b(buffer_b, h, read_only);\n\n    /*\n      Explicitly instruct the SYCL runtime to copy the kernel's output buffer\n      back to the host upon kernel completion. This is not required for\n      functionality since the buffer access in ProcessOutput() also implicitly\n      instructs the runtime to copy the data back. But it should be noted that\n      this buffer access blocks ProcessOutput() until the kernel is complete\n      and the data is copied. In contrast, update_host() instructs the runtime\n      to perform the copy earlier. This allows ProcessOutput() to optionally\n      perform more useful work *before* making the blocking buffer access. Said\n      another way, this allows ProcessOutput() to potentially perform more work\n      in parallel with the runtime's copy operation.\n    */\n    h.update_host(accessor_b);\n  });\n}\n\n// Returns kernel execution time for a given SYCL event from a queue.\nunsigned long SyclGetExecTimeNs(event e) {\n  unsigned long start_time =\n      e.get_profiling_info<info::event_profiling::command_start>();\n  unsigned long end_time = e.get_profiling_info<info::event_profiling::command_end>();\n  return (end_time - start_time);\n}\n\n// Local pow function for verifying results\nfloat MyPow(float input, int pow) {\n  return (pow == 0) ? 1 : input * MyPow(input, pow - 1);\n}\n\n/*  Compares kernel output against expected output. Only compares part of the\n   output so that this method completes quickly. This is done\n   intentionally/artificially keep host-processing time shorter than kernel\n   execution time. Grabs kernel output data from its SYCL buffer. Reading from\n   this buffer is a blocking operation that will block on the kernel completing.\n    Queries and records execution time of the kernel that just completed. This\n   is a natural place to do this because ProcessOutput() is blocked on kernel\n   completion.\n*/\nvoid ProcessOutput(buffer<float, 1> &input_buf, buffer<float, 1> &output_buf,\n                   int exec_number, event e,\n                   unsigned long &total_kernel_time_per_slot) {\n  host_accessor input_buf_acc(input_buf, read_only);\n  host_accessor output_buf_acc(output_buf, read_only);\n  int num_errors = 0;\n  int num_errors_to_print = 10;\n\n  // Max fractional difference between FPGA pow result and CPU pow result\n  // Anything greater than this will be considered an error\n  constexpr double epsilon = 0.01;\n\n  /*  The use of update_host() in the kernel function allows for additional\n     host-side operations to be performed here, in parallel with the buffer copy\n     operation from device to host, before the blocking access to the output\n     buffer is made via output_buf_acc[]. To be clear, no real operations are\n     done here and this is just a note that this is the place\n      where you *could* do it. */\n  for (int i = 0; i < kSize / 8; i++) {\n    const double expected_value = MyPow(input_buf_acc[i], kPow);\n    const bool out_invalid = std::abs((output_buf_acc[i] - expected_value) /\n                                      expected_value) > epsilon;\n    if ((num_errors < num_errors_to_print) && out_invalid) {\n      if (num_errors == 0) {\n        pass = false;\n        std::cout << \"Verification failed on kernel execution # \" << exec_number\n                  << \". Showing up to \" << num_errors_to_print\n                  << \" mismatches.\\n\";\n      }\n      std::cout << \"Verification failed on kernel execution # \" << exec_number\n                << \", at element \" << i << \". Expected \" << std::fixed\n                << std::setprecision(16) << expected_value << \" but got \"\n                << output_buf_acc[i] << \"\\n\";\n      num_errors++;\n    }\n  }\n\n  // At this point we know the kernel has completed,\n  // so can query the profiling data.\n  total_kernel_time_per_slot += SyclGetExecTimeNs(e);\n}\n\n/*\n    Generates input data for the next kernel execution. Only fills part of the\n   buffer so that this method completes quickly. This is done\n   intentionally/artificially keep host-processing time shorter than kernel\n   execution time. Writes the data into the associated SYCL buffer. The write\n   will block until the previous kernel execution, that is using this buffer,\n   completes.\n*/\nvoid ProcessInput(buffer<float, 1> &buf) {\n  // We are generating completely new input data, so can the no_init property\n  // here to indicate we don't care about the SYCL buffer's current contents.\n  host_accessor buf_acc(buf, write_only, no_init);\n\n  // RNG seed\n  auto seed = std::chrono::system_clock::now().time_since_epoch().count();\n\n  // RNG engine\n  std::default_random_engine dre(seed);\n\n  // generate random numbers between 1 and 2\n  std::uniform_real_distribution<float> di(1.0f, 2.0f);\n\n  // Randomly generate a start value and increment from there.\n  // Compared to randomly generating every value, this is done to\n  // speed up this function a bit.\n  float start_val = di(dre);\n\n  for (int i = 0; i < kSize / 8; i++) {\n    buf_acc[i] = start_val;\n    start_val++;\n  }\n}\n\nint main() {\n\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n#ifndef FPGA_HARDWARE\n  std::cout << \"\\nEmulator and simulator outputs do not demonstrate \"\n               \"true hardware performance. The design may need to run \"\n               \"on actual hardware to observe the performance benefit \"\n               \"of the optimization exemplified in this tutorial.\\n\\n\";\n#endif\n\n  try {\n    auto prop_list = property_list{property::queue::enable_profiling()};\n\n    sycl::queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    platform platform = q.get_context().get_platform();\n    device device = q.get_device();\n\n    std::cout << \"Platform name: \"\n              << platform.get_info<info::platform::name>().c_str() << \"\\n\";\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    std::cout << \"Executing kernel \" << kTimes << \" times in each round.\\n\\n\";\n\n    // Create a vector to store the input/output SYCL buffers\n    std::vector<buffer<float, 1>> input_buf;\n    std::vector<buffer<float, 1>> output_buf;\n\n    // SYCL events for each kernel launch.\n    event sycl_events[2];\n\n    // In nanoseconds. Total execution time of kernels in a given slot.\n    unsigned long total_kernel_time_per_slot[2];\n\n    // Total execution time of all kernels.\n    unsigned long total_kernel_time = 0;\n\n    // Allocate vectors to store the host-side copies of the input data\n    // Create and allocate the SYCL buffers\n    for (int i = 0; i < 2; i++) {\n      input_buf.push_back(buffer<float, 1>(range<1>(kSize)));\n      output_buf.push_back(buffer<float, 1>(range<1>(kSize)));\n    }\n\n    /*\n      Main loop. This loop runs twice to show the performance difference without\n      and with double buffering.\n    */\n    for (int i = 0; i < kNumRuns; i++) {\n      for (int i = 0; i < 2; i++) {\n        total_kernel_time_per_slot[i] = 0;  // Initialize timers to zero.\n      }\n\n      switch (i) {\n        case 0: {\n          std::cout << \"*** Beginning execution, without double buffering\\n\";\n          break;\n        }\n        case 1: {\n          std::cout << \"*** Beginning execution, with double buffering.\\n\";\n          break;\n        }\n        default: {\n          std::cout << \"*** Beginning execution.\\n\";\n        }\n      }\n\n      // Start the timer. This will include the time to process the input data\n      // for the first 2 kernel executions.\n      auto start = std::chrono::steady_clock::now();\n\n      if (i == 0) {  // Single buffering\n        for (int i = 0; i < kTimes; i++) {\n          // Only print every few iterations, just to limit the prints.\n          if (i % 10 == 0) {\n            std::cout << \"Launching kernel #\" << i << \"\\n\";\n          }\n\n          ProcessInput(input_buf[0]);\n          SimplePow(q, input_buf[0], output_buf[0], sycl_events[0]);\n          ProcessOutput(input_buf[0], output_buf[0], i, sycl_events[0],\n                        total_kernel_time_per_slot[0]);\n        }\n      } else {  // Double buffering\n        // Process input for first 2 kernel launches and queue them. Then block\n        // on processing the output of the first kernel.\n        ProcessInput(input_buf[0]);\n        ProcessInput(input_buf[1]);\n\n        std::cout << \"Launching kernel #0\\n\";\n\n        SimplePow(q, input_buf[0], output_buf[0], sycl_events[0]);\n        for (int i = 1; i < kTimes; i++) {\n          if (i % 10 == 0) {\n            std::cout << \"Launching kernel #\" << i << \"\\n\";\n          }  // Only print every few iterations, just to limit the prints.\n\n          // Launch the next kernel\n          SimplePow(q, input_buf[i % 2], output_buf[i % 2], sycl_events[i % 2]);\n\n          // Process output from previous kernel. This will block on kernel\n          // completion.\n          ProcessOutput(input_buf[(i - 1) % 2], output_buf[(i - 1) % 2], i,\n                        sycl_events[(i - 1) % 2],\n                        total_kernel_time_per_slot[(i - 1) % 2]);\n\n          // Generate input for the next kernel.\n          ProcessInput(input_buf[(i - 1) % 2]);\n        }\n\n        // Process output of the final kernel\n        ProcessOutput(input_buf[(kTimes - 1) % 2], output_buf[(kTimes - 1) % 2],\n                      i, sycl_events[(kTimes - 1) % 2],\n                      total_kernel_time_per_slot[(kTimes - 1) % 2]);\n      }\n\n      // Add up the overall kernel execution time.\n      total_kernel_time = 0;\n      for (int i = 0; i < 2; i++) {\n        total_kernel_time += total_kernel_time_per_slot[i];\n      }\n\n      // Stop the timer.\n      auto end = std::chrono::steady_clock::now();\n      double time_span = std::chrono::duration_cast<std::chrono::duration<double>>(end - start).count();\n\n      std::cout << \"\\nOverall execution time \"\n                << ((i == 0) ? \"without\" : \"with\")\n                << \" double buffering = \" << (unsigned)(time_span * 1000)\n                << \" ms\\n\";\n      std::cout << \"Total kernel-only execution time \"\n                << ((i == 0) ? \"without\" : \"with\") << \" double buffering = \"\n                << (unsigned)(total_kernel_time / 1000000) << \" ms\\n\";\n      std::cout << \"Throughput = \" << std::setprecision(8)\n                << (float)kSize * (float)kTimes * (float)sizeof(float) /\n                       (float)time_span / 1000000\n                << \" MB/s\\n\\n\\n\";\n    }\n    if (pass) {\n      std::cout << \"Verification PASSED\\n\";\n    } else {\n      std::cout << \"Verification FAILED\\n\";\n      return 1;\n    }\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n      std::cerr << \"If you are targeting the FPGA simulator, compile with \"\n                   \"-DFPGA_SIMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n  return 0;\n}\n"
    },
    {
        "label": "compute_units.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <iostream>\n\n#include \"exception_handler.hpp\"\n#include \"compute_units.hpp\"\n#include \"pipe_utils.hpp\" // Included from DirectProgramming/C++SYCL_FPGA/include/\n\n\nusing namespace sycl;\n\nconstexpr float kTestData = 555;\nconstexpr size_t kEngines = 5;\n\nusing Pipes = fpga_tools::PipeArray<class MyPipe, float, 1, kEngines + 1>;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass Source;\nclass Sink;\ntemplate <std::size_t ID> class ChainComputeUnit;\n\n// Write the data into the chain\nvoid SourceKernel(queue &q, float data) {\n  q.single_task<Source>([=] { Pipes::PipeAt<0>::write(data); });\n}\n\n// Get the data out of the chain and return it to the host\nvoid SinkKernel(queue &q, float &out_data) {\n\n  // The verbose buffer syntax is necessary here,\n  // since out_data is just a single scalar value\n  // and its size can not be inferred automatically\n  buffer<float, 1> out_buf(&out_data, 1);\n\n  q.submit([&](handler &h) {\n    accessor out_accessor(out_buf, h, write_only, no_init);\n    h.single_task<Sink>([=] {\n      out_accessor[0] = Pipes::PipeAt<kEngines>::read();\n    });\n  });\n}\n\nint main() {\n\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  float out_data = 0;\n\n  try {\n    queue q(selector, fpga_tools::exception_handler);\n\n    sycl::device device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Enqueue the Source kernel\n    SourceKernel(q, kTestData);\n\n    // Enqueue the chain of kEngines compute units\n    // Compute unit must take a single argument, its ID\n    SubmitComputeUnits<kEngines, ChainComputeUnit>(q, [=](auto ID) {\n      auto f = Pipes::PipeAt<ID>::read();\n      // Pass the data to the next compute unit in the chain\n      // The compute unit with ID k reads from pipe k and writes to pipe\n      // k + 1\n      Pipes::PipeAt<ID + 1>::write(f);\n    });\n\n    // Enqueue the Sink kernel\n    SinkKernel(q, out_data);\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  // Verify result\n  if (out_data != kTestData) {\n    std::cout << \"FAILED: The results are incorrect\\n\";\n    std::cout << \"Expected: \" << kTestData << \" Got: \" << out_data << \"\\n\";\n    return 1;\n  }\n\n  std::cout << \"PASSED: The results are correct\\n\";\n  return 0;\n}\n"
    },
    {
        "label": "compute_units.hpp",
        "data": "#include <sycl/sycl.hpp>\n#include <utility>\n\nnamespace {\ntemplate <typename Func, template <std::size_t> typename Name,\n          std::size_t Index>\nclass SubmitOneComputeUnit {\npublic:\n  SubmitOneComputeUnit(Func &&f, sycl::queue &q) {\n    q.single_task<Name<Index>>([=] {\n      static_assert(\n          std::is_invocable_v<Func, std::integral_constant<std::size_t, Index>>,\n          \"The callable Func passed to SubmitComputeUnits must take a single \"\n          \"argument of type auto\");\n      f(std::integral_constant<std::size_t, Index>());\n    });\n  }\n};\n\ntemplate <template <std::size_t> typename Name, typename Func,\n          std::size_t... Indices>\ninline constexpr void ComputeUnitUnroller(sycl::queue &q, Func &&f,\n                                          std::index_sequence<Indices...>) {\n  (SubmitOneComputeUnit<Func, Name, Indices>(f, q), ...); // fold expression\n}\n} // namespace\n\ntemplate <std::size_t N,                           // Number of compute units\n          template <std::size_t ID> typename Name, // Name for the compute units\n          typename Func>                           // Callable defining compute\n                                                   // units' functionality\n\n// Func must take a single argument. This argument is the compute unit's ID.\n// The compute unit ID is a constexpr, and it can be used to specialize\n// the kernel's functionality.\n// Note: the type of Func's single argument must be 'auto', because Func\n// will be called with various indices (i.e., the ID for each compute unit)\nconstexpr void SubmitComputeUnits(sycl::queue &q, Func &&f) {\n  std::make_index_sequence<N> indices;\n  ComputeUnitUnroller<Name>(q, f, indices);\n}\n"
    },
    {
        "label": "onchip_memory_cache.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <algorithm>\n#include <chrono>\n\n#include \"onchip_memory_with_cache.hpp\" // DirectProgramming/C++SYCL_FPGA/include\n#include \"unrolled_loop.hpp\"            // DirectProgramming/C++SYCL_FPGA/include\n\n#include \"exception_handler.hpp\"\n\n#if defined(FPGA_SIMULATOR)\n// Smaller size to keep the runtime reasonable\nconstexpr int kInitNumInputs = 16 * 1024;  // Default number of inputs\n// Only test a single cache depth in simulation mode\nconstexpr int kMaxCacheDepth = 5; // max cache depth to test\nconstexpr int kMinCacheDepth = 5; // min cache depth to test\n#else\nconstexpr int kInitNumInputs = 16 * 1024 * 1024;  // Default number of inputs\nconstexpr int kMaxCacheDepth = MAX_CACHE_DEPTH; // max cache depth to test\nconstexpr int kMinCacheDepth = MIN_CACHE_DEPTH; // min cache depth to test\n#endif\n\nconstexpr int kNumOutputs = 64;           // Number of outputs\nconstexpr int kInitSeed = 42;             // Seed for randomizing data inputs\n\nconstexpr double kNs = 1000000000.0;      // number of nanoseconds in a second\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\ntemplate<size_t cache_depth> class HistogramID;\n\ntemplate<size_t k_cache_depth>\nvoid ComputeHistogram(sycl::queue &q, sycl::buffer<uint32_t>& input_buf,\n                      sycl::buffer<uint32_t>& output_buf, sycl::event& e) {\n  // Enqueue  kernel\n  e = q.submit([&](sycl::handler& h) {\n    // Get accessors to the SYCL buffers\n    sycl::accessor input(input_buf, h, sycl::read_only);\n    sycl::accessor output(output_buf, h, sycl::write_only, sycl::no_init);\n\n    h.single_task<HistogramID<k_cache_depth>>(\n    [=]() [[intel::kernel_args_restrict]] {\n\n      // On-chip memory for Histogram\n      // A k_cache_depth of 0 is equivalent to a standard array with no cache\n      fpga_tools::OnchipMemoryWithCache<uint32_t, kNumOutputs, k_cache_depth> \n        histogram(0);\n      // Compute the Histogram\n      for (uint32_t n = 0; n < kInitNumInputs; ++n) {\n        uint32_t hist_group = input[n] % kNumOutputs;\n        auto hist_count = histogram.read(hist_group);\n        hist_count++;\n        histogram.write(hist_group, hist_count);\n      }\n\n      // Write output to global memory\n      for (uint32_t hist_group = 0; hist_group < kNumOutputs; ++hist_group) {\n        output[hist_group] = histogram.read(hist_group);\n      }\n    });\n  });\n}\n\nint main() {\n  // Host and kernel profiling\n  sycl::event e;\n  unsigned long t1_kernel, t2_kernel;\n  double time_kernel;\n\n// Create queue, get platform and device\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n#ifndef FPGA_HARDWARE\n  std::cout << \"\\nEmulator and simulator outputs do not demonstrate \"\n               \"true hardware performance. The design may need to run \"\n               \"on actual hardware to observe the performance benefit \"\n               \"of the optimization exemplified in this tutorial.\\n\\n\";\n#endif\n\n  try {\n    auto prop_list =\n        sycl::property_list{sycl::property::queue::enable_profiling()};\n\n    sycl::queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    sycl::platform platform = q.get_context().get_platform();\n    sycl::device device = q.get_device();\n    std::cout << \"Platform name: \"\n              << platform.get_info<sycl::info::platform::name>().c_str() \n              << \"\\n\";\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    std::cout << \"\\nNumber of inputs: \" << kInitNumInputs << \"\\n\";\n    std::cout << \"Number of outputs: \" << kNumOutputs << \"\\n\\n\";\n\n    // Create input and output buffers\n    auto input_buf = sycl::buffer<uint32_t>(sycl::range<1>(kInitNumInputs));\n    auto output_buf = sycl::buffer<uint32_t>(sycl::range<1>(kNumOutputs));\n\n    srand(kInitSeed);\n\n    // Compute the reference solution\n    uint32_t gold[kNumOutputs];\n\n    {\n      // Get host-side accessors to the SYCL buffers\n      sycl::host_accessor input_host(input_buf, sycl::write_only);\n      // Initialize random input\n      for (int i = 0; i < kInitNumInputs; ++i) {\n        input_host[i] = rand();\n      }\n\n      for (int hist_group = 0; hist_group < kNumOutputs; ++hist_group) {\n        gold[hist_group] = 0;\n      }\n      for (int i = 0; i < kInitNumInputs; ++i) {\n        int hist_group = input_host[i] % kNumOutputs;\n        gold[hist_group]++;\n      }\n    }\n\n    // Host accessor is now out-of-scope and is destructed. This is required\n    // in order to unblock the kernel's subsequent accessor to the same buffer.\n\n    // iterate over the cache depths\n    for (int i = kMinCacheDepth; i < kMaxCacheDepth + 1; i++) {\n\n      std::cout << \"Beginning run with cache depth \" << i;\n      if (i == 0) { std::cout << \" (no cache)\"; }\n      std::cout << std::endl;\n\n      // ComputeHistogram is templated on the cache depth, and template\n      // parameters must be compile time constants. This unrolled loop allows\n      // us to convert the runtime variable i into a compile time constant j.\n      fpga_tools::UnrolledLoop<kMinCacheDepth, kMaxCacheDepth+1>([&](auto j) {\n        if (j == i) {\n          ComputeHistogram<j>(q, input_buf, output_buf, e);\n        }\n      });\n\n      // Wait for kernel to finish\n      q.wait();\n\n      // Compute kernel execution time\n      t1_kernel = \n        e.get_profiling_info<sycl::info::event_profiling::command_start>();\n      t2_kernel = \n        e.get_profiling_info<sycl::info::event_profiling::command_end>();\n      time_kernel = (t2_kernel - t1_kernel) / kNs;\n\n      // Get accessor to output buffer. Accessing the buffer at this point in\n      // the code will block on kernel completion.\n      sycl::host_accessor output_host(output_buf);\n\n      // Verify output and print pass/fail, and clear the output buffer\n      bool passed = true;\n      int num_errors = 0;\n      for (int hist_group = 0; hist_group < kNumOutputs; hist_group++) {\n        if (num_errors < 10 && output_host[hist_group] != gold[hist_group]) {\n          passed = false;\n          std::cout << \" data mismatch in bucket: \" << hist_group\n                    << \", expected \" << gold[hist_group]\n                    << \", received from kernel: \" << output_host[hist_group]\n                    << std::endl;\n          num_errors++;\n        }\n        output_host[hist_group] = 0;\n      }\n\n      if (passed) {\n        std::cout << \"Data check succeeded for cache depth \" << i \n                  << std::endl;\n        std::cout.setf(std::ios::fixed);\n        double N_MB = (kInitNumInputs * sizeof(uint32_t)) /\n                      (1024 * 1024);  // Input size in MB\n        std::cout << \"Kernel execution time: \" << time_kernel << \" seconds\" \n                  << std::endl;\n        std::cout << \"Kernel throughput for cache depth \" << i << \": \"\n                  << (N_MB / time_kernel) << \" MB/s\" << std::endl << std::endl;\n      } else {\n        std::cout << \"Verification FAILED\" << std::endl;\n        return 1;\n      }\n    }\n    std::cout << \"Verification PASSED\" << std::endl;\n\n  } catch (sycl::exception const& e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n  return 0;\n}\n"
    },
    {
        "label": "autorun.cpp",
        "data": "#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\n#include \"autorun.hpp\"\n\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace sycl;\n\n// choose the device selector based on emulation or actual hardware\n// we make this a global variable so it can be used by the autorun kernels\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n// declare the kernel names globally to reduce name mangling\nclass ARProducerID;\nclass ARKernelID;\nclass ARConsumerID;\nclass ARForeverProducerID;\nclass ARForeverKernelID;\nclass ARForeverConsumerID;\n\n// declare the pipe names globally to reduce name mangling\nclass ARProducePipeID;\nclass ARConsumePipeID;\nclass ARForeverProducePipeID;\nclass ARForeverConsumePipeID;\n\n// pipes\nusing ARProducePipe = ext::intel::pipe<ARProducePipeID, int>;\nusing ARConsumePipe = ext::intel::pipe<ARConsumePipeID, int>;\nusing ARForeverProducePipe = ext::intel::pipe<ARForeverProducePipeID, int>;\nusing ARForeverConsumePipe = ext::intel::pipe<ARForeverConsumePipeID, int>;\n\n////////////////////////////////////////////////////////////////////////////////\n// Autorun user kernel and global variable\nstruct MyAutorun {\n  void operator()() const {\n    // notice that in this version, we explicitly add the while(1)-loop\n    while (1) {\n      auto d = ARProducePipe::read();\n      ARConsumePipe::write(d);\n    }\n  }\n};\n\n// declaring a global instance of this class causes the constructor to be called\n// before main() starts, and the constructor launches the kernel.\nfpga_tools::Autorun<ARKernelID> ar_kernel{selector, MyAutorun{}};\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n// AutorunForever user kernel and global variable\n// The AutorunForever kernel implicitly wraps the code below in a while(1) loop\nstruct MyAutorunForever {\n  void operator()() const {\n    // this code is implicitly placed in a while(1)-loop by the\n    // fpga_tools::AutorunForever class\n    auto d = ARForeverProducePipe::read();\n    ARForeverConsumePipe::write(d);\n  }\n};\n\n// declaring a global instance of this class causes the constructor to be called\n// before main() starts, and the constructor launches the kernel.\nfpga_tools::AutorunForever<ARForeverKernelID> ar_forever_kernel{\n    selector, MyAutorunForever{}};\n////////////////////////////////////////////////////////////////////////////////\n\n//\n// Submit a kernel to read data from global memory and write to a pipe\n//\ntemplate <typename KernelID, typename Pipe>\nevent SubmitProducerKernel(queue& q, buffer<int, 1>& in_buf) {\n  return q.submit([&](handler& h) {\n    accessor in(in_buf, h, read_only);\n    int size = in_buf.size();\n    h.single_task<KernelID>([=] {\n      for (int i = 0; i < size; i++) {\n        Pipe::write(in[i]);\n      }\n    });\n  });\n}\n\n//\n// Submit a kernel to read data from a pipe and write to global memory\n//\ntemplate <typename KernelID, typename Pipe>\nevent SubmitConsumerKernel(queue& q, buffer<int, 1>& out_buf) {\n  return q.submit([&](handler& h) {\n    accessor out(out_buf, h, write_only, no_init);\n    int size = out_buf.size();\n    h.single_task<KernelID>([=] {\n      for (int i = 0; i < size; i++) {\n        out[i] = Pipe::read();\n      }\n    });\n  });\n}\n\nint main() {\n  int count = 5000;\n  bool passed = true;\n\n  std::vector<int> in_data(count), out_data(count);\n\n  // populate random input data, clear output data\n  std::generate(in_data.begin(), in_data.end(), [] { return rand() % 100; });\n  std::fill(out_data.begin(), out_data.end(), -1);\n\n  try {\n    // create the queue\n    queue q(selector, fpga_tools::exception_handler);\n\n    sycl::device device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // stream data through the Autorun kernel\n    std::cout << \"Running the Autorun kernel test\\n\";\n    {\n      // Create input and output buffers\n      buffer in_buf(in_data);\n      buffer out_buf(out_data);\n      SubmitProducerKernel<ARProducerID, ARProducePipe>(q, in_buf);\n      SubmitConsumerKernel<ARConsumerID, ARConsumePipe>(q, out_buf);\n    }\n\n    // validate the results\n    // operator== for a vector checks sizes, then checks per-element\n    passed &= (out_data == in_data);\n\n    // stream data through the AutorunForever kernel\n    std::cout << \"Running the AutorunForever kernel test\\n\";\n    {\n      // Create input and output buffers\n      buffer in_buf(in_data);\n      buffer out_buf(out_data);\n      SubmitProducerKernel<ARForeverProducerID, ARForeverProducePipe>(q,\n                                                                      in_buf);\n      SubmitConsumerKernel<ARForeverConsumerID, ARForeverConsumePipe>(q,\n                                                                      out_buf);\n    }\n\n    // validate the results\n    // operator== for a vector checks sizes, then checks per-element\n    passed &= (out_data == in_data);\n  } catch (sycl::exception const& e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  if (passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n"
    },
    {
        "label": "autorun.hpp",
        "data": "#ifndef __AUTORUN_HPP__\n#define __AUTORUN_HPP__\n\n#include <sycl/sycl.hpp>\n#include <type_traits>\n\n/*\nThis header defines the Autorun kernel utility. This utility is used to\nlaunch kernels that are submitted before main begins. It is typically used\nto launch kernels that run forever.\n\nTwo classes are defined in this header file: Autorun and AutorunForever.\nAutorun creates an autorun kernel that is NOT implicitly wrapped in an infinite\nloop.\n\nAutorunForever creates a kernel and wraps it in a while(1) loop.\nAutorun creates the kernel and does not wrap it in a while(1) loop.\nUsually when using Autorun the user will have the while(1) loop explicitly in\ntheir code.\n\nThe following describes the common template and constructor arguments for both\nthe Autorun and AutorunForever.\n\nTemplate Args:\n  KernelID (optional): the name of the autorun kernel.\n  DeviceSelector: The type of the device selector.\n  KernelFunctor: the kernel functor type.\nConstructor Arguments:\n    device_selector: the SYCL device selector\n    kernel: the user-defined kernel functor.\n            This defines the logic of the autorun kernel.\n*/\nnamespace fpga_tools {\n\nnamespace detail {\n// Autorun implementation\ntemplate <bool run_forever, typename KernelID>\nstruct Autorun_impl {\n  // Constructor with a kernel name\n  template <typename DeviceSelector, typename KernelFunctor>\n  Autorun_impl(DeviceSelector device_selector, KernelFunctor kernel) {\n    // static asserts to ensure KernelFunctor is callable\n    static_assert(std::is_invocable_r_v<void, KernelFunctor>,\n                  \"KernelFunctor must be callable with no arguments\");\n\n    // create the device queue\n    sycl::queue q{device_selector};\n\n    // submit the user's kernel\n    if constexpr (run_forever) {\n      if constexpr (std::is_same_v<KernelID, void>) {\n        // AutorunForever, kernel name not given\n        q.single_task([=] {\n          while (1) {\n            kernel();\n          }\n        });\n      } else {\n        // AutorunForever, kernel name given\n        q.single_task<KernelID>([=] {\n          while (1) {\n            kernel();\n          }\n        });\n      }\n    } else {\n      // run the kernel as-is, if the user wanted it to run forever they\n      // will write their own explicit while-loop\n      if constexpr (std::is_same_v<KernelID, void>) {\n        // Autorun, kernel name not given\n        q.single_task(kernel);\n      } else {\n        // Autorun, kernel name given\n        q.single_task<KernelID>(kernel);\n      }\n    }\n  }\n};\n}  // namespace detail\n\n// Autorun\ntemplate <typename KernelID = void>\nusing Autorun = detail::Autorun_impl<false, KernelID>;\n\n// AutorunForever\ntemplate <typename KernelID = void>\nusing AutorunForever = detail::Autorun_impl<true, KernelID>;\n}  // namespace fpga_tools\n\n#endif /* __AUTORUN_HPP__ */\n"
    },
    {
        "label": "simple_host_streaming.cpp",
        "data": "#include <algorithm>\n#include <array>\n#include <chrono>\n#include <iomanip>\n#include <functional>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <string>\n#include <type_traits>\n#include <utility>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\n#include \"single_kernel.hpp\"\n#include \"multi_kernel.hpp\"\n\nusing namespace sycl;\nusing namespace std::chrono;\n\n// data types and constants\n// NOTE: this tutorial assumes you are using a sycl::vec datatype. Therefore, \n// 'Type' can only be changed to a different vector datatype (e.g. int16,\n// long8, etc...)\nusing Type = long8;\n\n///////////////////////////////////////////////////////////////////////////////\n// forward declaration of the functions in this file\n// the function definitions are all below the main() function in this file\ntemplate<typename T>\nvoid DoWorkOffload(queue& q, T* in, T* out, size_t total_count,\n                   size_t iterations);\n\ntemplate<typename T>\nvoid DoWorkSingleKernel(queue& q, T* in, T* out,\n                        size_t chunks, size_t chunk_count, size_t total_count,\n                        size_t inflight_kernels, size_t iterations);\n\ntemplate <typename T>\nvoid DoWorkMultiKernel(queue& q, T* in, T* out,\n                       size_t chunks, size_t chunk_count, size_t total_count,\n                       size_t inflight_kernels, size_t iterations);\n\ntemplate<typename T>\nvoid PrintPerformanceInfo(std::string print_prefix, size_t count,\n                          std::vector<double>& latency_ms,\n                          std::vector<double>& process_time_ms);\n///////////////////////////////////////////////////////////////////////////////\n\n\nint main(int argc, char* argv[]) {\n  // default values\n#if defined(FPGA_EMULATOR)\n  size_t chunks = 1 << 4;         // 16\n  size_t chunk_count = 1 << 8;    // 256\n  size_t iterations = 2;\n#elif defined(FPGA_SIMULATOR)\n  size_t chunks = 1 << 3;         // 8\n  size_t chunk_count = 1 << 7;    // 128\n  size_t iterations = 2;\n#else\n  size_t chunks = 1 << 9;         // 512\n  size_t chunk_count = 1 << 15;   // 32768\n  size_t iterations = 5;\n#endif\n\n  // This is the number of kernels we will have in the queue at a single time.\n  // If this number is set too low (e.g. 1) then we don't take advantage of\n  // fast kernel relaunch (see the README). If this number is set to high,\n  // then the first kernel launched finishes before we are done launching all\n  // the kernels and therefore throughput is decreased.\n  size_t inflight_kernels = 2;\n\n  // parse the command line arguments\n  for (int i = 1; i < argc; i++) {\n    std::string arg(argv[i]);\n\n    if (arg == \"--help\" || arg == \"-h\") {\n      std::cout << \"USAGE: \"\n                << \"./simple_host_streaming \"\n                << \"[--chunks=<int>] \"\n                << \"[--chunk_count=<int>] \"\n                << \"[--inflight_kernels=<int>] \"\n                << \"[--iterations=<int>]\\n\";\n      return 0;\n    } else {\n      std::string str_after_equals = arg.substr(arg.find(\"=\") + 1);\n\n      if (arg.find(\"--chunks=\") == 0) {\n        chunks = atoi(str_after_equals.c_str());\n      } else if (arg.find(\"--chunk_count=\") == 0) {\n        chunk_count = atoi(str_after_equals.c_str());\n      } else if (arg.find(\"--inflight_kernels=\") == 0) {\n        inflight_kernels = atoi(str_after_equals.c_str());\n      } else if (arg.find(\"--iterations=\") == 0) {\n        iterations = std::max(2, atoi(str_after_equals.c_str()) + 1);\n      } else {\n        std::cout << \"WARNING: ignoring unknown argument '\" << arg << \"'\\n\";\n      }\n    }\n  }\n\n  // check the chunks\n  if (chunks <= 0) {\n    std::cerr << \"ERROR: 'chunks' must be greater than 0\\n\";\n    std::terminate();\n  }\n\n  // check the chunk size\n  if (chunk_count <= 0) {\n    std::cerr << \"ERROR: 'chunk_count' must be greater than 0\\n\";\n    std::terminate();\n  }\n\n  // check inflight_kernels\n  if (inflight_kernels <= 0) {\n    std::cerr << \"ERROR: 'inflight_kernels' must be positive\\n\";\n    std::terminate();\n  }\n\n  // check the number of iterations\n  if (iterations <= 0) {\n    std::cerr << \"ERROR: 'iterations' must be positive\\n\";\n    std::terminate();\n  }\n\n  // compute the total number of elements\n  size_t total_count = chunks * chunk_count;\n\n  std::cout << \"# Chunks:             \" << chunks << \"\\n\";\n  std::cout << \"Chunk count:          \" << chunk_count << \"\\n\";\n  std::cout << \"Total count:          \" << total_count << \"\\n\";\n  std::cout << \"Iterations:           \" << iterations-1 << \"\\n\";\n  std::cout << \"\\n\";\n\n  bool passed = true;\n\n  try {\n    // device selector\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // queue properties to enable profiling\n    property_list prop_list { property::queue::enable_profiling() };\n\n    // create the device queue\n    queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    // make sure the device supports USM host allocations\n    auto device = q.get_device();\n    if (!device.get_info<info::device::usm_host_allocations>()) {\n      std::cerr << \"ERROR: The selected device does not support USM host\"\n                << \" allocations\\n\";\n      std::terminate();\n    }\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // the USM input and output data\n    Type *in, *out;\n    if ((in = malloc_host<Type>(total_count, q)) == nullptr) {\n      std::cerr << \"ERROR: could not allocate space for 'in'\\n\";\n      std::terminate();\n    }\n    if ((out = malloc_host<Type>(total_count, q)) == nullptr) {\n      std::cerr << \"ERROR: could not allocate space for 'out'\\n\";\n      std::terminate();\n    }\n\n    // generate the random input data\n    // NOTE: by generating all of the data ahead of time, we are essentially\n    // assuming that the producer of data (producing data for the FPGA to\n    // consume) has infinite bandwidth. However, if the producer of data cannot\n    // produce data faster than our FPGA can consume it, the CPU producer will\n    // bottleneck the total throughput of the design.\n    std::generate_n(in, total_count, [] { return Type(rand() % 100); });\n\n    // a lambda function to validate the results\n    auto validate_results = [&] {\n      for (size_t i = 0; i < total_count; i++) {\n        auto comp = (in[i] == out[i]);\n        for (auto j = 0; j < comp.size(); j++) {\n          if (!comp[j]) {\n            std::cerr << \"ERROR: Values do not match, \"\n                      << \"in[\" << i << \"][\" << j << \"]:\" << in[i][j]\n                      << \" != out[\" << i << \"][\"<< j << \"]:\" << out[i][j]\n                      << \"\\n\";\n            return false;\n          }\n        }\n      }\n\n      return true;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // run the offload version, which is NOT optimized for latency at all\n    std::cout << \"Running the basic offload kernel\\n\";\n    DoWorkOffload(q, in, out, total_count, iterations);\n\n    // validate the results using the lambda\n    passed &= validate_results();\n\n    std::cout << \"\\n\";\n    ////////////////////////////////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////////////////////////////////\n    // run the optimized (for latency) version that uses fast kernel relaunch\n    // by keeping at most 'inflight_kernels' in the SYCL queue at a time\n    std::cout << \"Running the latency optimized single-kernel design\\n\";\n    DoWorkSingleKernel(q, in, out, chunks, chunk_count, total_count,\n                       inflight_kernels, iterations);\n\n    // validate the results using the lambda\n    passed &= validate_results();\n\n    std::cout << \"\\n\";\n    ////////////////////////////////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////////////////////////////////\n    // run the optimized (for latency) version with multiple kernels that uses\n    // fast kernel relaunch by keeping at most 'inflight_kernels' in the SYCL\n    // queue at a time\n    std::cout << \"Running the latency optimized multi-kernel design\\n\";\n    DoWorkMultiKernel(q, in, out, chunks, chunk_count, total_count,\n                      inflight_kernels, iterations);\n\n    // validate the results using the lambda\n    passed &= validate_results();\n\n    std::cout << \"\\n\";\n    ////////////////////////////////////////////////////////////////////////////\n\n    // free the USM pointers\n    sycl::free(in, q);\n    sycl::free(out, q);\n\n  } catch (exception const& e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n      std::cerr << \"If you are targeting the FPGA simulator, compile with \"\n                   \"-DFPGA_SIMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  if(passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n\n// the basic offload kernel version (doesn't care about latency)\ntemplate<typename T>\nvoid DoWorkOffload(queue& q, T* in, T* out, size_t total_count,\n                   size_t iterations) {\n  // timing data\n  std::vector<double> latency_ms(iterations);\n  std::vector<double> process_time_ms(iterations);\n\n  for (size_t i = 0; i < iterations; i++) {\n    auto start = high_resolution_clock::now();\n\n    // submit single kernel for entire buffer\n    // this function is defined in 'single_kernel.hpp'\n    auto e = SubmitSingleWorker(q, in, out, total_count);\n\n    // wait on the kernel to finish\n    e.wait();\n\n    auto end = high_resolution_clock::now();\n\n    // compute latency and processing time\n    duration<double, std::milli> process_time = end - start;\n\n    // in offload designs, the processing time and latency are identical\n    // since the synchronization between the host and device is coarse grain\n    // (i.e. the synchronization happens once ALL the data has been processed).\n    latency_ms[i] = process_time.count();\n    process_time_ms[i] = process_time.count();\n  }\n\n  // compute and print timing information\n  PrintPerformanceInfo<T>(\"Offload\",\n                          total_count, latency_ms, process_time_ms);\n}\n\n// The single-kernel version of the design.\n// This function optimizes for latency (while maintaining throughput) by\n// breaking the computation into 'chunks' and launching kernels for each\n// chunk. The synchronization of the kernel ending tells the host that the data\n// for the given chunk is ready in the output buffer.\ntemplate <typename T>\nvoid DoWorkSingleKernel(queue& q, T* in, T* out,\n                        size_t chunks, size_t chunk_count, size_t total_count,\n                        size_t inflight_kernels, size_t iterations) {\n  // timing data\n  std::vector<double> latency_ms(iterations);\n  std::vector<double> process_time_ms(iterations);\n\n  // count the number of chunks for which kernels have been started\n  size_t in_chunk = 0;\n\n  // count the number of chunks for which kernels have finished \n  size_t out_chunk = 0;\n\n  // use a queue to track the kernels in flight\n  // By queueing multiple kernels before waiting on the oldest to finish\n  // (inflight_kernels) we still have kernels in the SYCL queue and ready to\n  // launch while we call event.wait() on the oldest kernel in the queue.\n  // However, if we set 'inflight_kernels' too high, then the time to launch\n  // the first set of kernels will be longer than the time for the first kernel\n  // to finish and our latency and throughput will be negatively affected.\n  std::queue<event> event_q;\n\n  for (size_t i = 0; i < iterations; i++) {\n    // reset the output data to catch any untouched data\n    std::fill_n(out, total_count, -1);\n\n    // reset counters\n    in_chunk = 0;\n    out_chunk = 0;\n\n    // clear the queue\n    std::queue<event> clear_q;\n    std::swap(event_q, clear_q);\n\n    // latency timers\n    high_resolution_clock::time_point first_data_in, first_data_out;\n\n    auto start = high_resolution_clock::now();\n\n    do {\n      // if we still have kernels to launch, launch them in here\n      if (in_chunk < chunks) {\n        // launch the kernel\n        size_t chunk_offset = in_chunk*chunk_count; \n        // this function is defined in 'single_kernel.hpp'\n        auto e = SubmitSingleWorker(q, in + chunk_offset, out + chunk_offset,\n                                    chunk_count);\n\n        // push the kernel event into the queue\n        event_q.push(e);\n\n        // if this is the first chunk, track the time\n        if (in_chunk == 0) first_data_in = high_resolution_clock::now();\n        in_chunk++;\n      }\n\n      // wait on the earliest kernel to finish if either condition is met:\n      //    1) there are a certain number kernels in flight\n      //    2) all of the kernels have been launched\n      if ((event_q.size() >= inflight_kernels) || (in_chunk >= chunks)) {\n        // pop the earliest kernel event we are waiting on\n        auto e = event_q.front();\n        event_q.pop();\n\n        // wait on it to finish\n        e.wait();\n\n        // track the time if this is the first producer/consumer pair\n        if (out_chunk == 0) first_data_out = high_resolution_clock::now();\n\n        // The synchronization of the kernels ending tells us that, at this \n        // point, the first 'out_chunk' chunks are valid on the host.\n        // NOTE: This is the point where you would consume the output data\n        // at (out + out_chunk*chunk_size).\n        out_chunk++;\n      }\n    } while (out_chunk < chunks);\n\n    auto end = high_resolution_clock::now();\n\n    // compute latency and processing time\n    duration<double, std::milli> latency = first_data_out - first_data_in;\n    duration<double, std::milli> process_time = end - start;\n    latency_ms[i] = latency.count();\n    process_time_ms[i] = process_time.count();\n  }\n\n  // compute and print timing information\n  PrintPerformanceInfo<T>(\"Single-kernel\",\n                          total_count, latency_ms, process_time_ms);\n}\n\n//\n// The multi-kernel version of the design.\n// Like the single-kernel version of the design, this design optimizes for \n// latency (while maintaining throughput) by breaking the producing and\n// consuming of data into chunks. That is, the main kernel pipeline (K0, \n// K1, and K2 from SubmitMultiKernelWorkers above) are enqueued ONCE but\n// the producer and consumer kernels, that feed and consume data to the\n// the kernel pipeline, are broken into smaller chunks. The synchronization of\n// the producer and consumer kernels (specifically, the consumer kernel)\n// signals to the host that a new chunk of data is ready in host memory.\n// See the README file for more information on why a producer and consumer\n// kernel are created for this design style.\n//\n// The following is a block diagram of this kernel this function creates:\n//\n//  in |---| ProducePipe |----| Pipe0 |----| Pipe1 |----| ConsumePipe |---| out\n// --->| P |============>| K0 |======>| K1 |======>| K2 |============>| C |---->\n//     |---|             |----|       |----|       |----|             |---|\n//\n\n// the pipes used to produce/consume data\nusing ProducePipe = pipe<class ProducePipeClass, Type>;\nusing ConsumePipe = pipe<class ConsumePipeClass, Type>;\n\ntemplate <typename T>\nvoid DoWorkMultiKernel(queue& q, T* in, T* out,\n                        size_t chunks, size_t chunk_count, size_t total_count,\n                        size_t inflight_kernels, size_t iterations) {\n  // timing data\n  std::vector<double> latency_ms(iterations);\n  std::vector<double> process_time_ms(iterations);\n\n  // count the number of chunks for which kernels have been started\n  size_t in_chunk = 0;\n\n  // count the number of chunks for which kernels have finished \n  size_t out_chunk = 0;\n\n  // use a queue to track the kernels in flight\n  std::queue<std::pair<event,event>> event_q;\n\n  for (size_t i = 0; i < iterations; i++) {\n    // reset the output data to catch any untouched data\n    std::fill_n(out, total_count, -1);\n\n    // reset counters\n    in_chunk = 0;\n    out_chunk = 0;\n\n    // clear the queue\n    std::queue<std::pair<event,event>> clear_q;\n    std::swap(event_q, clear_q);\n\n    // latency timers\n    high_resolution_clock::time_point first_data_in, first_data_out;\n\n    // launch the worker kernels\n    // NOTE: these kernels will process ALL of the data (total_count)\n    // while the producer/consumer will be broken into chunks\n    // this function is defined in 'multi_kernel.hpp'\n    auto events = SubmitMultiKernelWorkers<T,\n                                           ProducePipe,\n                                           ConsumePipe>(q, total_count);\n\n    auto start = high_resolution_clock::now();\n\n    do {\n      // if we still have kernels to launch, launch them in here\n      if (in_chunk < chunks) {\n        // launch the producer/consumer pair for the next chunk of data\n        size_t chunk_offset = in_chunk*chunk_count;\n\n        // these functions are defined in 'multi_kernel.hpp'\n        event p_e = SubmitProducer<T, ProducePipe>(q, in + chunk_offset,\n                                                   chunk_count);\n        event c_e = SubmitConsumer<T, ConsumePipe>(q, out + chunk_offset,\n                                                   chunk_count);\n\n        // push the kernel event into the queue\n        event_q.push(std::make_pair(p_e, c_e));\n\n        // if this is the first chunk, track the time\n        if (in_chunk == 0) first_data_in = high_resolution_clock::now();\n        in_chunk++;\n      }\n\n      // wait on the oldest kernel to finish if any of these conditions are met:\n      //    1) there are a certain number kernels in flight\n      //    2) all of the kernels have been launched\n      //\n      // NOTE: 'inflight_kernels' is now the number of inflight\n      // producer/consumer kernel pairs\n      if ((event_q.size() >= inflight_kernels) || (in_chunk >= chunks)) {\n        // grab the oldest kernel event we are waiting on\n        auto event_pair = event_q.front();\n        event_q.pop();\n\n        // wait on the producer/consumer kernel pair to finish\n        event_pair.first.wait();    // producer\n        event_pair.second.wait();   // consumer\n\n        // track the time if this is the first producer/consumer pair\n        if (out_chunk == 0) first_data_out = high_resolution_clock::now();\n\n        // at this point the first 'out_chunk' chunks are ready to be\n        // processed on the host\n        out_chunk++;\n      }\n    } while(out_chunk < chunks);\n\n    // wait for the worker kernels to finish, which should be done quickly\n    // since all producer/consumer pairs are done\n    for (auto& e : events) {\n      e.wait();\n    }\n\n    auto end = high_resolution_clock::now();\n\n    // compute latency and processing time\n    duration<double, std::milli> latency = first_data_out - first_data_in;\n    duration<double, std::milli> process_time = end - start;\n    latency_ms[i] = latency.count();\n    process_time_ms[i] = process_time.count();\n  }\n\n  // compute and print timing information\n  PrintPerformanceInfo<T>(\"Multi-kernel\",\n                          total_count, latency_ms, process_time_ms);\n}\n\n// a helper function to compute and print the performance info\ntemplate<typename T>\nvoid PrintPerformanceInfo(std::string print_prefix, size_t count,\n                          std::vector<double>& latency_ms,\n                          std::vector<double>& process_time_ms) {\n  // compute the input size in MB\n  double input_size_megabytes = (sizeof(T) * count) * 1e-6;\n\n  // compute the average latency and processing time\n  double iterations = latency_ms.size() - 1;\n  double avg_latency_ms = std::accumulate(latency_ms.begin() + 1,\n                                          latency_ms.end(),\n                                          0.0) / iterations;\n  double avg_processing_time_ms = std::accumulate(process_time_ms.begin() + 1,\n                                                  process_time_ms.end(),\n                                                  0.0) / iterations;\n\n  // compute the throughput\n  double avg_tp_mb_s = input_size_megabytes / (avg_processing_time_ms * 1e-3);\n\n  // print info\n  std::cout << std::fixed << std::setprecision(4);\n  std::cout << print_prefix\n            << \" average latency:           \" << avg_latency_ms << \" ms\\n\";\n  std::cout << print_prefix\n            << \" average throughput:        \" << avg_tp_mb_s  << \" MB/s\\n\";\n}\n"
    },
    {
        "label": "pipe_array.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#include <vector>\n#include \"pipe_utils.hpp\"\n#include \"unrolled_loop.hpp\"\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\nconstexpr size_t kNumRows = 2;\nconstexpr size_t kNumCols = 2;\nconstexpr size_t kNumberOfConsumers = kNumRows * kNumCols;\nconstexpr size_t kDepth = 2;\n\nusing ProducerToConsumerPipeMatrix =\n    fpga_tools::PipeArray<          // Defined in \"pipe_utils.hpp\".\n      class ProducerConsumerPipe,   // An identifier for the pipe.\n      uint64_t,                     // The type of data in the pipe.\n      kDepth,                       // The capacity of each pipe.\n      kNumRows,                     // array dimension.\n      kNumCols                      // array dimension.\n    >;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass ProducerTutorial;\ntemplate <size_t consumer_id> class ConsumerTutorial;\n\nvoid Producer(queue &q, buffer<uint64_t, 1> &input_buffer) {\n  std::cout << \"Enqueuing producer...\\n\";\n\n  auto e = q.submit([&](handler &h) {\n    accessor in(input_buffer, h, read_only);\n    auto num_elements = input_buffer.size();\n    auto num_passes = num_elements / kNumberOfConsumers;\n\n    // The producer kernel writes to every pipe in the 2D pipe array\n    h.single_task<ProducerTutorial>([=]() {\n      size_t input_idx = 0;\n      for (size_t pass = 0; pass < num_passes; pass++) {\n        // Template-based unroll (outer \"i\" loop)\n        fpga_tools::UnrolledLoop<kNumRows>([&input_idx, in](auto i) {\n          // Template-based unroll (inner \"j\" loop)\n          fpga_tools::UnrolledLoop<kNumCols>([&input_idx, &i, in](auto j) {\n            // Write a value to the <i,j> pipe of the pipe array\n            ProducerToConsumerPipeMatrix::PipeAt<i, j>::write(in[input_idx++]);\n          });\n        });\n      }\n    });\n  });\n}\n\n// Do some work on the data (any function could be substituted)\nuint64_t ConsumerWork(uint64_t i) { return i * i; }\n\ntemplate <size_t consumer_id>\nvoid Consumer(queue &q, buffer<uint64_t, 1> &out_buf) {\n  std::cout << \"Enqueuing consumer \" << consumer_id << \"...\\n\";\n\n  auto e = q.submit([&](handler &h) {\n    accessor out(out_buf, h, write_only, no_init);\n    auto num_elements = out_buf.size();\n\n    // The consumer kernel reads from a single pipe, determined by consumer_id\n    h.single_task<ConsumerTutorial<consumer_id>>([=]() {\n      constexpr size_t x = consumer_id / kNumCols;\n      constexpr size_t y = consumer_id % kNumCols;\n      for (size_t i = 0; i < num_elements; ++i) {\n        auto input = ProducerToConsumerPipeMatrix::PipeAt<x, y>::read();\n        out[i] = ConsumerWork(input);\n      }\n    });\n  });\n}\n\nint main(int argc, char *argv[]) {\n  uint64_t array_size = 1;\n  array_size <<= 10;\n\n  // Parse optional data size argument\n  if (argc > 1) {\n    std::string option(argv[1]);\n    if (option == \"-h\" || option == \"--help\") {\n      std::cout << \"Usage: \\n<executable> <data size>\\n\\nFAILED\\n\";\n      return 1;\n    } else {\n      array_size = std::stoi(option);\n    }\n  }\n\n  std::cout << \"Input Array Size:  \" << array_size << \"\\n\";\n\n  // Check input validity\n  if (array_size % kNumberOfConsumers != 0) {\n    std::cout << \"Array size must be a multiple of the number of consumers! \"\n                 \"Exiting...\\n\";\n    return 0;\n  }\n\n  // Set up producer input vector, and kNumberOfConsumers output vectors\n  uint64_t items_per_consumer = array_size / kNumberOfConsumers;\n  std::vector<uint64_t> producer_input(array_size, -1);\n  std::array<std::vector<uint64_t>, kNumberOfConsumers> consumer_output;\n\n  for (auto &output : consumer_output)\n    output.resize(items_per_consumer, -1);\n\n  // Initialize producer input\n  for (size_t i = 0; i < array_size; i++)\n    producer_input[i] = i;\n\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Enqueue producer\n    buffer<uint64_t,1> producer_buffer(producer_input);\n    Producer(q, producer_buffer);\n\n    std::vector<buffer<uint64_t,1>> consumer_buffers;\n\n    // Use template-based unroll to enqueue multiple consumers\n    fpga_tools::UnrolledLoop<kNumberOfConsumers>([&](auto consumer_id) {\n      consumer_buffers.emplace_back(consumer_output[consumer_id].data(),\n                                    items_per_consumer);\n      Consumer<consumer_id>(q, consumer_buffers.back());\n    });\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  // Verify result\n  for (size_t i = 0; i < items_per_consumer; ++i) {\n    for (size_t consumer = 0; consumer < kNumberOfConsumers; ++consumer) {\n      auto fpga_result = consumer_output[consumer][i];\n      auto expected_result = ConsumerWork(kNumberOfConsumers * i + consumer);\n      if (fpga_result != expected_result) {\n        std::cout << \"FAILED: The results are incorrect\\n\";\n        std::cout << \"On Input: \" << kNumberOfConsumers * i + consumer\n                  << \" Expected: \" << expected_result << \" Got: \" << fpga_result\n                  << \"\\n\";\n        return 1;\n      }\n    }\n  }\n\n  std::cout << \"PASSED: The results are correct\\n\";\n  return 0;\n}\n"
    },
    {
        "label": "loop_carried_dependency.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <string>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\nusing namespace std;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass UnOptKernel;\nclass OptKernel;\n\nconstexpr size_t kMaxN = 150;\n\n\nevent Unoptimized(queue &q, const vector<double> &vec_a,\n                  const vector<double> &vec_b, double &result, size_t N) {\n  buffer b_a(vec_a);\n  buffer b_b(vec_b);\n  buffer b_result(&result, range(1));\n\n  auto e = q.submit([&](handler &h) {\n    accessor a(b_a, h, read_only);\n    accessor b(b_b, h, read_only);\n    accessor result(b_result, h, write_only, no_init);\n\n    h.single_task<UnOptKernel>([=]() {\n      double sum = 0;\n      double local_a[kMaxN * kMaxN], local_b[kMaxN];\n\n      // Copy to local memory for speed\n      for (size_t i = 0; i < N * N; i++) local_a[i] = a[i];\n      for (size_t i = 0; i < N; i++) local_b[i] = b[i];\n\n      for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n          sum += local_a[i * N + j];\n        }\n        sum += local_b[i];\n      }\n      result[0] = sum;\n    });\n  });\n  return e;\n}\n\nevent Optimized(queue &q, const vector<double> &vec_a,\n                const vector<double> &vec_b, double &result, size_t N) {\n  buffer b_a(vec_a);\n  buffer b_b(vec_b);\n  buffer b_result(&result, range(1));\n\n  auto e = q.submit([&](handler &h) {\n    accessor a(b_a, h, read_only);\n    accessor b(b_b, h, read_only);\n    accessor result(b_result, h, write_only, no_init);\n\n    h.single_task<OptKernel>([=]() [[intel::kernel_args_restrict]] {\n      double sum = 0;\n      double local_a[kMaxN * kMaxN], local_b[kMaxN];\n\n      // Copy to local memory\n      for (size_t i = 0; i < N * N; i++) local_a[i] = a[i];\n      for (size_t i = 0; i < N; i++) local_b[i] = b[i];\n\n      for (size_t i = 0; i < N; i++) {\n        // Step 1: Definition\n        double sum_2 = 0;\n\n        // Step 2: Accumulation of array A values for one outer loop iteration\n        for (size_t j = 0; j < N; j++) {\n          sum_2 += local_a[i * N + j];\n        }\n\n        // Step 3: Addition of array B value for an outer loop iteration\n        sum += sum_2;\n        sum += local_b[i];\n      }\n\n      result[0] = sum;\n    });\n  });\n  return e;\n}\n\nvoid PrintTime(const event &e, queue &q, const char *kind) {\n  double start_k = e.get_profiling_info<info::event_profiling::command_start>();\n  double end_k = e.get_profiling_info<info::event_profiling::command_end>();\n\n  cout << \"Run: \" << kind << \":\\n\";\n#if defined(FPGA_SIMULATOR)\n  double kernel_time = (double)(end_k - start_k) * 1e-9;\n  cout << \"kernel time : \" << kernel_time << \" s\\n\";\n#else\n  double kernel_time = (double)(end_k - start_k) * 1e-6;\n  cout << \"kernel time : \" << kernel_time << \" ms\\n\";\n#endif\n}\n\nint main(int argc, char *argv[]) {\n  size_t n = kMaxN;\n\n  if (argc > 1) {\n    string option(argv[1]);\n    if (option == \"-h\" || option == \"--help\") {\n      cout << \"Usage: <executable> <data size>\\n\\nFAILED\\n\";\n      return 1;\n    } else {\n      n = stoi(option);\n    }\n  }\n  // Cap the value of n.\n  n = std::max(std::min((size_t)n, (size_t)kMaxN), (size_t)100);\n  cout << \"Number of elements: \" << n << '\\n';\n\n  vector<double> vec_a(n * n);\n  vector<double> vec_b(n);\n\n  double answer = 0;\n\n  // initialize data and compute golden result\n  for (size_t i = 0; i < n; i++) {\n    for (size_t j = 0; j < n; j++) {\n      vec_a[i * n + j] = i + j;\n      answer += i + j;\n    }\n    vec_b[i] = i;\n    answer += i;\n  }\n\n  // Initialize queue with device selector and enabling profiling\n  // Create queue, get platform and device\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n#ifndef FPGA_HARDWARE\n  cout << \"\\nEmulator and simulator outputs do not demonstrate true \"\n          \"hardware performance. The design may need to run on actual \"\n          \"hardware to observe the performance benefit of the optimization \"\n          \"exemplified in this tutorial.\\n\\n\";\n#endif\n\n  double unopt_sum = -1, opt_sum = -1;\n\n  try {\n    // Create a profiling queue\n    queue q(selector, fpga_tools::exception_handler,\n            property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // compute result on device\n    PrintTime(Unoptimized(q, vec_a, vec_b, unopt_sum, n), q, \"Unoptimized\");\n    PrintTime(Optimized(q, vec_a, vec_b, opt_sum, n), q, \"Optimized\");\n\n    // q's destructor invokes q's exception handler on any device exceptions.\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  // Check the results\n  bool failed = false;\n  if (unopt_sum != answer) {\n    cout << \"Unoptimized: expected: \" << answer << \", result: \" << unopt_sum\n         << '\\n';\n    failed = true;\n  }\n  if (opt_sum != answer) {\n    cout << \"Optimized: expected: \" << answer << \", result: \" << opt_sum\n         << '\\n';\n    failed = true;\n  }\n\n  if (failed) {\n    cout << \"FAILED\\n\";\n    return 1;\n  }\n  cout << \"PASSED\\n\";\n  return 0;\n}\n"
    },
    {
        "label": "explicit_data_movement.cpp",
        "data": "#include <assert.h>\n\n#include <algorithm>\n#include <chrono>\n#include <iomanip>\n#include <numeric>\n#include <random>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n#include <type_traits>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass ImplicitKernel;\nclass ExplicitKernel;\n\n//\n// This version of the kernel demonstrates implicit data movement\n// through SYCL buffers and accessors.\n//\ntemplate <typename T>\ndouble SubmitImplicitKernel(sycl::queue &q, std::vector<T> &in,\n                            std::vector<T> &out, size_t size) {\n  // start the timer\n  auto start = std::chrono::high_resolution_clock::now();\n\n  {\n    // set up the input and output buffers\n    sycl::buffer in_buf(in);\n    sycl::buffer out_buf(out);\n\n    // launch the computation kernel\n    auto kernel_event = q.submit([&](sycl::handler &h) {\n      // When targeting an FPGA family/part, the compiler infers memory\n      // interfaces based on the unique buffer_locations specified on kernel\n      // arguments whereas when a BSP is specified to the compiler, the\n      // buffer_location is used to select from the available memory interfaces\n      // supported by the BSP. Here, we specify 0 on the accessor arguments\n      // whereas the pointer arguments in ExplicitKernel are specified to be in\n      // buffer_location 1, when targeting an FPGA family/part.\n      sycl::ext::oneapi::accessor_property_list location_of_buffer{\n          sycl::ext::intel::buffer_location<0>};\n      sycl::accessor in_a(in_buf, h, sycl::read_only, location_of_buffer);\n\n      sycl::ext::oneapi::accessor_property_list location_of_buffer_no_init{\n          sycl::no_init, sycl::ext::intel::buffer_location<0>};\n      sycl::accessor out_a(out_buf, h, sycl::write_only,\n                           location_of_buffer_no_init);\n\n      h.single_task<ImplicitKernel>([=]() [[intel::kernel_args_restrict]] {\n        for (size_t i = 0; i < size; i++) {\n          out_a[i] = in_a[i] * i;\n        }\n      });\n    });\n  }\n\n  // We use the scope above to synchronize the FPGA kernels.\n  // Exiting the scope will cause the buffer destructors to be called\n  // which will wait until the kernel finishes and copy the data back to the\n  // host (if the buffer was written to).\n  // Therefore, at this point in the code, we know the kernels have finished\n  // and the data has been transferred back to the host.\n\n  // stop the timer\n  auto end = std::chrono::high_resolution_clock::now();\n  std::chrono::duration<double, std::milli> diff = end - start;\n\n  return diff.count();\n}\n\n//\n// This version of the kernel demonstrates explicit data movement\n// through explicit USM.\n//\ntemplate <typename T>\ndouble SubmitExplicitKernel(sycl::queue &q, std::vector<T> &in,\n                            std::vector<T> &out, size_t size) {\n#if defined(IS_BSP)\n  // USM device allocations are more commonly supported by FPGA boards than\n  // other types of USM allocations like host and shared allocations.\n  // Allocate the device memory\n  T *in_ptr = sycl::malloc_device<T>(\n      size, q,\n      sycl::ext::intel::experimental::property::usm::buffer_location(0));\n  T *out_ptr = sycl::malloc_device<T>(\n      size, q,\n      sycl::ext::intel::experimental::property::usm::buffer_location(0));\n#else\n  // When targeting an FPGA family/part, use USM host or shared allocations\n  // since USM device allocations are not supported. Here we use USM shared\n  // allocation.\n  T *in_ptr = sycl::malloc_host<T>(\n      size, q,\n      sycl::ext::intel::experimental::property::usm::buffer_location(1));\n  T *out_ptr = sycl::malloc_host<T>(\n      size, q,\n      sycl::ext::intel::experimental::property::usm::buffer_location(1));\n#endif\n\n  // ensure we successfully allocated the device memory\n  if (in_ptr == nullptr) {\n    std::cerr << \"ERROR: failed to allocate space for 'in_ptr'\\n\";\n    return 0;\n  }\n  if (out_ptr == nullptr) {\n    std::cerr << \"ERROR: failed to allocate space for 'out_ptr'\\n\";\n    return 0;\n  }\n\n  // start the timer\n  auto start = std::chrono::high_resolution_clock::now();\n\n  // copy host input data to the device's memory\n  auto copy_host_to_device_event =\n      q.memcpy(in_ptr, in.data(), size * sizeof(T));\n\n#if !defined(IS_BSP)\n  // When targeting a FPGA family/part, the compiler infers as many global\n  // memory interfaces for the design as unique buffer locations. The\n  // ImplicitKernel specifies buffer_location 0 on the accessor argument\n  // allowing the compiler to infer an interface for buffer_location 0.\n  // Here, we use annotated_arg to specify buffer_location on the USM pointer\n  // kernel argument to allow the compiler to infer an interface for\n  // buffer_location 1\n  sycl::ext::oneapi::experimental::annotated_arg in_ptr_d(\n      in_ptr, sycl::ext::oneapi::experimental::properties{\n                  sycl::ext::intel::experimental::buffer_location<1>});\n  sycl::ext::oneapi::experimental::annotated_arg out_ptr_d(\n      out_ptr, sycl::ext::oneapi::experimental::properties{\n                   sycl::ext::intel::experimental::buffer_location<1>});\n#endif\n\n  // launch the computation kernel\n  auto kernel_event = q.submit([&](sycl::handler &h) {\n    // this kernel must wait until the data is copied from the host's to\n    // the device's memory\n    h.depends_on(copy_host_to_device_event);\n\n    h.single_task<ExplicitKernel>([=]() [[intel::kernel_args_restrict]] {\n#if defined(IS_BSP)\n      // Explicitly create device pointers to inform the compiler that these\n      // pointers point to device memory\n      sycl::ext::intel::device_ptr<T> in_ptr_d(in_ptr);\n      sycl::ext::intel::device_ptr<T> out_ptr_d(out_ptr);\n#endif\n\n      for (size_t i = 0; i < size; i++) {\n        out_ptr_d[i] = in_ptr_d[i] * i;\n      }\n    });\n  });\n\n  // copy output data back from device to host\n  auto copy_device_to_host_event = q.submit([&](sycl::handler &h) {\n    // we cannot copy the output data from the device's to the host's memory\n    // until the computation kernel has finished\n    h.depends_on(kernel_event);\n    h.memcpy(out.data(), out_ptr, size * sizeof(T));\n  });\n\n  // wait for copy back to finish\n  copy_device_to_host_event.wait();\n\n  // stop the timer\n  auto end = std::chrono::high_resolution_clock::now();\n  std::chrono::duration<double, std::milli> diff = end - start;\n\n  // free the device memory\n  // note that these are calls to sycl::free()\n  free(in_ptr, q);\n  free(out_ptr, q);\n\n  return diff.count();\n}\n\n//\n// main driver program\n//\nint main(int argc, char *argv[]) {\n  // The data type for our design. Assert that it is arithmetic.\n  // Templating allows us to easily change the data type of the entire design.\n  using Type = int;\n  static_assert(std::is_arithmetic<Type>::value);\n\n  // the default arguments\n#if defined(FPGA_EMULATOR)\n  size_t size = 10000;\n  size_t iters = 1;\n#elif defined(FPGA_SIMULATOR)\n  size_t size = 100;\n  size_t iters = 1;\n#else\n  size_t size = 100000000;\n  size_t iters = 5;\n#endif\n\n  // Allow the size to be changed by a command line argument\n  if (argc > 1) {\n    size = atoi(argv[1]);\n  }\n\n  // check the size\n  if (size <= 0) {\n    std::cerr << \"ERROR: size must be greater than 0\\n\";\n    return 1;\n  }\n\n  try {\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // queue properties to enable profiling\n    auto prop_list =\n        sycl::property_list{sycl::property::queue::enable_profiling()};\n\n    // create the device queue\n    sycl::queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    // make sure the device supports USM device allocations\n    auto device = q.get_device();\n    if (!device.get_info<sycl::info::device::usm_device_allocations>()) {\n      std::cerr << \"ERROR: The selected device does not support USM device\"\n                << \" allocations\\n\";\n      return 1;\n    }\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // input and output data\n    std::vector<Type> in(size);\n    std::vector<Type> out_gold(size), out_implicit(size), out_explicit(size);\n\n    // generate some random input data\n    std::generate(in.begin(), in.end(), [=] { return Type(rand() % 100); });\n\n    // compute gold output data\n    for (size_t i = 0; i < size; i++) {\n      out_gold[i] = in[i] * i;\n    }\n\n    // run the ImplicitKernel\n    std::cout << \"Running the ImplicitKernel with size=\" << size << \"\\n\";\n    std::vector<double> implicit_kernel_latency(iters);\n    for (size_t i = 0; i < iters; i++) {\n      implicit_kernel_latency[i] =\n          SubmitImplicitKernel<Type>(q, in, out_implicit, size);\n    }\n\n    // run the ExplicitKernel\n    std::cout << \"Running the ExplicitKernel with size=\" << size << \"\\n\";\n    std::vector<double> explicit_kernel_latency(iters);\n    for (size_t i = 0; i < iters; i++) {\n      explicit_kernel_latency[i] =\n          SubmitExplicitKernel<Type>(q, in, out_explicit, size);\n    }\n\n    // validate the outputs\n    bool passed = true;\n\n    // validate ImplicitKernel output\n    for (size_t i = 0; i < size; i++) {\n      if (out_gold[i] != out_implicit[i]) {\n        std::cout << \"FAILED: mismatch at entry \" << i\n                  << \" of 'ImplicitKernel' output \"\n                  << \"(\" << out_gold[i] << \",\" << out_implicit[i] << \")\"\n                  << \"\\n\";\n        passed = false;\n      }\n    }\n    // validate ExplicitKernel kernel\n    for (size_t i = 0; i < size; i++) {\n      if (out_gold[i] != out_explicit[i]) {\n        std::cout << \"FAILED: mismatch at entry \" << i\n                  << \" of 'ExplicitKernel' kernel output \"\n                  << \"(\" << out_gold[i] << \",\" << out_explicit[i] << \")\"\n                  << \"\\n\";\n        passed = false;\n      }\n    }\n\n    if (passed) {\n      // The emulator does not accurately represent real hardware performance.\n      // Therefore, we don't show performance results when running in emulation.\n#if !defined(FPGA_EMULATOR) && !defined(FPGA_SIMULATOR)\n      double implicit_avg_lat =\n          std::accumulate(implicit_kernel_latency.begin() + 1,\n                          implicit_kernel_latency.end(), 0.0) /\n          (double)(iters - 1);\n      double explicit_avg_lat =\n          std::accumulate(explicit_kernel_latency.begin() + 1,\n                          explicit_kernel_latency.end(), 0.0) /\n          (double)(iters - 1);\n\n      std::cout << \"Average latency for the ImplicitKernel: \"\n                << implicit_avg_lat << \" ms\\n\";\n      std::cout << \"Average latency for the ExplicitKernel: \"\n                << explicit_avg_lat << \" ms\\n\";\n#endif\n\n      std::cout << \"PASSED\\n\";\n      return 0;\n    } else {\n      std::cout << \"FAILED\\n\";\n      return 1;\n    }\n\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return 0;\n}\n"
    },
    {
        "label": "zero_copy_data_transfer.cpp",
        "data": "#include <assert.h>\n#include <algorithm>\n#include <chrono>\n#include <iomanip>\n#include <numeric>\n#include <random>\n#include <type_traits>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\n#include \"buffer_kernel.hpp\"\n#include \"zero_copy_kernel.hpp\"\n\nusing namespace sycl;\n\n// the data type - assert that it is arithmetic\n// this allows the design to easily switch between types by changing\n// the line below\nusing Type = int;\nstatic_assert(std::is_arithmetic<Type>::value);\n\nint main(int argc, char* argv[]) {\n  // parse command line arguments\n#if defined(FPGA_EMULATOR)\n  size_t size = 10000;\n  size_t iterations = 1;\n#elif FPGA_SIMULATOR\n  size_t size = 700;\n  size_t iterations = 1;\n#else\n  size_t size = 100000000;\n  size_t iterations = 5;\n#endif\n\n  // Allow the size to be changed by a command line argument\n  if (argc > 1) {\n    size = atoi(argv[1]);\n  }\n\n  // check the size\n  if (size <= 0) {\n    std::cerr << \"ERROR: size must be greater than 0\\n\";\n    return 1;\n  }\n\n  try {\n    // device selector\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    queue q(selector, fpga_tools::exception_handler);\n\n    // make sure the device supports USM host allocations\n    auto device = q.get_device();\n    if (!device.get_info<info::device::usm_host_allocations>()) {\n      std::cerr << \"ERROR: The selected device does not support USM host\"\n                << \" allocations\\n\";\n      return 1;\n    }\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // the golden output\n    std::vector<Type> out_gold(size);\n\n    // input and output data for the buffer version\n    std::vector<Type> in_buffer(size), out_buffer(size);\n\n    // input and output data for the zero-copy version\n    // malloc_host allocates memory specifically in the host's address space\n#if defined(IS_BSP)\n    Type* in_zero_copy = malloc_host<Type>(size, q.get_context());\n    Type* out_zero_copy = malloc_host<Type>(size, q.get_context());\n#else\n    // The USM pointers passed into the kernel must be allocated with the same\n    // buffer_location as the one specified on the kernel argument with the\n    // annotated_arg class.\n    Type *in_zero_copy = sycl::malloc_host<Type>(\n        size, q,\n        sycl::ext::intel::experimental::property::usm::buffer_location(0));\n    Type *out_zero_copy = sycl::malloc_host<Type>(\n        size, q,\n        sycl::ext::intel::experimental::property::usm::buffer_location(0));\n#endif\n    \n    // ensure that we could allocate space for both the input and output\n    if (in_zero_copy == NULL) {\n      std::cerr << \"ERROR: failed to allocate space for 'in_zero_copy'\\n\";\n      return 1;\n    }\n    if (out_zero_copy == NULL) {\n      std::cerr << \"ERROR: failed to allocate space for 'out_zero_copy'\\n\";\n      return 1;\n    }\n\n    // generate some random input data and compute the golden result\n    for (int i = 0; i < size; i++) {\n      // generate a random value\n      Type n = Type(rand() % 100);\n\n      // populate the inputs\n      in_buffer[i] = in_zero_copy[i] = n;\n\n      // compute the golden result\n      out_gold[i] = n * i;\n    }\n\n    // run the buffer version kernel\n    std::cout << \"Running the buffer kernel version with size=\" << size << \"\\n\";\n    std::vector<double> buffer_kernel_latency(iterations);\n    for (size_t i = 0; i < iterations; i++) {\n      buffer_kernel_latency[i] = SubmitBufferKernel<Type>(q, in_buffer,\n                                                          out_buffer, size);\n    }\n\n    // run the the zero-copy version kernel\n    std::cout << \"Running the zero-copy kernel version with size=\" << size\n              << \"\\n\";\n    std::vector<double> zero_copy_latency(iterations);\n    for (size_t i = 0; i < iterations; i++) {\n      zero_copy_latency[i] = SubmitZeroCopyKernel<Type>(q, in_zero_copy,\n                                                        out_zero_copy, size);\n    }\n\n    // validate the outputs\n    // validate the buffer version\n    for (int i = 0; i < size; i++) {\n      if (out_gold[i] != out_buffer[i]) {\n        std::cerr << \"ERROR: mismatch at entry \" << i\n                  << \" of 'Buffer' kernel output \"\n                  << \"(\" << out_gold[i] << \",\" << out_buffer[i] << \")\"\n                  << \"\\n\";\n        return 1;\n      }\n    }\n    // validate the the zero-copy version\n    for (int i = 0; i < size; i++) {\n      if (out_gold[i] != out_zero_copy[i]) {\n        std::cerr << \"ERROR: mismatch at entry \" << i\n                  << \" of 'ZeroCopy' kernel output \"\n                  << \"(\" << out_gold[i] << \",\" << out_zero_copy[i] << \")\"\n                  << \"\\n\";\n        return 1;\n      }\n    }\n\n    // The FPGA emulator or simulator do not accurately represent the hardware performance\n    // so we don't print performance results when running with the emulator or simulator\n#ifdef FPGA_EMULATOR\n#elif FPGA_SIMULATOR\n#else\n    // Compute the average latency across all iterations.\n    // We use the first iteration as a 'warmup' for the FPGA,\n    // so we ignore its results.\n    double buffer_avg_lat = std::accumulate(buffer_kernel_latency.begin() + 1,\n                                            buffer_kernel_latency.end(), 0.0) /\n                                        (iterations - 1);\n    double zero_copy_avg_lat =\n        std::accumulate(zero_copy_latency.begin() + 1,\n                        zero_copy_latency.end(), 0.0) /\n                    (iterations - 1);\n\n    std::cout << \"Average latency for the buffer kernel: \" << buffer_avg_lat\n              << \" ms\\n\";\n    std::cout << \"Average latency for the zero-copy kernel: \"\n              << zero_copy_avg_lat << \" ms\\n\";\n#endif\n\n    // free the USM host allocations\n    // note that these are calls to sycl::free()\n    free(in_zero_copy, q);\n    free(out_zero_copy, q);\n\n  } catch (exception const& e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  std::cout << \"PASSED\\n\";\n\n  return 0;\n}\n"
    },
    {
        "label": "optimize_inner_loop.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <algorithm>\n#include <array>\n#include <iomanip>\n#include <iostream>\n#include <numeric>\n#include <random>\n#include <type_traits>\n\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// allow the maximum random number value to be controlled from the command line\n#ifndef RAND_RANGE_MAX\n#define RAND_RANGE_MAX 3\n#endif\n\n//// constants\nconstexpr int kNumKernels = 3;\nconstexpr int kRandRangeMax = RAND_RANGE_MAX;\nconstexpr double kProbSuccess = 1.0 / kRandRangeMax;\n\n// Forward declare the kernel names in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\n// Templating allows us to instantiate multiple versions of the kernel.\ntemplate <int version>\nclass Producer;\ntemplate <int version>\nclass Consumer;\n\n// Declare the pipe class name globally to reduce name mangling.\n// Templating allows us to instantiate multiple versions of pipes for each\n// version of the kernel.\ntemplate <int version>\nclass PipeClass;\n\n//\n// Submits the kernel, which is templated on the variables:\n//    version             - The version ID of the kernel\n//    in_element_upper_bound - The upperbound (inclusive) on the elements of the\n//                          'in' vector (a negative value implies no bound). In\n//                          other words: if in_element_upper_bound >= 0, then\n//                          in[i] <= in_element_upper_bound, for all elements\n//                          of 'in'\n//    spec_iters           - The number of speculated iterations to set for the\n//                          inner loop\n//\ntemplate <int version, int in_element_upper_bound, int spec_iters>\nvoid SubmitKernels(std::vector<int> &in, int &res, double &kernel_time_ms) {\n  // static asserts: these cause the compiler to fail if the conditions fail\n  static_assert(version >= 0, \"Invalid kernel version\");\n  static_assert(spec_iters >= 0, \"spec_iters must be positive\");\n\n  // the device selector\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  // the pipe\n  using Pipe = pipe<PipeClass<version>, bool>;\n\n  kernel_time_ms = 0.0;\n  int size = in.size();\n\n  try {\n    // create the device queue with profiling enabled\n    auto prop_list = property_list{property::queue::enable_profiling()};\n    queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // The input data buffer\n    buffer in_buf(in);\n\n    // The output data buffer\n    // Scalar inputs are passed to the kernel using the lambda capture,\n    // but a SYCL buffer must be used to return a scalar from the kernel.\n    buffer<int, 1> res_buf(&res, 1);\n\n    // submit the Producer kernel\n    event p_e = q.submit([&](handler &h) {\n      // the input buffer accessor\n      accessor in_a(in_buf, h, read_only);\n\n      h.single_task<Producer<version>>([=]() [[intel::kernel_args_restrict]] {\n        for (int i = 0; i < size; i++) {\n          // read the input value, which is in the range [0,InnerLoopBound]\n          int val = in_a[i];\n\n          // 'in_element_upper_bound' is a constant (a template variable).\n          // Therefore, the condition 'in_element_upper_bound < 0', and\n          // therefore the taken branch of this if-else statement, can be\n          // determined at compile time. This results in the branch that is NOT\n          // taken being optimized away. Both versions of the inner loop apply\n          // the speculated_iterations attribute, where the number of speculated\n          // iterations is determined by the template variable 'spec_iters'.\n          if (in_element_upper_bound < 0) {\n            // In this version of the inner loop, we do NOT provide an\n            // upperbound on the loop index variable 'j'. While it may be easy\n            // for you to read the code and reason that\n            // 'j<in_element_upper_bound' is always true by looking at the rest\n            // of the program, it is much more difficult for the compiler. As a\n            // result, the compiler will be conservative and assume this inner\n            // loop may have a large trip count and decide to make (or not make)\n            // optimizations accordingly.\n            [[intel::speculated_iterations(spec_iters)]] for (int j = 0;\n                                                              j < val; j++) {\n              Pipe::write(true);\n            }\n          } else {\n            // In this version of the inner loop, we provide an upper bound\n            // on the loop index variable 'j' by adding the\n            // 'j<in_element_upper_bound' loop exit condition. This provides the\n            // compiler with a constant upperbound on the trip count and allows\n            // it to make optimizations accordingly.\n            [[intel::speculated_iterations(\n                spec_iters)]] for (int j = 0;\n                                   j < val && j <= in_element_upper_bound;\n                                   j++) {\n              Pipe::write(true);\n            }\n          }\n        }\n\n        // tell the consumer that we are done producing data\n        Pipe::write(false);\n      });\n    });\n\n    // submit the Consumer kernel\n    event c_e = q.submit([&](handler &h) {\n      // the output buffer accessor\n      accessor res_a(res_buf, h, write_only, no_init);\n\n      h.single_task<Consumer<version>>([=]() [[intel::kernel_args_restrict]] {\n        // local register to accumulate into\n        int local_sum = 0;\n\n        // keep grabbing data from the Producer until it tells us to stop\n        while (Pipe::read()) {\n          local_sum++;\n        }\n\n        // copy back the result to global memory\n        res_a[0] = local_sum;\n      });\n    });\n\n    // get the kernel time in milliseconds\n    // this excludes memory transfer and queuing overhead\n    double startk =\n        p_e.template get_profiling_info<info::event_profiling::command_start>();\n    double endk =\n        c_e.template get_profiling_info<info::event_profiling::command_end>();\n    kernel_time_ms = (endk - startk) * 1e-6f;\n\n  } catch (exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n}\n\n//\n// main function\n//\nint main(int argc, char *argv[]) {\n\n  // set the input size based on whether we are in emulation or FPGA hardware\n#if defined(FPGA_EMULATOR) || defined(FPGA_SIMULATOR)\n  int size = 5000;\n#else\n  int size = 5000000;\n#endif\n\n  // Allow the size to be changed by a command line argument\n  if (argc > 1) {\n    size = atoi(argv[1]);\n  }\n\n  // check that the size makes sense\n  if (size <= 0) {\n    std::cerr << \"ERROR: 'size' must be strictly positive\\n\";\n    return 1;\n  }\n\n  // generate random input data and compute golden result\n  std::vector<int> in(size);\n  int golden_result = 0;\n\n  std::cout << \"generating \" << size << \" random numbers in the range \"\n            << \"[0,\" << kRandRangeMax << \"]\\n\";\n\n  // The random number generator (rng)\n  std::default_random_engine rng;\n\n  // A binomial distribution will generate random numbers in the range\n  // [0,kRandRangeMax], where the expected value is kRandRangeMax*kProbSuccess.\n  // We have set these constants such that the expected value is 1. This\n  // means that the number of inner loop iterations in the Producer kernel\n  // is in the range [0,kRandRangeMax], but is 1 on average. For more info see:\n  //    https://en.cppreference.com/w/cpp/numeric/random/binomial_distribution\n  std::binomial_distribution<int> bin_dist(kRandRangeMax, kProbSuccess);\n\n  // generate the random input data\n  std::generate(in.begin(), in.end(), [&] { return bin_dist(rng); });\n\n  // compute the golden result\n  golden_result = std::accumulate(in.begin(), in.end(), 0);\n\n  // the result variables from the kernels\n  std::array<int, kNumKernels> result;\n  std::array<double, kNumKernels> ktime;\n\n  // version 0\n  //\n  // For the inner loop, this version has the bounding of the inner loop\n  // disabled (-1 for in_element_upper_bound disables inner loop bounding)\n  // and sets 2 speculated iterations.\n  std::cout << \"Running kernel 0\\n\";\n  SubmitKernels<0, -1, 2>(in, result[0], ktime[0]);\n\n  // version 1\n  //\n  // For the inner loop, this version has the bounding of the inner loop\n  // disabled (-1 for in_element_upper_bound disables inner loop bounding)\n  // and sets 0 speculated iterations.\n  std::cout << \"Running kernel 1\\n\";\n  SubmitKernels<1, -1, 0>(in, result[1], ktime[1]);\n\n  // version 2\n  //\n  // For the inner loop, this version bounds the inner loop (the max value\n  // generated by our RNG above, kRandRangeMax) and has 0 speculated iterations.\n  std::cout << \"Running kernel 2\\n\";\n  SubmitKernels<2, kRandRangeMax, 0>(in, result[2], ktime[2]);\n\n  // validate the results\n  bool success = true;\n  for (int i = 0; i < kNumKernels; i++) {\n    if (result[i] != golden_result) {\n      std::cerr << \"ERROR: Kernel \" << i << \" result mismatch: \" << result[i]\n                << \" != \" << golden_result << \" (result != expected)\\n\";\n      success = false;\n    }\n  }\n\n  if (success) {\n    // the emulator does not accurately represent real hardware performance.\n    // Therefore, we don't show performance results when running in emulation.\n#if !defined(FPGA_EMULATOR) && !defined(FPGA_SIMULATOR)\n    double input_size_bytes = size * sizeof(int);\n\n    // only display two decimal points\n    std::cout << std::fixed << std::setprecision(2);\n\n    // compute and print the performance results\n    for (int i = 0; i < kNumKernels; i++) {\n      std::cout << \"Kernel \" << i\n                << \" throughput: \" << (input_size_bytes / ktime[i]) * 1e-3\n                << \" MB/s \\n\";\n    }\n#endif\n\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n"
    },
    {
        "label": "shannonization.cpp",
        "data": "#include <algorithm>\n#include <numeric>\n#include <string>\n#include <type_traits>\n#include <vector>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"IntersectionKernel.hpp\"\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n//\n// print the usage\n//\nvoid Usage() {\n  std::cout\n      << \"USAGE: ./intersection [--A=<size of list A>] [--B=<size of list B>]\"\n      << \"[--iters=<number of times to run the kernel>] [-h --help]\\n\";\n}\n\n//\n// helper to check if string 'str' starts with 'prefix'\n//\nbool StrStartsWith(std::string& str, std::string prefix) {\n  return str.find(prefix) == 0;\n}\n\n//\n// Helper to count instances of an element 'x' in a sorted vector 'v'.\n// Since the vector is sorted, this algorithm has O(logn) complexity,\n// rather than the naive O(n) complexity.\n//\nunsigned int CountSorted(std::vector<unsigned int>& v, int x) {\n  // find first occurrence of 'x' in 'v'\n  auto low = std::lower_bound(v.begin(), v.end(), x);\n\n  // check if element was present\n  if (low == v.end() || *low != x) {\n    return 0;\n  }\n\n  // find last occurrence of x in array\n  auto high = std::upper_bound(low, v.end(), x);\n\n  // return count\n  return high - low;\n}\n\n//\n// Submit the three kernels that make up the whole design\n//\ntemplate <int Version, int II>\nevent SubmitKernels(queue& q, std::vector<unsigned int>& a,\n                    std::vector<unsigned int>& b, int& n) {\n  // static asserts\n  static_assert(Version >= 0 && Version <= 3, \"Invalid kernel version\");\n  static_assert(II > 0, \"II target must be positive and non-zero\");\n\n  // the pipes for this Version of the design\n  using ProduceAPipe = pipe<ProduceAPipeClass<Version>, unsigned int>;\n  using ProduceBPipe = pipe<ProduceBPipeClass<Version>, unsigned int>;\n\n  // input sizes\n  const int a_size = a.size();\n  const int b_size = b.size();\n\n  // setup the input buffers\n  buffer a_buf(a);\n  buffer b_buf(b);\n\n  // setup the output buffer\n  buffer<int,1> n_buf(&n, 1);\n\n  // submit the kernel that produces table A\n  q.submit([&](handler& h) {\n    accessor a_accessor(a_buf, h, read_only);\n    h.single_task<ProducerA<Version>>([=]() [[intel::kernel_args_restrict]] {\n      for (int i = 0; i < a_size; i++) {\n        ProduceAPipe::write(a_accessor[i]);\n      }\n    });\n  });\n\n  // submit the kernel that produces table B\n  q.submit([&](handler& h) {\n    accessor b_accessor(b_buf, h, read_only);\n    h.single_task<ProducerB<Version>>([=]() [[intel::kernel_args_restrict]] {\n      for (int i = 0; i < b_size; i++) {\n        ProduceBPipe::write(b_accessor[i]);\n      }\n    });\n  });\n\n  // submit the kernel that performs the intersection\n  event e = q.submit([&](handler& h) {\n    // output accessor\n    accessor n_accessor(n_buf, h, write_only, no_init);\n\n    h.single_task<Worker<Version>>([=]() [[intel::kernel_args_restrict]] {\n      // The 'Version' template parameter will choose between the different\n      // versions of the kernel defined in IntersectionKernel.hpp.\n      // The operator() of the IntersectionKernel object will return the\n      // size of the intersection of A and B.\n      IntersectionKernel<Version, II, ProduceAPipe, ProduceBPipe> K;\n      n_accessor[0] = K(a_size, b_size);\n    });\n  });\n\n  return e;\n}\n\n//\n// This function performs the intersection by submitting the\n// different kernels. This method also validates the output\n// of the kernels and prints performance information\n//\ntemplate <int Version, int II>\nbool Intersection(queue& q, std::vector<unsigned int>& a,\n                  std::vector<unsigned int>& b, int golden_n) {\n  // For emulation, just do a single iteration.\n  // For hardware, perform multiple iterations for a more\n  // accurate throughput measurement\n#if defined(FPGA_EMULATOR) || defined(FPGA_SIMULATOR)\n  int iterations = 1;\n#else\n  int iterations = 5;\n#endif\n\n  std::cout << \"Running \" << iterations\n            << ((iterations == 1) ? \" iteration\" : \" iterations\")\n            << \" of kernel \" << Version\n            << \" with |A|=\" << a.size()\n            << \" and |B|=\" << b.size() << \"\\n\";\n\n  bool success = true;\n  std::vector<double> kernel_latency(iterations);\n\n  // perform multiple iterations of the kernel to get a more accurate\n  // throughput measurement\n  for (size_t i = 0; i < iterations && success; i++) {\n    // run kernel\n    int n = 0;\n    event e = SubmitKernels<Version,II>(q, a, b, n);\n\n    // check output\n    if (golden_n != n) {\n      success = false;\n      std::cerr << \"ERROR: Kernel version \" << Version << \" output is incorrect\"\n                << \" (Expected=\" << golden_n << \", Result=\" << n << \")\\n\";\n    }\n\n    // get profiling info\n    auto start = e.get_profiling_info<info::event_profiling::command_start>();\n    auto end = e.get_profiling_info<info::event_profiling::command_end>();\n    kernel_latency[i] = (end - start) / 1e9;\n  }\n\n  // If all the iterations were successful, print the throughput results.\n  // The FPGA emulator does not accurately represent the hardware performance\n  // so we don't print performance results when running with the emulator\n  if (success) {\n#if !defined(FPGA_EMULATOR) && !defined(FPGA_SIMULATOR)\n    // Compute the average throughput across all iterations.\n    // We use the first iteration as a 'warmup' for the FPGA,\n    // so we ignore its results.\n    double avg_kernel_latency =\n        std::accumulate(kernel_latency.begin() + 1, kernel_latency.end(), 0.0) /\n        (double)(iterations - 1);\n\n    double input_size_megabytes =\n        ((a.size() + b.size()) * sizeof(unsigned int)) / (1024.0 * 1024.0);\n\n    const double avg_throughput = input_size_megabytes / avg_kernel_latency;\n\n    std::cout << \"Kernel \" << Version\n              << \" average throughput: \" << avg_throughput << \" MB/s\\n\";\n#endif\n  }\n\n  return success;\n}\n\n\nint main(int argc, char** argv) {\n  // parse the command line arguments\n#if defined(FPGA_EMULATOR) || defined(FPGA_SIMULATOR)\n  unsigned int a_size = 128;\n  unsigned int b_size = 256;\n#else\n  unsigned int a_size = 16384;\n  unsigned int b_size = 32768;\n#endif\n  bool need_help = false;\n\n  for (int i = 1; i < argc; i++) {\n    std::string arg(argv[i]);\n\n    if (arg == \"--help\" || arg == \"-h\") {\n      need_help = true;\n    } else {\n      std::string str_after_equals = arg.substr(arg.find(\"=\") + 1);\n\n      if (StrStartsWith(arg, \"--A=\")) {\n        a_size = std::stoi(str_after_equals);\n      } else if (StrStartsWith(arg, \"--B=\")) {\n        b_size = std::stoi(str_after_equals);\n      } else {\n        std::cout << \"WARNING: ignoring unknown argument '\" << arg << \"'\\n\";\n      }\n    }\n  }\n\n  // ensure the arrays have more than 3 elements\n  if (a_size <= 3) {\n    std::cout << \"WARNING: array A must have more than 3 \"\n                  \"elements, increasing its size\\n\";\n    a_size = 4;\n  }\n  if (b_size <= 3) {\n    std::cout << \"WARNING: array A must have more than 3\"\n                  \"elements, increasing its size\\n\";\n    b_size = 4;\n  }\n\n  // print help if needed or asked\n  if (need_help) {\n    Usage();\n    return 0;\n  }\n\n  std::cout << \"Generating input data\\n\";\n\n  // seed the random number generator\n  srand(777);\n\n  // initialize input data\n  std::vector<unsigned int> a(a_size), b(b_size);\n  std::iota(a.begin(), a.end(), 0);\n  std::generate(b.begin(), b.end(), [=] { return rand() % a_size; });\n  std::sort(b.begin(), b.end());\n\n  std::cout << \"Computing golden result\\n\";\n\n  // compute the golden result\n  int golden_n = 0;\n  for (int i = 0; i < a_size; i++) {\n    golden_n += CountSorted(b, a[i]);\n  }\n\n  try {\n    // queue properties to enable profiling\n    auto props = property_list{property::queue::enable_profiling()};\n\n    // the device selector\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    queue q(selector, props);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    bool success = true;\n\n    // Instantiate multiple versions of the kernel\n    // The II achieved by the compiler can differ between FPGA architectures\n    //\n    // On Arria\u00ae 10, we are able to achieve an II of 1 for all versions of the\n    // kernel.\n    // Version 2 of the kernel can achieve the highest Fmax with\n    // an II of 1 (and therefore has the highest throughput).\n    // Since this tutorial compiles to a single FPGA image, this is not\n    // reflected in the final design (that is, version 1 bottlenecks the Fmax\n    // of the entire design, which contains versions 0, 1 and 2).\n    // However, the difference between versions 1 and 2\n    // can be seen in the \"Block Scheduled Fmax\" columns in the\n    // \"Loop Analysis\" tab of the HTML reports.\n    //\n    // On Stratix\u00ae 10 and Agilex\u00ae 7, the same discussion applies, but version 0\n    // can only achieve an II of 3 while versions 1 and 2 can only achieve\n    // an II of 2. On Stratix\u00ae 10 and Agilex\u00ae 7, we can achieve an II of 1 if we use\n    // non-blocking pipe reads in the IntersectionKernel, which is shown in\n    // version 3 of the kernel.\n    //\n#if defined(A10)\n    success &= Intersection<0,1>(q, a, b, golden_n);\n    success &= Intersection<1,1>(q, a, b, golden_n);\n    success &= Intersection<2,1>(q, a, b, golden_n);\n#elif defined(CycloneV)\n    success &= Intersection<0,3>(q, a, b, golden_n);\n    success &= Intersection<1,2>(q, a, b, golden_n);\n    success &= Intersection<2,2>(q, a, b, golden_n);\n#elif defined(S10)\n    success &= Intersection<0,3>(q, a, b, golden_n);\n    success &= Intersection<1,2>(q, a, b, golden_n);\n    success &= Intersection<2,2>(q, a, b, golden_n);\n#elif defined(Agilex7)\n    success &= Intersection<0,3>(q, a, b, golden_n);\n    success &= Intersection<1,2>(q, a, b, golden_n);\n    success &= Intersection<2,2>(q, a, b, golden_n);\n#elif defined(Agilex5)\n    success &= Intersection<0,3>(q, a, b, golden_n);\n    success &= Intersection<1,2>(q, a, b, golden_n);\n    success &= Intersection<2,2>(q, a, b, golden_n);\n#else\n    success &= Intersection<0,3>(q, a, b, golden_n);\n    success &= Intersection<1,3>(q, a, b, golden_n);\n    success &= Intersection<2,3>(q, a, b, golden_n);\n#endif\n\n    if (success) {\n      std::cout << \"PASSED\\n\";\n    } else {\n      std::cout << \"FAILED\\n\";\n    }\n\n  } catch (exception const& e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return 0;\n}\n"
    },
    {
        "label": "main.cpp",
        "data": "#include <iostream>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n#include \"restartable_counter_kernel.hpp\"\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass CounterID;\n\nconstexpr int kIterations = 256;\n\n// Read integers from `PipeType` and check that they start at some expected\n// value and increment by one each time. Optionally, flush data from `PipeType`\n// until a `start_of_packet` is seen.\ntemplate <typename PipeType>\nbool CheckIncrements(sycl::queue q, int count_start, int iterations,\n                     bool should_flush = true) {\n  bool passed = true;\n  int expected_count = count_start;\n\n  if (should_flush) {\n    std::cout << \"Flush pipe until 'start of packet' is seen.\" << std::endl;\n  } else {\n    std::cout << \"Start counting from \" << expected_count << std::endl;\n  }\n\n  int flushed_count = 0;\n  for (int itr = 0; itr < iterations; itr++) {\n    restartable_counter::OutputBeat beat = PipeType::read(q);\n\n    // Flush the pipe in case we are starting fresh.\n    if (should_flush && itr == 0) {\n      while (beat.sop != true) {\n        beat = PipeType::read(q);\n        flushed_count++;\n      }\n      std::cout << \"\\tFlushed \" << flushed_count << \" beats.\" << std::endl;\n      std::cout << \"Start counting from \" << expected_count << std::endl;\n    }\n\n    int calculated_count = beat.data;\n    if (calculated_count != expected_count) {\n      std::cout << \"\\nitr=\" << itr << \": result \" << calculated_count\n                << \", expected (\" << expected_count << \")\";\n      passed = false;\n    }\n    expected_count++;\n  }\n\n  return passed;\n}\n\nint main() {\n  bool passed = false;\n\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n    {\n      int count_start = 7;\n      std::cout << \"\\nStart kernel RestartableCounter at \" << count_start\n                << \". \" << std::endl;\n\n      // Capture the event so that we can stop the kernel later on\n      sycl::event e = q.single_task<CounterID>(\n          restartable_counter::RestartableCounter{count_start});\n\n      passed = CheckIncrements<restartable_counter::OutputPipe>(q, count_start,\n                                                                kIterations);\n\n      int new_start = count_start + kIterations;\n      // continue reading more results\n      passed &= CheckIncrements<restartable_counter::OutputPipe>(\n          q, new_start, kIterations, false);\n\n      std::cout << \"Stop kernel RestartableCounter\" << std::endl;\n      // Write a `true` into `StopPipe` to instruct the kernel to break out of\n      // its main loop, then wait for the kernel to complete.\n      restartable_counter::StopPipe::write(q, true);\n      e.wait();\n    }\n    {\n      int count_start = 77;\n      std::cout << \"\\nStart RestartableCounter at \" << count_start << \".\"\n                << std::endl;\n      sycl::event e = q.single_task<CounterID>(\n          restartable_counter::RestartableCounter{count_start});\n      passed &= CheckIncrements<restartable_counter::OutputPipe>(q, count_start,\n                                                                 kIterations);\n\n      std::cout << \"Stop kernel RestartableCounter\" << std::endl;\n      restartable_counter::StopPipe::write(q, true);\n      e.wait();\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}"
    },
    {
        "label": "triangular_loop.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <chrono>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// Seed for randomizing data inputs\nconstexpr int kInitSeed = 42;\n\n// This tutorial runs twice to show the impact with\n// and without the optimization.\nconstexpr int kNumRuns = 2;\n\n// number of nanoseconds in a second\nconstexpr double kNs = 1000000000.0;\n\n// Number of inputs. Don't set this too large, otherwise\n// computation of the reference solution will take a long time on\n// the host (the time is proportional to kSize^2)\n#if defined(FPGA_SIMULATOR)\nconstexpr int kSize = 256;\n#else\nconstexpr int kSize = 8 * 1024;\n#endif\n\n// >=1. Minimum number of iterations of the inner loop that must be\n// executed in the optimized implementation. Set this approximately\n// equal to the ii of inner loop in the unoptimized implementation.\nconstexpr int kM = 50;\n\n// do not use with unary operators, e.g., kMin(x++, y++)\nconstexpr int Min(int X, int Y) { return (((X) < (Y)) ? (X) : (Y)); };\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass Task;\n\n// This method represents the operation you perform on the loop-carried variable\n// in the triangular loop (i.e. a dot product or something that may take many\n// cycles to complete).\nint SomethingComplicated(int x) { return (int)sycl::sqrt((float)x); }\n\n// This kernel function implements two data paths: with and without the\n// optimization. 'optimize' specifies which path to take.\nvoid TriangularLoop(sycl::queue&q, buffer<uint32_t>& input_buf,\n                    buffer<uint32_t>& output_buf, uint32_t n, event& e,\n                    bool optimize) {\n  // Enqueue kernel\n  e = q.submit([&](handler& h) {\n    // Get accessors to the SYCL buffers\n    accessor input(input_buf, h, read_only);\n    accessor output(output_buf, h, write_only, no_init);\n\n    h.single_task<Task>([=]() [[intel::kernel_args_restrict]] {\n      // See README for description of the loop_bound calculation.\n      const int real_iterations = (n * (n + 1) / 2 - 1);\n      const int extra_dummy_iterations = (kM - 2) * (kM - 1) / 2;\n      const int loop_bound = real_iterations + extra_dummy_iterations;\n\n      // Local memory for the buffer to be operated on\n      uint32_t local_buf[kSize];\n\n      // Read the input_buf from global mem and load it into the local mem\n      for (uint32_t i = 0; i < kSize; i++) {\n        local_buf[i] = input[i];\n      }\n\n      // Perform the triangular loop computation\n\n      if (!optimize) {  // Unoptimized loop.\n\n        for (int x = 0; x < n; x++) {\n          for (int y = x + 1; y < n; y++) {\n            local_buf[y] = local_buf[y] + SomethingComplicated(local_buf[x]);\n          }\n        }\n\n      } else {  // Optimized loop.\n\n        // Indices to track the execution inside the single, merged loop.\n        int x = 0, y = 1;\n\n        // Specify that the minimum dependence-distance of loop-carried\n        // variables is kM iterations. We ensure this is true by modifying the y\n        // index such that a minimum of kM iterations are always executed.\n        [[intel::ivdep(kM)]] for (int i = 0; i < loop_bound; i++) {\n          // Determine if this iteration is a dummy iteration or a real\n          // iteration in which the computation should be performed.\n          bool compute = y > x;\n          // Perform the computation if needed.\n          if (compute) {\n            local_buf[y] = local_buf[y] + SomethingComplicated(local_buf[x]);\n          }\n          // Figure out the next value for the indices.\n          y++;\n\n          // If we've hit the end, set y such that a minimum of kM\n          // iterations are exected.\n          if (y == n) {\n            x++;\n            y = Min(n - kM, x + 1);\n          }\n        }\n      }\n\n      // Write the output to global mem\n      for (uint32_t i = 0; i < kSize; i++) {\n        output[i] = local_buf[i];\n      }\n    });\n  });\n\n}\n\nint main() {\n\n  // Host and kernel profiling\n  event e;\n  unsigned long t1_kernel, t2_kernel;\n  double time_kernel;\n// Create queue, get platform and device\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n    auto prop_list =\n        property_list{property::queue::enable_profiling()};\n\n    sycl::queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    platform platform = q.get_context().get_platform();\n    device device = q.get_device();\n    std::cout << \"Platform name: \"\n              << platform.get_info<info::platform::name>().c_str() << \"\\n\";\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // Create input and output buffers\n    auto input_buf = buffer<uint32_t>(range<1>(kSize));\n    auto output_buf = buffer<uint32_t>(range<1>(kSize));\n\n    srand(kInitSeed);\n\n    // Compute the reference solution\n    uint32_t gold[kSize];\n\n    {\n      // Get host-side accessors to the SYCL buffers.\n      host_accessor input_host(input_buf, write_only);\n\n      // Initialize random input\n      for (int i = 0; i < kSize; ++i) {\n        input_host[i] = rand() % 256;\n      }\n\n      for (int i = 0; i < kSize; ++i) {\n        gold[i] = input_host[i];\n      }\n    }\n\n    // Host accessor now out-of-scope and is destructed. This is required in\n    // order to unblock the kernel's subsequent accessor to the same buffer.\n\n    for (int x = 0; x < kSize; x++) {\n      for (int y = x + 1; y < kSize; y++) {\n        gold[y] += SomethingComplicated(gold[x]);\n      }\n    }\n\n    std::cout << \"Length of input array: \" << kSize << \"\\n\\n\";\n\n    for (int i = 0; i < kNumRuns; i++) {\n      switch (i) {\n        case 0: {\n          std::cout\n              << \"Beginning run without triangular loop optimization.\\n\\n\";\n          TriangularLoop(q, input_buf, output_buf, kSize, e, false);\n          break;\n        }\n        case 1: {\n          std::cout << \"Beginning run with triangular loop optimization.\\n\\n\";\n          TriangularLoop(q, input_buf, output_buf, kSize, e, true);\n          break;\n        }\n        default: {\n          TriangularLoop(q, input_buf, output_buf, kSize, e, false);\n        }\n      }\n\n      // Wait for kernels to finish\n      q.wait();\n\n      t1_kernel = e.get_profiling_info<info::event_profiling::command_start>();\n      t2_kernel = e.get_profiling_info<info::event_profiling::command_end>();\n      time_kernel = (t2_kernel - t1_kernel) / kNs;\n\n      // Get accessor to output buffer. Accessing the buffer at this point in\n      // the code will block on kernel completion.\n      host_accessor output_host(output_buf, read_only);\n\n      // Verify output and print pass/fail\n      bool passed = true;\n      int num_errors = 0;\n      for (int b = 0; b < kSize; b++) {\n        if (num_errors < 10 && output_host[b] != gold[b]) {\n          passed = false;\n          std::cout << \" Mismatch at element \" << b << \". expected \" << gold[b]\n                    << \")\\n\";\n          num_errors++;\n        }\n      }\n\n      if (passed) {\n        std::cout << \"Verification PASSED\\n\\n\";\n\n        // Report host execution time and throughput\n        std::cout.setf(std::ios::fixed);\n        std::cout << \"Execution time: \" << time_kernel << \" seconds\\n\";\n        int num_iterations =\n            kSize * (kSize + 1) / 2 -\n            1;  // One piece of data is processed on each iteration. This\n                // formula is taken from the loop_bound calculation.\n#if defined(FPGA_SIMULATOR)\n        double N_KB = (sizeof(uint32_t) * num_iterations) /\n                      1024;  // Amount of data processed, in kB\n        std::cout << \"Throughput \" << (i == 0 ? \"without\" : \"with\")\n                  << \" optimization: \" << N_KB / time_kernel << \" KB/s\\n\\n\";\n#else\n        double N_MB = (sizeof(uint32_t) * num_iterations) /\n                      (1024 * 1024);  // Amount of data processed, in mB\n        std::cout << \"Throughput \" << (i == 0 ? \"without\" : \"with\")\n                  << \" optimization: \" << N_MB / time_kernel << \" MB/s\\n\\n\";\n#endif\n      } else {\n        std::cout << \"Verification FAILED\\n\";\n        return 1;\n      }\n    }\n  } catch (sycl::exception const& e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n  return 0;\n}\n"
    },
    {
        "label": "main.cpp",
        "data": "#include <iostream>\n\n#include \"exception_handler.hpp\"\n#include \"memory_system_defines.hpp\"\n#include \"memory_system_kernels.hpp\"\n\n// Forward declaration of kernel names.\nclass IDNaiveKernel;\nclass IDOptimizedKernel;\n\n// Function that verifies the output from example kernels.\nbool CheckOutput(sycl::queue &q) {\n  SimpleOutputT result_naive;\n  SimpleOutputT result_optimized;\n  bool passed = true;\n  for (int i = 0; i < 500; ++i) {\n    result_naive = OutStreamNaiveKernel::read(q);\n    result_optimized = OutStreamOptKernel::read(q);\n    if (result_naive[4] != i || result_optimized[4] != i) {\n      passed = false;\n    }\n  }\n  return passed;\n}\n\nint main() {\n  try {\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    // Test for simple kernels.\n    q.single_task<class Input>([=]() {\n      for (int i = 0; i < 500; ++i) {\n        InStreamNaiveKernel::write(i);\n        InStreamOptKernel::write(i);\n      }\n    });\n\n    std::cout << \"Launch kernel\" << std::endl;\n\n    q.single_task<IDNaiveKernel>(NaiveKernel{});\n    q.single_task<IDOptimizedKernel>(OptimizedKernel{});\n\n    std::cout << \"Checking output\" << std::endl;\n    bool passed = CheckOutput(q);\n\n    if (passed) {\n      std::cout << \"Verification PASSED.\\n\";\n    } else {\n      std::cout << \"Verification FAILED.\\n\";\n      return 1;\n    }\n  }\n  catch (sycl::exception const &e) {\n    std::cerr << \"Caught a synchronous SYCL exception: \" << e.what()\n              << std::endl;\n    std::terminate();\n  }\n  return 0;\n}\n"
    },
    {
        "label": "n_way_buffering.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <cmath>\n#include <iomanip>\n#include <random>\n#include <thread>\n\n#include \"exception_handler.hpp\"\n\nusing namespace sycl;\n\n// N-way buffering. N must be >= 1.\nconstexpr int kLocalN = 5;\n\n// # times to execute the kernel. kTimes must be >= kLocalN\n#if defined(FPGA_EMULATOR)\nconstexpr int kTimes = 20;\n#elif defined(FPGA_SIMULATOR)\nconstexpr int kTimes = 10;\n#else\nconstexpr int kTimes = 100;\n#endif\n\n// # of floats to process on each kernel execution.\n#if defined(FPGA_EMULATOR)\nconstexpr int kSize = 4096;\n#elif defined(FPGA_SIMULATOR)\nconstexpr int kSize = 256;\n#else\nconstexpr int kSize = 2621440;  // ~10MB\n#endif\n\n// Kernel executes a power function (base^kPow). Must be\n// >= 2. Can increase this to increase kernel execution\n// time, but ProcessOutput() time will also increase.\n#if defined(FPGA_SIMULATOR)\nconstexpr int kPow = 5;\n#else\nconstexpr int kPow = 20;\n#endif\n\n// Number of iterations through the main loop\n#if defined(FPGA_SIMULATOR)\nconstexpr int kNumRuns = 2;\n#else\nconstexpr int kNumRuns = 4;\n#endif\n\nbool pass = true;\n\n// Forward declare the kernel name in the global scope.\n// This FPGA best practice reduces name mangling in the optimization reports.\nclass SimpleVpow;\n\n/*  Kernel function.\n    Performs buffer_b[i] = buffer_a[i] ** pow\n    Only supports pow >= 2.\n    This kernel is not meant to be an optimal implementation of the power\n   operation -- it's just a sample kernel for this tutorial whose execution time\n   is easily controlled via the pow parameter. SYCL buffers are created\n   externally and passed in by reference to control (external to this function)\n   when the buffers are destructed. The destructor causes a blocking buffer\n   transfer from device to host and N-way buffering requires us to not block\n   here (because we need to queue more kernels). So we only want this transfer\n   to occur at the end of overall execution, not at the end of each individual\n   kernel execution.\n*/\nvoid SimplePow(sycl::queue &q, buffer<float, 1> &buffer_a,\n               buffer<float, 1> &buffer_b, event &e) {\n  // Submit to the queue and execute the kernel\n  e = q.submit([&](handler &h) {\n    // Get kernel access to the buffers\n    accessor accessor_a(buffer_a, h, read_only);\n    accessor accessor_b(buffer_b, h, read_write, no_init);\n\n    const int num = kSize;\n    const int p = kPow - 1;  // Assumes pow >= 2;\n    assert(kPow >= 2);\n\n    h.single_task<class SimpleVpow>([=]() [[intel::kernel_args_restrict]] {\n      for (int j = 0; j < p; j++) {\n        if (j == 0) {\n          for (int i = 0; i < num; i++) {\n            accessor_b[i] = accessor_a[i] * accessor_a[i];\n          }\n        } else {\n          for (int i = 0; i < num; i++) {\n            accessor_b[i] = accessor_b[i] * accessor_a[i];\n          }\n        }\n      }\n    });\n  });\n\n  event update_host_event;\n  update_host_event = q.submit([&](handler &h) {\n    accessor accessor_b(buffer_b, h, read_only);\n\n    /*\n      Explicitly instruct the SYCL runtime to copy the kernel's output buffer\n      back to the host upon kernel completion. This is not required for\n      functionality since the buffer access in ProcessOutput() also implicitly\n      instructs the runtime to copy the data back. But it should be noted that\n      this buffer access blocks ProcessOutput() until the kernel is complete\n      and the data is copied. In contrast, update_host() instructs the runtime\n      to perform the copy earlier. This allows ProcessOutput() to optionally\n      perform more useful work *before* making the blocking buffer access. Said\n      another way, this allows ProcessOutput() to potentially perform more work\n      in parallel with the runtime's copy operation.\n    */\n    h.update_host(accessor_b);\n  });\n}\n\n// Returns kernel execution time for a given SYCL event from a queue.\nunsigned long SyclGetExecTimeNs(event e) {\n  unsigned long start_time =\n      e.get_profiling_info<info::event_profiling::command_start>();\n  unsigned long end_time = e.get_profiling_info<info::event_profiling::command_end>();\n  return (end_time - start_time);\n}\n\n// Local pow function for verifying results\nfloat MyPow(float input, int pow) {\n  return (pow == 0) ? 1 : input * MyPow(input, pow - 1);\n}\n\n/*  Compares kernel output against expected output.\n    Grabs kernel output data from its SYCL buffer. Reading from this buffer is a\n   blocking operation that will block on the kernel completing. Grabs expected\n   output from a host-side copy of the input data. A copy is used to allow for\n   parallel generation of the input data for the next execution. Queries and\n   records execution time of the kernel that just completed. This is a natural\n   place to do this because ProcessOutput() is blocked on kernel completion.\n*/\nvoid ProcessOutput(buffer<float, 1> &output_buf, std::vector<float> &input_copy,\n                   int exec_number, event e,\n                   unsigned long &total_kernel_time_per_slot) {\n  host_accessor output_buf_acc(output_buf, read_only);\n  int num_errors = 0;\n  int num_errors_to_print = 10;\n\n  // Max fractional difference between FPGA pow result and CPU pow result\n  // Anything greater than this will be considered an error\n  constexpr double epsilon = 0.01;\n\n  /*  The use of update_host() in the kernel function allows for additional\n     host-side operations to be performed here, in parallel with the buffer copy\n     operation from device to host, before the blocking access to the output\n     buffer is made via output_buf_acc[]. To be clear, no real operations are\n     done here and this is just a note that this is the place\n      where you *could* do it. */\n  for (int i = 0; i < kSize; i++) {\n    const double expected_value = MyPow(input_copy.data()[i], kPow);\n    const bool out_invalid = std::abs((output_buf_acc[i] - expected_value) /\n                                      expected_value) > epsilon;\n    if ((num_errors < num_errors_to_print) && out_invalid) {\n      if (num_errors == 0) {\n        pass = false;\n        std::cout << \"Verification failed on kernel execution # \" << exec_number\n                  << \". Showing up to \" << num_errors_to_print\n                  << \" mismatches.\\n\";\n      }\n      std::cout << \"Verification failed on kernel execution # \" << exec_number\n                << \", at element \" << i << \". Expected \" << std::fixed\n                << std::setprecision(16) << expected_value << \" but got \"\n                << output_buf_acc[i] << \"\\n\";\n      num_errors++;\n    }\n  }\n\n  // At this point we know the kernel has completed, so can query the profiling\n  // data.\n  total_kernel_time_per_slot += SyclGetExecTimeNs(e);\n}\n\n/*\n    Generates input data for the next kernel execution.\n    Writes the data into the associated SYCL buffer. The write will block until\n   the previous kernel execution, that is using this buffer, completes. Writes a\n   copy of the data into a host-side buffer that will later be used by\n   ProcessOutput().\n*/\nvoid ProcessInput(buffer<float, 1> &buf, std::vector<float> &copy) {\n  // We are generating completely new input data, so can use the no_init property\n  // here to indicate we don't care about the SYCL buffer's current contents.\n  host_accessor buf_acc(buf, write_only, no_init);\n\n  // RNG seed\n  auto seed = std::chrono::system_clock::now().time_since_epoch().count();\n\n  // RNG engine\n  std::default_random_engine dre(seed);\n\n  // Values between 1 and 2\n  std::uniform_real_distribution<float> di(1.0f, 2.0f);\n\n  // Randomly generate a start value and increment from there.\n  // Compared to randomly generating every value, this is done to\n  // speed up this function a bit.\n  float start_val = di(dre);\n\n  for (int i = 0; i < kSize; i++) {\n    buf_acc[i] = start_val;\n    copy.data()[i] = start_val;\n    start_val++;\n  }\n}\n\nint main() {\n// Create queue, get platform and device\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n#ifndef FPGA_HARDWARE\n  std::cout << \"\\nEmulator and simulator outputs do not demonstrate \"\n               \"true hardware performance. The design may need to run \"\n               \"on actual hardware to observe the performance benefit \"\n               \"of the optimization exemplified in this tutorial.\\n\\n\";\n#endif\n\n  try {\n    auto prop_list = property_list{property::queue::enable_profiling()};\n\n    sycl::queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    platform platform = q.get_context().get_platform();\n    device device = q.get_device();\n    std::cout << \"Platform name: \"\n              << platform.get_info<info::platform::name>().c_str() << \"\\n\";\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    std::cout << \"Executing kernel \" << kTimes << \" times in each round.\\n\\n\";\n\n    // Create a vector to store the input/output SYCL buffers\n    std::vector<buffer<float, 1>> input_buf;\n    std::vector<buffer<float, 1>> output_buf;\n\n    // For every execution slot, we need 2 host-side buffers\n    // to store copies of the input data. One is used to\n    // verify the previous kernel's output. The other stores\n    // the new data for the next kernel execution.\n    std::vector<float> input_buf_copy[2 * kLocalN];\n\n    // SYCL events for each kernel launch.\n    event sycl_events[kLocalN];\n\n    // In nanoseconds. Total execution time of kernels in a given slot.\n    unsigned long total_kernel_time_per_slot[kLocalN];\n\n    // Total execution time of all kernels.\n    unsigned long total_kernel_time = 0;\n\n    // Threads to process the output from each kernel\n    std::thread t_process_output[kLocalN];\n\n    // Threads to process the input data for the next kernel\n    std::thread t_process_input[kLocalN];\n\n    // Demonstrate with 1-way buffering first, then N-way buffering.\n    int N;\n\n    // st = \"single threaded\".\n    // Used to enable multi-threading in subsequent runs.\n    bool st = true;\n\n    // Allocate vectors to store the host-side copies of the input data\n    for (int i = 0; i < 2 * kLocalN; i++) {\n      input_buf_copy[i] = std::vector<float>(kSize);\n    }\n\n    // Create and allocate the SYCL buffers\n    for (int i = 0; i < kLocalN; i++) {\n      input_buf.push_back(buffer<float, 1>(range<1>(kSize)));\n      output_buf.push_back(buffer<float, 1>(range<1>(kSize)));\n    }\n\n    /*\n      Main loop.\n      This loop runs multiple times to demonstrate how performance can be\n      improved by increasing the number of buffers as well as multi-threading\n      the host-side operations. The first iteration is a base run, demonstrating\n      the performance with none of these optimizations (ie. 1-way buffering,\n      single-threaded).\n    */\n    for (int i = 0; i < kNumRuns; i++) {\n      for (int i = 0; i < kLocalN; i++) {\n        total_kernel_time_per_slot[i] = 0;  // Initialize timers to zero.\n      }\n\n      switch (i) {\n        case 0: {\n          std::cout << \"*** Beginning execution, 1-way buffering, \"\n                       \"single-threaded host operations\\n\";\n          N = 1;\n          st = true;\n          break;\n        }\n        case 1: {\n          std::cout << \"*** Beginning execution, 1-way buffering, \"\n                       \"multi-threaded host operations.\\n\";\n          N = 1;\n          st = false;\n          break;\n        }\n        case 2: {\n          std::cout << \"*** Beginning execution, 2-way buffering, \"\n                       \"multi-threaded host operationss\\n\";\n          N = 2;\n          st = false;\n          break;\n        }\n        case 3: {\n          std::cout << \"*** Beginning execution, N=\" << kLocalN\n                    << \"-way buffering, multi-threaded host operations\\n\";\n          N = kLocalN;\n          st = false;\n          break;\n        }\n        default:\n          std::cout << \"*** Beginning execution.\\n\";\n      }\n\n      // Start the timer. This will include the time to process the\n      // input data for the first N kernel executions.\n      auto start = std::chrono::steady_clock::now();\n\n      // Process the input data for first N kernel executions. For\n      // multi-threaded runs, this is done in parallel.\n      for (int i = 0; i < N; i++) {\n        t_process_input[i] = std::thread(ProcessInput, std::ref(input_buf[i]),\n                                         std::ref(input_buf_copy[i]));\n        if (st) {\n          t_process_input[i].join();\n        }\n      }\n\n      /*\n        It's useful to think of the kernel execution space as having N slots.\n        Conceptually, the slots are executed chronologically sequentially on the\n        device (i.e. slot 0 to N-1). Each slot has its own buffering on both the\n        host and device. Before launching a kernel in a given slot, we must\n        process output data from the previous execution that occurred in that\n        slot and process new input data for the upcoming new execution in that\n        slot.\n      */\n      for (int i = 0; i < kTimes; i++) {\n        // The current slot is i%N.\n        // Before each kernel launch, the ProcessOutput() must have completed\n        // for the last execution in this slot. The ProcessInput() must also\n        // have completed for the upcoming new execution for this slot. Block on\n        // both of these.\n        if (!st) {\n          // ProcessOutput() is only relevant after the\n          // first N kernels have been launched.\n          if (i >= N) {\n            t_process_output[i % N].join();\n          }\n\n          t_process_input[i % N].join();\n        }\n\n        // Launch the kernel. This is non-blocking with respect to main().\n        // Only print every few iterations, just to limit the prints.\n        if (i % 10 == 0) {\n          std::cout << \"Launching kernel #\" << i << \"\\n\";\n        }\n\n        SimplePow(q, input_buf[i % N], output_buf[i % N], sycl_events[i % N]);\n\n        // Immediately launch threads for the ProcessOutput() and\n        // ProcessInput() for *this* slot. These are non-blocking with respect\n        // to main(), but they will individually be blocked until the\n        // corresponding kernel execution is complete. The ProcessOutput()\n        // compares the kernel output data against the input data. But\n        // ProcessInput() will be overwriting that input data in parallel.\n        // Therefore ProcessOutput() must compare against an older copy of the\n        // data. We ping-pong between host-side copies of the input data.\n        t_process_output[i % N] = std::thread(\n            ProcessOutput, std::ref(output_buf[i % N]),\n            std::ref(input_buf_copy[i % (2 * N)]), i, sycl_events[i % N],\n            std::ref(total_kernel_time_per_slot[i % N]));\n\n        // For single-threaded runs, force single-threaded operation by\n        // blocking here immediately.\n        if (st) {\n          t_process_output[i % N].join();\n        }\n\n        // For the final N kernel launches, no need to process\n        // input data because there will be no more launches.\n        if (i < kTimes - N) {\n          // The indexes for the input_buf_copy used by ProcessOutput() and\n          // ProcessInput() are spaced N apart.\n          t_process_input[i % N] =\n              std::thread(ProcessInput, std::ref(input_buf[i % N]),\n                          std::ref(input_buf_copy[(i + N) % (2 * N)]));\n\n          if (st) {\n            t_process_input[i % N].join();\n          }\n        }\n      }\n\n      // Wait for the final N threads to finish and add up the overall kernel\n      // execution time.\n      total_kernel_time = 0;\n      for (int i = 0; i < N; i++) {\n        if (!st) {\n          t_process_output[i].join();\n        }\n        total_kernel_time += total_kernel_time_per_slot[i];\n      }\n\n      // Stop the timer.\n      auto end = std::chrono::steady_clock::now();\n      double time_span = std::chrono::duration_cast<std::chrono::duration<double>>(end - start).count();\n\n      std::cout << \"\\nOverall execution time \"\n                << ((i == kNumRuns - 1) ? (\"with N-way buffering \") : \"\")\n                << \"= \" << (unsigned)(time_span * 1000) << \" ms\\n\";\n      std::cout << \"Total kernel-only execution time \"\n                << ((i == kNumRuns - 1) ? (\"with N-way buffering \") : \"\")\n                << \"= \" << (unsigned)(total_kernel_time / 1000000) << \" ms\\n\";\n      std::cout << \"Throughput = \" << std::setprecision(8)\n                << (float)kSize * (float)kTimes * (float)sizeof(float) /\n                       (float)time_span / 1000000\n                << \" MB/s\\n\\n\\n\";\n    }\n    if (pass) {\n      std::cout << \"Verification PASSED\\n\";\n    } else {\n      std::cout << \"Verification FAILED\\n\";\n      return 1;\n    }\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n      std::cerr << \"If you are targeting the FPGA simulator, compile with \"\n                   \"-DFPGA_SIMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n  return 0;\n}\n"
    },
    {
        "label": "buffered_host_streaming.cpp",
        "data": "#include <assert.h>\n#include <algorithm>\n#include <array>\n#include <chrono>\n#include <iomanip>\n#include <numeric>\n#include <functional>\n#include <string>\n#include <thread>\n#include <type_traits>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\n#include \"streaming_without_api.hpp\"\n#include \"streaming_with_api.hpp\"\n\nusing namespace sycl;\n\n// the type used\n// NOTE: the tutorial assumes the use of a sycl::vec datatype (like long8).\n// Therefore, 'Type' must be a sycl::vec datatype (e.g. int8, char64, etc).\nusing Type = long8;\n\n// forward declare the roofline analysis function\ntemplate<typename T>\nvoid DoRooflineAnalysis(queue& q, size_t buffer_count, size_t iterations,\n                        size_t threads);\n\n// the main function\nint main(int argc, char* argv[]) {\n  // parse command line arguments\n#if defined(FPGA_EMULATOR)\n  size_t reps = 20;\n  size_t buffer_count = 1 << 12;  // 4096\n  size_t iterations = 2;\n#elif defined(FPGA_SIMULATOR)\n  size_t reps = 2;\n  size_t buffer_count = 1 << 8;  // 256\n  size_t iterations = 2;\n#else\n  size_t reps = 200;\n  size_t buffer_count = 1 << 19;  // 524388\n  size_t iterations = 5;\n#endif\n\n  // auto-detect the number of available threads\n  size_t detected_threads = (size_t)(std::thread::hardware_concurrency());\n\n  // thread::hardware_concurrency() returns 0 if it cannot determine\n  // the number of threads, so fallback to 2\n  size_t threads = std::max(size_t(2), detected_threads);\n\n  size_t buffers = 2;\n  bool need_help = false;\n\n  // parse the command line arguments\n  for (int i = 1; i < argc; i++) {\n    std::string arg(argv[i]);\n\n    if (arg == \"--help\" || arg == \"-h\") {\n      need_help = true;\n    } else {\n      std::string str_after_equals = arg.substr(arg.find(\"=\") + 1);\n\n      if (arg.find(\"--reps=\") == 0) {\n        reps = atoi(str_after_equals.c_str());\n      } else if (arg.find(\"--buffers=\") == 0) {\n        buffers = atoi(str_after_equals.c_str());\n      } else if (arg.find(\"--buffer_count=\") == 0) {\n        buffer_count = atoi(str_after_equals.c_str());\n      } else if (arg.find(\"--iterations=\") == 0) {\n        iterations = std::max(2, atoi(str_after_equals.c_str()) + 1);\n      } else if (arg.find(\"--threads=\") == 0) {\n        threads = atoi(str_after_equals.c_str());\n      }  else {\n        std::cout << \"WARNING: ignoring unknown argument '\" << arg << \"'\\n\";\n      }\n    }\n  }\n\n  // print help is asked\n  if (need_help) {\n    std::cout << \"USAGE: \"\n              << \"./buffered_host_streaming \"\n              << \"[--reps=<int>] \"\n              << \"[--buffers=<int>] \"\n              << \"[--buffer_count=<int>] \"\n              << \"[--iterations=<int>] \"\n              << \"[--threads=<int>]\\n\";\n    return 0;\n  }\n\n  // check the reps\n  if (reps <= 0) {\n    std::cerr << \"ERROR: 'reps' must be greater than 0\\n\";\n    std::terminate();\n  }\n\n  // check the buffer_count\n  if (buffer_count <= 0) {\n    std::cerr << \"ERROR: 'buffer_count' must be greater than 0\\n\";\n    std::terminate();\n  }\n\n  // check the number of iterations\n  if (iterations <= 0) {\n    std::cerr << \"ERROR: 'iterations' must be positive\\n\";\n    std::terminate();\n  }\n\n  if (threads <= 0) {\n    std::cerr << \"ERROR: 'threads' must be positive\\n\";\n    std::terminate();\n  }\n\n  // print info\n  std::cout << \"Repetitions:      \" << reps << \"\\n\";\n  std::cout << \"Buffers:          \" << buffers << \"\\n\";\n  std::cout << \"Buffer Count:     \" << buffer_count << \"\\n\";\n  std::cout << \"Iterations:       \" << iterations-1 << \"\\n\";\n  std::cout << \"Total Threads:    \" << threads << \"\\n\";\n  std::cout << \"\\n\";\n\n  bool passed = true;\n\n  try {\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // queue properties to enable profiling\n    property_list prop_list { property::queue::enable_profiling() };\n\n    // create the device queue\n    queue q(selector, fpga_tools::exception_handler, prop_list);\n\n    // make sure the device supports USM host allocations\n    auto device = q.get_device();\n    if (!device.get_info<info::device::usm_host_allocations>()) {\n      std::cerr << \"ERROR: The selected device does not support USM host\"\n                << \" allocations\\n\";\n      std::terminate();\n    }\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    ///////////////////////////////////////////////////////////////////////////\n    // find the bandwidth of each processing component in our design\n    std::cout << \"Running the roofline analysis\\n\";\n    DoRooflineAnalysis<Type>(q, buffer_count, iterations, threads);\n    std::cout << \"Done the roofline analysis\\n\\n\";\n    ///////////////////////////////////////////////////////////////////////////\n\n    ///////////////////////////////////////////////////////////////////////////\n    // run the design that does not use the API (see streaming_without_api.hpp)\n    std::cout << \"Running the full design without API\\n\";\n    passed &= DoWork<Type>(q, buffers, buffer_count, reps, iterations, threads);\n    std::cout << \"\\n\";\n    ///////////////////////////////////////////////////////////////////////////\n\n    ///////////////////////////////////////////////////////////////////////////\n    // run the design that uses the API (see streaming_with_api.hpp)\n    std::cout << \"Running the full design with API\\n\";\n    passed &= DoWorkAPI<Type>(q, buffers, buffer_count, reps, iterations,\n                              threads);\n    std::cout << \"\\n\";\n    ///////////////////////////////////////////////////////////////////////////\n\n  } catch (exception const& e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  if(passed) {\n    std::cout << \"PASSED\\n\";\n    return 0;\n  } else {\n    std::cout << \"FAILED\\n\";\n    return 1;\n  }\n}\n\n// This function performs a bandwidth test on the individual components of the\n// processing pipeline: Producer, Consumer, and the FPGA kernel.\n// It computes (and returns) the maximum possible throughput of the full design\n// when the individual components are combined. \ntemplate<typename T>\nvoid DoRooflineAnalysis(queue& q, size_t buffer_count, size_t iterations,\n                        size_t threads) {\n  // allocate some memory to work with\n  T *tmp_in[2], *tmp_out[2];\n  for (size_t i = 0; i < 2; i++) {\n    if ((tmp_in[i] = malloc_host<T>(buffer_count, q)) == nullptr) {\n      std::cerr << \"ERROR: could not allocate space for \"\n                << \"'tmp_in[\" << i << \"]'\\n\";\n      std::terminate();\n    }\n    if ((tmp_out[i] = malloc_host<T>(buffer_count, q)) == nullptr) {\n      std::cerr << \"ERROR: could not allocate space for \"\n                << \"'tmp_out[\" << i << \"]'\\n\";\n      std::terminate();\n    }\n  }\n\n  // the Producer and Consumer get half of the total threads, each.\n  // std::max() guards against the case where there is only 1 thread.\n  size_t half_threads = std::max(size_t(1), threads/2);\n\n  // these tests are quick, so run some extra iterations for more accuracy\n  size_t bw_test_iterations = iterations * 4 + 1;\n\n  // timing variables\n  high_resolution_clock::time_point start, end;\n  duration<double, std::milli> delta_ms;\n  double processing_time_producer = 0.0, tp_producer;\n  double processing_time_consumer = 0.0, tp_consumer;\n  double processing_time_producer_consumer = 0.0, tp_producer_consumer;\n  double processing_time_kernel = 0.0, tp_kernel;\n\n  // the total number of megabytes processed by the operations\n  double size_mb = sizeof(T) * buffer_count * 1e-6;\n\n  // do multiple interations of the test to improve measurement accuracy\n  for (size_t i = 0; i < bw_test_iterations; i++) {\n    // generate some data\n    std::fill_n(tmp_out[0], buffer_count, i);\n    std::fill_n(tmp_out[1], buffer_count, i);\n\n    // Producer in isolation\n    start = high_resolution_clock::now();\n    // ProducerFunction is defined in common.hpp\n    ProducerFunction(tmp_out[0], tmp_in[0], buffer_count, half_threads);\n    end = high_resolution_clock::now();\n    delta_ms = end - start;\n    if (i > 0) processing_time_producer += delta_ms.count();\n\n    // wait 10ms\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n    // Consumer in isolation\n    start = high_resolution_clock::now();\n    // ConsumerFunction is defined in common.hpp\n    ConsumerFunction(tmp_in[0], tmp_out[0], buffer_count, half_threads);\n    end = high_resolution_clock::now();\n    delta_ms = end - start;\n    if (i > 0) processing_time_consumer += delta_ms.count();\n\n    // wait 10ms\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n    // Producer & Consumer at the same time\n    // NOTE: this is the most accurate measurement of our actual design,\n    // since the Producer and Consumer will be executing in parallel (see\n    // README.md for more details on this).\n    // The ProducerFunction and ConsumerFunction are defined in common.hpp\n    start = high_resolution_clock::now();\n    std::thread producer_thread([&] {\n      ProducerFunction(tmp_out[0], tmp_in[0], buffer_count, half_threads);\n    });\n    ConsumerFunction(tmp_out[1], tmp_in[1], buffer_count, half_threads);\n    producer_thread.join();\n    end = high_resolution_clock::now();\n    delta_ms = end - start;\n    if (i > 0) processing_time_producer_consumer += delta_ms.count();\n\n    // wait 10ms\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n    // Kernel in isolation\n    start = high_resolution_clock::now();\n    // SubmitKernel is defined in streaming_without_api.hpp\n    auto e = SubmitKernel(q, tmp_in[0], buffer_count, tmp_out[0]);\n    e.wait();\n    end = high_resolution_clock::now();\n    delta_ms = end - start;\n    if (i > 0) processing_time_kernel += delta_ms.count();\n\n    // wait 10ms\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n  }\n\n  // average the processing times across iterations\n  processing_time_producer /= (bw_test_iterations-1);\n  processing_time_consumer /= (bw_test_iterations-1);\n  processing_time_producer_consumer /= (bw_test_iterations-1);\n  processing_time_kernel /= (bw_test_iterations-1);\n\n  // compute throughputs\n  tp_producer = size_mb / (processing_time_producer * 1e-3);\n  tp_consumer = size_mb / (processing_time_consumer * 1e-3);\n  tp_producer_consumer = size_mb / (processing_time_producer_consumer * 1e-3);\n  tp_kernel = size_mb / (processing_time_kernel * 1e-3);\n\n  // print results\n  std::cout << std::fixed << std::setprecision(4);\n  std::cout << \"Producer (\" << half_threads << \" threads)\\n\";\n  std::cout << \"\\tTime:       \" << processing_time_producer << \" ms\\n\";\n  std::cout << \"\\tThroughput: \" << tp_producer << \" MB/s\\n\";\n\n  std::cout << \"Consumer (\" << half_threads << \" threads)\\n\";\n  std::cout << \"\\tTime:       \" << processing_time_consumer << \" ms\\n\";\n  std::cout << \"\\tThroughput: \" << tp_consumer << \" MB/s\\n\";\n\n  std::cout << \"Producer & Consumer (\" << half_threads << \" threads, each)\\n\";\n  std::cout << \"\\tTime:       \" << processing_time_producer_consumer << \" ms\\n\";\n  std::cout << \"\\tThroughput: \" << tp_producer_consumer << \" MB/s\\n\";\n\n  std::cout << \"Kernel\\n\";\n  std::cout << \"\\tTime:       \" << processing_time_kernel << \" ms\\n\";\n  std::cout << \"\\tThroughput: \" << tp_kernel << \" MB/s\\n\";\n\n  // find the minimum throughput (which will bottleneck the design)\n  std::vector<double> tps = {tp_producer,\n                             tp_consumer,\n                             tp_producer_consumer,\n                             tp_kernel};\n  \n  // the index of the min throughput\n  int min_tp_idx = std::min_element(tps.begin(), tps.end()) - tps.begin();\n\n  // the minimum throughput\n  double min_tp = tps[min_tp_idx];\n\n  // check if the bottleneck throughput is the kernel\n  bool kernel_is_limit = (min_tp_idx == tps.size()-1);\n\n  // the minimum throughput is the maximum throughput of the full design\n  std::cout << \"\\n\";\n  std::cout << \"Maximum Design Throughput: \" << min_tp << \" MB/s\\n\";\n  std::cout << \"The FPGA kernel \"\n            << (kernel_is_limit ? \"limits\" : \"does not limit\")\n            << \" the performance of the design\\n\";\n\n  // free temp USM memory\n  for (size_t i = 0; i < 2; i++) {\n    sycl::free(tmp_in[i], q);\n    sycl::free(tmp_out[i], q);\n  }\n}\n"
    },
    {
        "label": "kernel.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"kernel.hpp\"\n\n\n// This file contains 'almost' exclusively device code. The single-source SYCL\n// code has been refactored between host.cpp and kernel.cpp to separate host and\n// device code to the extent that the language permits.\n//\n// Note that ANY change in either this file or in kernel.hpp will be detected\n// by the build system as a difference in the dependencies of device.o,\n// triggering a full recompilation of the device code. \n//\n// This is true even of trivial changes, e.g. tweaking the function definition \n// or the names of variables like 'q' or 'h', EVEN THOUGH these are not truly \n// \"device code\".\n\n\n// Forward declare the kernel names in the global scope. This FPGA best practice\n// reduces compiler name mangling in the optimization reports.\nclass VectorAdd;\n\nvoid RunKernel(queue& q, buffer<float,1>& buf_a, buffer<float,1>& buf_b,\n               buffer<float,1>& buf_r, size_t size){\n    // submit the kernel\n    q.submit([&](handler &h) {\n      // Data accessors\n      accessor a(buf_a, h, read_only);\n      accessor b(buf_b, h, read_only);\n      accessor r(buf_r, h, write_only, no_init);\n\n      // Kernel executes with pipeline parallelism on the FPGA.\n      // Use kernel_args_restrict to specify that a, b, and r do not alias.\n      h.single_task<VectorAdd>([=]() [[intel::kernel_args_restrict]] {\n        for (size_t i = 0; i < size; ++i) {\n          r[i] = a[i] + b[i];\n        }\n      });\n    });\n}\n"
    },
    {
        "label": "kernel.hpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n#include <sycl/sycl.hpp>\n\nusing namespace sycl;\n\nvoid RunKernel(queue& q, buffer<float,1>& buf_a, buffer<float,1>& buf_b,\n               buffer<float,1>& buf_r, size_t size);\n"
    },
    {
        "label": "host.cpp",
        "data": "//==============================================================\n// Copyright Intel Corporation\n//\n// SPDX-License-Identifier: MIT\n// =============================================================\n\n#include <iostream>\n#include <vector>\n\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\n#include \"exception_handler.hpp\"\n\n// This code sample demonstrates how to split the host and FPGA kernel code into\n// separate compilation units so that they can be separately recompiled.\n// Consult the README for a detailed discussion.\n//  - host.cpp (this file) contains exclusively code that executes on the host.\n//  - kernel.cpp contains almost exclusively code that executes on the device.\n//  - kernel.hpp contains only the forward declaration of a function containing\n//    the device code.\n#include \"kernel.hpp\"\n\nusing namespace sycl;\n\n// the tolerance used in floating point comparisons\nconstexpr float kTol = 0.001;\n\n// the array size of vectors a, b and c\nconstexpr size_t kArraySize = 32;\n\nint main() {\n  std::vector<float> vec_a(kArraySize);\n  std::vector<float> vec_b(kArraySize);\n  std::vector<float> vec_r(kArraySize);\n\n  // Fill vectors a and b with random float values\n  for (size_t i = 0; i < kArraySize; i++) {\n    vec_a[i] = rand() / (float)RAND_MAX;\n    vec_b[i] = rand() / (float)RAND_MAX;\n  }\n\n  // Select either the FPGA emulator, FPGA simulator or FPGA device\n#if FPGA_SIMULATOR\n  auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n  auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n  auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n  try {\n\n    // Create a queue bound to the chosen device.\n    // If the device is unavailable, a SYCL runtime exception is thrown.\n    queue q(selector, fpga_tools::exception_handler);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // create the device buffers\n    buffer device_a(vec_a);\n    buffer device_b(vec_b);\n    buffer device_r(vec_r);\n\n    // The definition of this function is in a different compilation unit,\n    // so host and device code can be separately compiled.\n    RunKernel(q, device_a, device_b, device_r, kArraySize);\n\n  } catch (exception const &e) {\n    // Catches exceptions in the host code\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  // At this point, the device buffers have gone out of scope and the kernel\n  // has been synchronized. Therefore, the output data (vec_r) has been updated\n  // with the results of the kernel and is safely accesible by the host CPU.\n\n  // Test the results\n  size_t correct = 0;\n  for (size_t i = 0; i < kArraySize; i++) {\n    float tmp = vec_a[i] + vec_b[i] - vec_r[i];\n    if (tmp * tmp < kTol * kTol) {\n      correct++;\n    }\n  }\n\n  // Summarize results\n  if (correct == kArraySize) {\n    std::cout << \"PASSED: results are correct\\n\";\n  } else {\n    std::cout << \"FAILED: results are incorrect\\n\";\n  }\n\n  return !(correct == kArraySize);\n}\n"
    },
    {
        "label": "vector_add.cpp",
        "data": "#include <iostream>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass VectorAddID;\n\nvoid VectorAdd(const int *vec_a_in, const int *vec_b_in, int *vec_c_out,\n               int len) {\n  for (int idx = 0; idx < len; idx++) {\n    int a_val = vec_a_in[idx];\n    int b_val = vec_b_in[idx];\n    int sum = a_val + b_val;\n    vec_c_out[idx] = sum;\n  }\n}\n\nconstexpr int kVectSize = 256;\n\nint main() {\n  bool passed = true;\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    sycl::queue q(selector);\n\n    // make sure the device supports USM host allocations\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // declare arrays and fill them\n    int *vec_a = new int[kVectSize];\n    int *vec_b = new int[kVectSize];\n    int *vec_c = new int[kVectSize];\n    for (int i = 0; i < kVectSize; i++) {\n      vec_a[i] = i;\n      vec_b[i] = (kVectSize - i);\n    }\n\n    std::cout << \"add two vectors of size \" << kVectSize << std::endl;\n    {\n      // copy the input arrays to buffers to share with kernel\n      sycl::buffer buffer_a{vec_a, sycl::range(kVectSize)};\n      sycl::buffer buffer_b{vec_b, sycl::range(kVectSize)};\n      sycl::buffer buffer_c{vec_c, sycl::range(kVectSize)};\n\n      q.submit([&](sycl::handler &h) {\n        // use accessors to interact with buffers from device code\n        sycl::accessor accessor_a{buffer_a, h, sycl::read_only};\n        sycl::accessor accessor_b{buffer_b, h, sycl::read_only};\n        sycl::accessor accessor_c{buffer_c, h, sycl::read_write, sycl::no_init};\n\n        h.single_task<VectorAddID>([=]() {\n          VectorAdd(&accessor_a[0], &accessor_b[0], &accessor_c[0], kVectSize);\n        });\n      });\n    }\n    // result is copied back to host automatically when accessors go out of\n    // scope.\n\n    // verify that VC is correct\n    for (int i = 0; i < kVectSize; i++) {\n      int expected = vec_a[i] + vec_b[i];\n      if (vec_c[i] != expected) {\n        std::cout << \"idx=\" << i << \": result \" << vec_c[i] << \", expected (\"\n                  << expected << \") A=\" << vec_a[i] << \" + B=\" << vec_b[i]\n                  << std::endl;\n        passed = false;\n      }\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    delete[] vec_a;\n    delete[] vec_b;\n    delete[] vec_c;\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}"
    },
    {
        "label": "vector_add.cpp",
        "data": "#include <iostream>\n#include <vector>\n\n// oneAPI headers\n#include <sycl/sycl.hpp>\n#include <sycl/ext/intel/fpga_extensions.hpp>\n\nusing namespace sycl;\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass VectorAddID;\n\nvoid VectorAdd(const int *vec_a_in, const int *vec_b_in, int *vec_c_out,\n               int len) {\n  for (int idx = 0; idx < len; idx++) {\n    int a_val = vec_a_in[idx];\n    int b_val = vec_b_in[idx];\n    int sum = a_val + b_val;\n    vec_c_out[idx] = sum;\n  }\n}\n\nconstexpr int kVectSize = 256;\n\nint main() {\n  bool passed = true;\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    sycl::queue q(selector);\n\n    // make sure the device supports USM host allocations\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // declare arrays and fill them\n    // allocate in shared memory so the kernel can see them\n    int *vec_a = malloc_shared<int>(kVectSize, q);\n    int *vec_b = malloc_shared<int>(kVectSize, q);\n    int *vec_c = malloc_shared<int>(kVectSize, q);\n    for (int i = 0; i < kVectSize; i++) {\n      vec_a[i] = i;\n      vec_b[i] = (kVectSize - i);\n    }\n\n    std::cout << \"add two vectors of size \" << kVectSize << std::endl;\n\n    q.single_task<VectorAddID>([=]() { \n        VectorAdd(vec_a, vec_b, vec_c, kVectSize); \n    })\n    .wait();\n\n    // verify that vec_c is correct\n    for (int i = 0; i < kVectSize; i++) {\n      int expected = vec_a[i] + vec_b[i];\n      if (vec_c[i] != expected) {\n        std::cout << \"idx=\" << i << \": result \" << vec_c[i] << \", expected (\"\n                  << expected << \") A=\" << vec_a[i] << \" + B=\" << vec_b[i]\n                  << std::endl;\n        passed = false;\n      }\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    free(vec_a, q);\n    free(vec_b, q);\n    free(vec_c, q);\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"
    },
    {
        "label": "vector_add.cpp",
        "data": "#include <iostream>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass VectorAddID;\n\nstruct VectorAdd {\n  int *const vec_a_in;\n  int *const vec_b_in;\n  int *const vec_c_out;\n  int len;\n\n  void operator()() const {\n    for (int idx = 0; idx < len; idx++) {\n      int a_val = vec_a_in[idx];\n      int b_val = vec_b_in[idx];\n      int sum = a_val + b_val;\n      vec_c_out[idx] = sum;\n    }\n  }\n};\n\nconstexpr int kVectSize = 256;\n\nint main() {\n  bool passed = true;\n  try {\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    // create the device queue\n    sycl::queue q(selector);\n\n    auto device = q.get_device();\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    if (!device.has(sycl::aspect::usm_host_allocations)) {\n      std::terminate();\n    }\n\n    // declare arrays and fill them\n    // allocate in shared memory so the kernel can see them\n    int *vec_a = sycl::malloc_shared<int>(kVectSize, q);\n    int *vec_b = sycl::malloc_shared<int>(kVectSize, q);\n    int *vec_c = sycl::malloc_shared<int>(kVectSize, q);\n    for (int i = 0; i < kVectSize; i++) {\n      vec_a[i] = i;\n      vec_b[i] = (kVectSize - i);\n    }\n\n    std::cout << \"add two vectors of size \" << kVectSize << std::endl;\n\n    q.single_task<VectorAddID>(VectorAdd{vec_a, vec_b, vec_c, kVectSize})\n        .wait();\n\n    // verify that vec_c is correct\n    for (int i = 0; i < kVectSize; i++) {\n      int expected = vec_a[i] + vec_b[i];\n      if (vec_c[i] != expected) {\n        std::cout << \"idx=\" << i << \": result \" << vec_c[i] << \", expected (\"\n                  << expected << \") A=\" << vec_a[i] << \" + B=\" << vec_b[i]\n                  << std::endl;\n        passed = false;\n      }\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    sycl::free(vec_a, q);\n    sycl::free(vec_b, q);\n    sycl::free(vec_c, q);\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}"
    },
    {
        "label": "vector_add.cpp",
        "data": "#include <iostream>\n\nvoid VectorAdd(const int *a_in, const int *b_in, int *c_out, int len) {\n  for (int idx = 0; idx < len; idx++) {\n    int a_val = a_in[idx];\n    int b_val = b_in[idx];\n    int sum = a_val + b_val;\n    c_out[idx] = sum;\n  }\n}\n\nconstexpr int kVectSize = 256;\n\nint main() {\n  // declare arrays and fill them\n  int *vec_a = new int[kVectSize];\n  int *vec_b = new int[kVectSize];\n  int *vec_c = new int[kVectSize];\n  for (int i = 0; i < kVectSize; i++) {\n    vec_a[i] = i;\n    vec_b[i] = (kVectSize - i);\n  }\n\n  std::cout << \"add two vectors of size \" << kVectSize << std::endl;\n\n  VectorAdd(vec_a, vec_b, vec_c, kVectSize);\n\n  // verify that vector C is correct\n  bool passed = true;\n  for (int i = 0; i < kVectSize; i++) {\n    int expected = vec_a[i] + vec_b[i];\n    if (vec_c[i] != expected) {\n      std::cout << \"idx=\" << i << \": result \" << vec_c[i] << \", expected (\"\n                << expected << \") A=\" << vec_a[i] << \" + B=\" << vec_b[i]\n                << std::endl;\n      passed = false;\n    }\n  }\n\n  std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n  delete[] vec_a;\n  delete[] vec_b;\n  delete[] vec_c;\n\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}"
    },
    {
        "label": "fpga_template.cpp",
        "data": "#include <iostream>\n\n// oneAPI headers\n#include <sycl/ext/intel/fpga_extensions.hpp>\n#include <sycl/sycl.hpp>\n\n#include \"exception_handler.hpp\"\n\n// Forward declare the kernel name in the global scope. This is an FPGA best\n// practice that reduces name mangling in the optimization reports.\nclass VectorAddID;\n\nstruct VectorAdd {\n  int *const a_in;\n  int *const b_in;\n  int *const c_out;\n  int len;\n\n  void operator()() const {\n    for (int idx = 0; idx < len; idx++) {\n      int a_val = a_in[idx];\n      int b_val = b_in[idx];\n      int sum = a_val + b_val;\n      c_out[idx] = sum;\n    }\n  }\n};\n\nconstexpr int kVectSize = 256;\n\nint main() {\n  bool passed = false;\n\n  try {\n\n    // Use compile-time macros to select either:\n    //  - the FPGA emulator device (CPU emulation of the FPGA)\n    //  - the FPGA device (a real FPGA)\n    //  - the simulator device\n#if FPGA_SIMULATOR\n    auto selector = sycl::ext::intel::fpga_simulator_selector_v;\n#elif FPGA_HARDWARE\n    auto selector = sycl::ext::intel::fpga_selector_v;\n#else  // #if FPGA_EMULATOR\n    auto selector = sycl::ext::intel::fpga_emulator_selector_v;\n#endif\n\n    sycl::queue q(selector, fpga_tools::exception_handler,\n                  sycl::property::queue::enable_profiling{});\n\n    auto device = q.get_device();\n\n    // make sure the device supports USM host allocations\n    if (!device.has(sycl::aspect::usm_host_allocations)) {\n      std::cerr << \"This design must either target a board that supports USM \"\n                   \"Host/Shared allocations, or IP Component Authoring. \"\n                << std::endl;\n      std::terminate();\n    }\n\n    std::cout << \"Running on device: \"\n              << device.get_info<sycl::info::device::name>().c_str()\n              << std::endl;\n\n    // declare arrays and fill them\n    // allocate in shared memory so the kernel can see them\n    int *a = sycl::malloc_shared<int>(kVectSize, q);\n    int *b = sycl::malloc_shared<int>(kVectSize, q);\n    int *c = sycl::malloc_shared<int>(kVectSize, q);\n    for (int i = 0; i < kVectSize; i++) {\n      a[i] = i;\n      b[i] = (kVectSize - i);\n    }\n\n    std::cout << \"add two vectors of size \" << kVectSize << std::endl;\n\n    q.single_task<VectorAddID>(VectorAdd{a, b, c, kVectSize}).wait();\n\n    // verify that VC is correct\n    passed = true;\n    for (int i = 0; i < kVectSize; i++) {\n      int expected = a[i] + b[i];\n      if (c[i] != expected) {\n        std::cout << \"idx=\" << i << \": result \" << c[i] << \", expected (\"\n                  << expected << \") A=\" << a[i] << \" + B=\" << b[i] << std::endl;\n        passed = false;\n      }\n    }\n\n    std::cout << (passed ? \"PASSED\" : \"FAILED\") << std::endl;\n\n    sycl::free(a, q);\n    sycl::free(b, q);\n    sycl::free(c, q);\n  } catch (sycl::exception const &e) {\n    // Catches exceptions in the host code.\n    std::cerr << \"Caught a SYCL host exception:\\n\" << e.what() << \"\\n\";\n\n    // Most likely the runtime couldn't find FPGA hardware!\n    if (e.code().value() == CL_DEVICE_NOT_FOUND) {\n      std::cerr << \"If you are targeting an FPGA, please ensure that your \"\n                   \"system has a correctly configured FPGA board.\\n\";\n      std::cerr << \"Run sys_check in the oneAPI root directory to verify.\\n\";\n      std::cerr << \"If you are targeting the FPGA emulator, compile with \"\n                   \"-DFPGA_EMULATOR.\\n\";\n    }\n    std::terminate();\n  }\n\n  return passed ? EXIT_SUCCESS : EXIT_FAILURE;\n}"
    }
]